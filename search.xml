<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker数据卷挂载宿主机</title>
    <url>/2020/05/15/Docker%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="Docker-挂载宿主机文件-目录"><a href="#Docker-挂载宿主机文件-目录" class="headerlink" title="Docker 挂载宿主机文件/目录"></a>Docker 挂载宿主机文件/目录</h1><pre><code>这个问题困扰了很久,上次挂载`redis`的配置文件,就折腾了好久,这次配置`nginx`的配置文件/目录,又忙活了两个小时,其实挂载目录是没什么的问题的,关键是加上了配置文件之后,就会导致容器启动失败,后来百般搜索,从一个大神这找到了问题 ,链接`[https://blog.csdn.net/ii19910410/article/details/88639320?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158519158119725219964887%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&amp;request_id=158519158119725219964887&amp;biz_id=0&amp;utm_source=distribute.pc_search_result.none-task](https://blog.csdn.net/ii19910410/article/details/88639320?ops_request_misc=%7B%22request%5Fid%22%3A%22158519158119725219964887%22%2C%22scm%22%3A%2220140713.130056874..%22%7D&amp;request_id=158519158119725219964887&amp;biz_id=0&amp;utm_source=distribute.pc_search_result.none-task)`.</code></pre><p>​        问题的关键是 ,再挂载配置的文件的时候,要提前将配置文件的目录创建好,将配置文件copy过来,最好是官方的配置文件,然后在挂载配置文件的这个地方,注意挂载的是文件,而不是目录. 我的运行命令如下<code>docker run -p 80:80 --name dockerNginx --privileged=true -v /yafenguse/mynginx/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /yafenguse/mynginx/nginx/conf/nginx.conf:/etc/nginx/nginx.conf  -v /yafenguse/mynginx/nginx/logs:/var/log/nginx  -v /yafenguse/mynginx/nginx/html:/usr/share/nginx/html -d nginx</code>,</p>
<p>以下是配置文件的挂载(切记提前创建):</p>
<p><code>/yafenguse/mynginx/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</code></p>
<p>最为关键的是以下命令:<code>--privileged=true</code>,原因是配置了配置文件以后,容器可能启动不成功,就使用该命令</p>
<p>​        百度之后得知,该命令相当于是已<code>root</code>权限使用    <code>docker</code>启动容器,可能是挂载宿主机的配置文件时,普通的用户权限无效吧,以下是百度的解释:</p>
<pre><code>大约在0.6版，privileged被引入docker。</code></pre><p>使用该参数，container内的root拥有真正的root权限。<br>否则，container内的root只是外部的一个普通用户权限。<br>privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。<br>甚至允许你在docker容器中启动docker容器。</p>
]]></content>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/2020/05/15/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB-Redis-database"><a href="#RDB-Redis-database" class="headerlink" title="RDB(Redis database)"></a>RDB(Redis database)</h3><p>定义 :  在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,它恢复时2是将快照文件直接读到内存里</p>
<pre><code>Redis会单独创建(fork)一个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件,整个过程中,主进程是不进行任何IO操作的</code></pre><h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3>]]></content>
  </entry>
  <entry>
    <title>MybatisPlus</title>
    <url>/2020/05/15/MybatisPlus/</url>
    <content><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a><code>MybatisPlus</code></h1><h1 id="一、wapper介绍"><a href="#一、wapper介绍" class="headerlink" title="一、wapper介绍"></a><strong>一、wapper介绍</strong></h1><p>![img](file:///C:/Users/yafeng/Documents/My Knowledge/temp/a07491cb-f54d-4437-870e-b4a9443eecac/128/index_files/27b56b5e-39a6-42ba-b7ed-4f109b6ad7bf.png)</p>
<p>Wrapper ： 条件构造抽象类，最顶端父类</p>
<p>  AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</p>
<p>​    QueryWrapper ： Entity 对象封装操作类，不是用lambda语法</p>
<p>​    UpdateWrapper ： Update 条件封装，用于Entity对象更新操作</p>
<p>  AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。</p>
<p>​    LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper</p>
<p>​    LambdaUpdateWrapper ： Lambda 更新封装Wrapper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class QueryWrapperTests &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、AbstractWrapper"><a href="#二、AbstractWrapper" class="headerlink" title="二、AbstractWrapper"></a>二、AbstractWrapper</h1><p>**<br><strong>**注意：</strong>以下条件构造器的方法入参中的 <code>column</code>均表示数据库字段</p>
<h2 id="1、ge、gt、le、lt、isNull、isNotNull"><a href="#1、ge、gt、le、lt、isNull、isNotNull" class="headerlink" title="1、ge、gt、le、lt、isNull、isNotNull"></a><strong>1、ge、gt、le、lt、isNull、isNotNull</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDelete() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">        .isNull(&quot;name&quot;)</span><br><span class="line">        .ge(&quot;age&quot;, 12)</span><br><span class="line">        .isNotNull(&quot;email&quot;);</span><br><span class="line">    int result &#x3D; userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(&quot;delete return count &#x3D; &quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：UPDATE user SET deleted=1 WHERE deleted=0 AND name IS NULL AND age &gt;= ? AND email IS NOT NULL</p>
<h2 id="2、eq、ne"><a href="#2、eq、ne" class="headerlink" title="2、eq、ne"></a><strong>2、eq、ne</strong></h2><p><strong>注意：</strong>seletOne返回的是一条实体记录，当出现多条时会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectOne() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(&quot;name&quot;, &quot;Tom&quot;);</span><br><span class="line"></span><br><span class="line">    User user &#x3D; userMapper.selectOne(queryWrapper);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SELECT id,name,age,email,create_time,update_time,deleted,version FROM user WHERE deleted=0 AND name = ? </p>
<h2 id="3、between、notBetween"><a href="#3、between、notBetween" class="headerlink" title="3、between、notBetween"></a><strong>3、between、notBetween</strong></h2><p>包含大小边界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectCount() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.between(&quot;age&quot;, 20, 30);</span><br><span class="line"></span><br><span class="line">    Integer count &#x3D; userMapper.selectCount(queryWrapper);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SELECT COUNT(1) FROM user WHERE deleted=0 AND age BETWEEN ? AND ? </p>
<h2 id="4、allEq"><a href="#4、allEq" class="headerlink" title="4、allEq"></a><strong>4、allEq</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectList() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;id&quot;, 2);</span><br><span class="line">    map.put(&quot;name&quot;, &quot;Jack&quot;);</span><br><span class="line">    map.put(&quot;age&quot;, 20);</span><br><span class="line"></span><br><span class="line">    queryWrapper.allEq(map);</span><br><span class="line">    List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SELECT id,name,age,email,create_time,update_time,deleted,version </p>
<p>FROM user WHERE deleted=0 AND name = ? AND id = ? AND age = ? </p>
<h2 id="5、like、notLike、likeLeft、likeRight"><a href="#5、like、notLike、likeLeft、likeRight" class="headerlink" title="5、like、notLike、likeLeft、likeRight"></a><strong>5、like、notLike、likeLeft、likeRight</strong></h2><p>selectMaps返回Map集合列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectMaps() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">        .notLike(&quot;name&quot;, &quot;e&quot;)</span><br><span class="line">        .likeRight(&quot;email&quot;, &quot;t&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; userMapper.selectMaps(queryWrapper);&#x2F;&#x2F;返回值是Map列表</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SELECT id,name,age,email,create_time,update_time,deleted,version </p>
<p>FROM user WHERE deleted=0 AND name NOT LIKE ? AND email LIKE ? </p>
<h2 id="6、in、notIn、inSql、notinSql、exists、notExists"><a href="#6、in、notIn、inSql、notinSql、exists、notExists" class="headerlink" title="6、in、notIn、inSql、notinSql、exists、notExists"></a><strong>6、in、notIn、inSql、notinSql、exists、notExists</strong></h2><p>in、notIn：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notIn(&quot;age&quot;,&#123;1,2,3&#125;)---&gt;age not in (1,2,3)notIn(&quot;age&quot;, 1, 2, 3)---&gt;age not in (1,2,3)</span><br></pre></td></tr></table></figure>

<p>inSql、notinSql：可以实现子查询</p>
<ul>
<li>例: <code>inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)</code>—&gt;<code>age in (1,2,3,4,5,6)</code></li>
<li>例: <code>inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)</code>—&gt;<code>id in (select id from table where id &lt; 3)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectObjs() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;queryWrapper.in(&quot;id&quot;, 1, 2, 3);</span><br><span class="line">    queryWrapper.inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; objects &#x3D; userMapper.selectObjs(queryWrapper);&#x2F;&#x2F;返回值是Object列表</span><br><span class="line">    objects.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SELECT id,name,age,email,create_time,update_time,deleted,version </p>
<p>FROM user WHERE deleted=0 AND id IN (select id from user where id &lt; 3) </p>
<h2 id="7、or、and"><a href="#7、or、and" class="headerlink" title="7、or、and"></a><strong>7、or、and</strong></h2><p><strong>注意：</strong>这里使用的是 UpdateWrapper </p>
<p>不调用<code>or</code>则默认为使用 <code>and</code>连</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdate1() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改值</span><br><span class="line">    User user &#x3D; new User();</span><br><span class="line">    user.setAge(99);</span><br><span class="line">    user.setName(&quot;Andy&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改条件</span><br><span class="line">    UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">    userUpdateWrapper</span><br><span class="line">        .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">        .or()</span><br><span class="line">        .between(&quot;age&quot;, 20, 30);</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line"></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UPDATE user SET name=?, age=?, update_time=? WHERE deleted=0 AND name LIKE ? OR age BETWEEN ? AND ?</p>
<h2 id="8、嵌套or、嵌套and"><a href="#8、嵌套or、嵌套and" class="headerlink" title="8、嵌套or、嵌套and"></a><strong>8、嵌套or、嵌套and</strong></h2><p>这里使用了lambda表达式，or中的表达式最后翻译成sql时会被加上圆括号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdate2() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改值</span><br><span class="line">    User user &#x3D; new User();</span><br><span class="line">    user.setAge(99);</span><br><span class="line">    user.setName(&quot;Andy&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改条件</span><br><span class="line">    UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">    userUpdateWrapper</span><br><span class="line">        .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">        .or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;age&quot;, 20));</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line"></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UPDATE user SET name=?, age=?, update_time=? </p>
<p>WHERE deleted=0 AND name LIKE ? </p>
<p>OR ( name = ? AND age &lt;&gt; ? ) </p>
<h2 id="9、orderBy、orderByDesc、orderByAsc"><a href="#9、orderBy、orderByDesc、orderByAsc" class="headerlink" title="9、orderBy、orderByDesc、orderByAsc"></a><strong>9、orderBy、orderByDesc、orderByAsc</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectListOrderBy() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.orderByDesc(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SELECT id,name,age,email,create_time,update_time,deleted,version </p>
<p>FROM user WHERE deleted=0 ORDER BY id DESC </p>
<h2 id="10、last"><a href="#10、last" class="headerlink" title="10、last"></a><strong>10、last</strong></h2><p>直接拼接到 sql 的最后</p>
<p><strong>注意：</strong>只能调用一次,多次调用以最后一次为准 有sql注入的风险,请谨慎使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectListLast() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.last(&quot;limit 1&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SELECT id,name,age,email,create_time,update_time,deleted,version </p>
<p>FROM user WHERE deleted=0 limit 1 </p>
<h2 id="11、指定要查询的列"><a href="#11、指定要查询的列" class="headerlink" title="11、指定要查询的列"></a><strong>11、</strong>指定要查询的列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectListColumn() &#123;</span><br><span class="line"></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">    queryWrapper.select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SELECT id,name,age FROM user WHERE deleted=0 </p>
<h2 id="12、set、setSql"><a href="#12、set、setSql" class="headerlink" title="12、set、setSql"></a><strong>12、set、setSql</strong></h2><p>最终的sql会合并 user.setAge()，以及 userUpdateWrapper.set()  和 setSql() 中 的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdateSet() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改值</span><br><span class="line">    User user &#x3D; new User();</span><br><span class="line">    user.setAge(99);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改条件</span><br><span class="line">    UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">    userUpdateWrapper</span><br><span class="line">        .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">        .set(&quot;name&quot;, &quot;老李头&quot;)&#x2F;&#x2F;除了可以查询还可以使用set设置修改的字段</span><br><span class="line">        .setSql(&quot; email &#x3D; &#39;123@qq.com&#39;&quot;);&#x2F;&#x2F;可以有子查询</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UPDATE user SET age=?, update_time=?, name=?, email = ‘123@qq.com’ WHERE deleted=0 AND name LIKE ? </p>
<h1 id="一、insert"><a href="#一、insert" class="headerlink" title="一、insert"></a><strong>一、insert</strong></h1><h2 id="1、插入操作"><a href="#1、插入操作" class="headerlink" title="1、插入操作"></a><strong>1、插入操作</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class CRUDTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testInsert()&#123;</span><br><span class="line"></span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setName(&quot;Helen&quot;);</span><br><span class="line">        user.setAge(18);</span><br><span class="line">        user.setEmail(&quot;55317332@qq.com&quot;);</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.insert(user);</span><br><span class="line">        System.out.println(result); &#x2F;&#x2F;影响的行数</span><br><span class="line">        System.out.println(user); &#x2F;&#x2F;id自动回填</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>数据库插入id值默认为：全局唯一id</p>
<p>![img](file:///C:/Users/yafeng/Documents/My Knowledge/temp/67ccbd19-bf21-41d8-a8a6-b88f3512aed9/128/index_files/93ff417f-c9f7-4225-b395-2afe2776183d.jpg)</p>
<h2 id="2、主键策略"><a href="#2、主键策略" class="headerlink" title="2、主键策略"></a>2、主键策略</h2><p><strong>（1）ID_WORKER</strong></p>
<p>MyBatis-Plus默认的主键策略是：ID_WORKER  <em>全局唯一ID</em></p>
<p><strong>参考资料：分布式系统唯一ID生成方案汇总：</strong><a href="https://www.cnblogs.com/haoxinyue/p/5208136.html" target="_blank" rel="noopener">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p>
<p><strong>（2）自增策略</strong></p>
<ul>
<li><p>要想主键自增需要配置如下主键策略</p>
</li>
<li><ul>
<li>需要在创建数据表的时候设置主键自增</li>
<li>实体字段中配置 @TableId(type = IdType.AUTO)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@TableId(type &#x3D; IdType.AUTO)</span><br><span class="line">private Long id;</span><br></pre></td></tr></table></figure>

<p>要想影响所有实体的配置，可以设置全局主键配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局设置主键生成策略</span><br><span class="line">mybatis-plus.global-config.db-config.id-type&#x3D;auto</span><br></pre></td></tr></table></figure>

<p>其它主键策略：分析 IdType 源码可知</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum IdType &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数据库ID自增</span><br><span class="line">     *&#x2F;</span><br><span class="line">    AUTO(0),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 该类型为未设置主键类型</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NONE(1),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用户输入ID</span><br><span class="line">     * 该类型可以通过自己注册自动填充插件进行填充</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INPUT(2),</span><br><span class="line"></span><br><span class="line">    &#x2F;* 以下3种类型、只有当插入对象ID 为空，才自动填充。 *&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 全局唯一ID (idWorker)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ID_WORKER(3),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 全局唯一ID (UUID)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    UUID(4),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 字符串全局唯一ID (idWorker 的字符串表示)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ID_WORKER_STR(5);</span><br><span class="line"></span><br><span class="line">    private int key;</span><br><span class="line"></span><br><span class="line">    IdType(int key) &#123;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、update"><a href="#二、update" class="headerlink" title="二、update"></a>二、update</h1><h2 id="1、根据Id更新操作"><a href="#1、根据Id更新操作" class="headerlink" title="1、根据Id更新操作"></a><strong>1、根据Id更新操作</strong></h2><p><strong>注意：</strong>update时生成的sql自动是动态sql：UPDATE user SET age=? WHERE id=? </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdateById()&#123;</span><br><span class="line"></span><br><span class="line">    User user &#x3D; new User();</span><br><span class="line">    user.setId(1L);</span><br><span class="line">    user.setAge(28);</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.updateById(user);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、自动填充"><a href="#2、自动填充" class="headerlink" title="2、自动填充"></a>2、自动填充</h2><p>项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等。</p>
<p>我们可以使用MyBatis Plus的自动填充功能，完成这些字段的赋值工作：</p>
<p><strong>（1）数据库表中添加自动填充字段</strong></p>
<p>在User表中添加datetime类型的新的字段 create_time、update_time</p>
<p><strong>（2）实体上添加注解</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    @TableField(fill &#x3D; FieldFill.INSERT)</span><br><span class="line">    private Date createTime;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;@TableField(fill &#x3D; FieldFill.UPDATE)</span><br><span class="line">    @TableField(fill &#x3D; FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）实现元对象处理器接口</strong></p>
<p><strong>注意：不要忘记添加 @Component 注解</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.atguigu.mybatisplus.handler;</span><br><span class="line">import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line">import org.apache.ibatis.reflection.MetaObject;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(MyMetaObjectHandler.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        LOGGER.info(&quot;start insert fill ....&quot;);</span><br><span class="line">        this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject);</span><br><span class="line">        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        LOGGER.info(&quot;start update fill ....&quot;);</span><br><span class="line">        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）测试</strong></p>
<h2 id="3、乐观锁"><a href="#3、乐观锁" class="headerlink" title="3、乐观锁"></a>3、乐观锁</h2><p><strong>主要适用场景：</strong>当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新</p>
<p><strong>乐观锁实现方式：</strong></p>
<ul>
<li>取出记录时，获取当前version</li>
<li>更新时，带上这个version</li>
<li>执行更新时， set version = newVersion where version = oldVersion</li>
<li>如果version不对，就更新失败</li>
</ul>
<p><strong><em>\</em>（1）数据库中添加version字段**</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#96;user&#96; ADD COLUMN &#96;version&#96; INT</span><br></pre></td></tr></table></figure>



<p>![img](file:///C:/Users/yafeng/Documents/My Knowledge/temp/67ccbd19-bf21-41d8-a8a6-b88f3512aed9/128/index_files/7bf260f8-d483-49fe-b448-b2fbea3dddaf.png)</p>
<p><strong><em>\</em>（2）实体类添加version字段**</strong></p>
<p>并添加 @Version 注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Version</span><br><span class="line">@TableField(fill &#x3D; FieldFill.INSERT)</span><br><span class="line">private Integer version;</span><br></pre></td></tr></table></figure>

<p><strong><em>\</em>（3）元对象处理器接口添加version的insert默认值**</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">    ......</span><br><span class="line">    this.setFieldValByName(&quot;version&quot;, 1, metaObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特别说明:</strong></p>
<p>支持的数据类型只有 int,Integer,long,Long,Date,Timestamp,LocalDateTime整数类型下 <code>newVersion = oldVersion + 1``newVersion</code> 会回写到 <code>entity</code> 中仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法在 <code>update(entity, wrapper)</code> 方法下, <code>wrapper</code> 不能复用!!!</p>
<p><strong>（4）\</strong>在 MybatisPlusConfig 中注册 Bean****</p>
<p>创建配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.atguigu.mybatisplus.config;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;</span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.atguigu.mybatis_plus.mapper&quot;)</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 乐观锁插件</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;</span><br><span class="line">        return new OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（5）测试乐观锁可以修改成功</strong></p>
<p>测试后分析打印的sql语句，将version的数值进行了加1操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试 乐观锁插件</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testOptimisticLocker() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查询</span><br><span class="line">    User user &#x3D; userMapper.selectById(1L);</span><br><span class="line">    &#x2F;&#x2F;修改数据</span><br><span class="line">    user.setName(&quot;Helen Yao&quot;);</span><br><span class="line">    user.setEmail(&quot;helen@qq.com&quot;);</span><br><span class="line">    &#x2F;&#x2F;执行更新</span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（5）测试乐观锁修改失败</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试乐观锁插件 失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testOptimisticLockerFail() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查询</span><br><span class="line">    User user &#x3D; userMapper.selectById(1L);</span><br><span class="line">    &#x2F;&#x2F;修改数据</span><br><span class="line">    user.setName(&quot;Helen Yao1&quot;);</span><br><span class="line">    user.setEmail(&quot;helen@qq.com1&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;模拟取出数据后，数据库中version实际数据比取出的值大，即已被其它线程修改并更新了version</span><br><span class="line">    user.setVersion(user.getVersion() - 1);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行更新</span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、select"><a href="#三、select" class="headerlink" title="三、select"></a><strong>三、select</strong></h1><h2 id="1、根据id查询记录"><a href="#1、根据id查询记录" class="headerlink" title="1、根据id查询记录"></a><strong>1、根据id查询记录</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectById()&#123;</span><br><span class="line"></span><br><span class="line">    User user &#x3D; userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、通过多个id批量查询"><a href="#2、通过多个id批量查询" class="headerlink" title="2、通过多个id批量查询"></a><strong>2、通过多个id批量查询</strong></h2><p>完成了动态sql的foreach的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectBatchIds()&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users &#x3D; userMapper.selectBatchIds(Arrays.asList(1, 2, 3));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、简单的条件查询"><a href="#3、简单的条件查询" class="headerlink" title="3、简单的条件查询"></a><strong>3、简单的条件查询</strong></h2><p>通过map封装查询条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectByMap()&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;name&quot;, &quot;Helen&quot;);</span><br><span class="line">    map.put(&quot;age&quot;, 18);</span><br><span class="line">    List&lt;User&gt; users &#x3D; userMapper.selectByMap(map);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>map中的key对应的是数据库中的列名。例如数据库user_id，实体类是userId，这时map的key需要填写user_id</p>
<h2 id="4、分页"><a href="#4、分页" class="headerlink" title="4、分页"></a>4、分页</h2><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p>
<p><strong>（1）创建配置类</strong></p>
<p>此时可以删除主类中的 <em>@MapperScan</em> 扫描注解**<br>**</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 分页插件</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Bean</span><br><span class="line">public PaginationInterceptor paginationInterceptor() &#123;</span><br><span class="line">    return new PaginationInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）测试selectPage分页</strong></p>
<p><strong>测试：</strong>最终通过page对象获取相关数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectPage() &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(1,5);</span><br><span class="line">    userMapper.selectPage(page, null);</span><br><span class="line"></span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.hasNext());</span><br><span class="line">    System.out.println(page.hasPrevious());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台sql语句打印：SELECT id,name,age,email,create_time,update_time FROM user LIMIT 0,5 </p>
<p><strong>（3）测试selectMapsPage分页：结果集是Map</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectMapsPage() &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(1, 5);</span><br><span class="line"></span><br><span class="line">    IPage&lt;Map&lt;String, Object&gt;&gt; mapIPage &#x3D; userMapper.selectMapsPage(page, null);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意：此行必须使用 mapIPage 获取记录列表，否则会有数据类型转换错误</span><br><span class="line">    mapIPage.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.hasNext());</span><br><span class="line">    System.out.println(page.hasPrevious());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、delete"><a href="#四、delete" class="headerlink" title="四、delete"></a>四、delete</h1><h2 id="1、根据id删除记录"><a href="#1、根据id删除记录" class="headerlink" title="1、根据id删除记录"></a><strong>1、根据id删除记录</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.deleteById(8L);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、批量删除"><a href="#2、批量删除" class="headerlink" title="2、批量删除"></a><strong>2、批量删除</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteBatchIds() &#123;</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.deleteBatchIds(Arrays.asList(8, 9, 10));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、简单的条件查询删除"><a href="#3、简单的条件查询删除" class="headerlink" title="3、简单的条件查询删除"></a><strong>3、简单的条件查询删除</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteByMap() &#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;name&quot;, &quot;Helen&quot;);</span><br><span class="line">    map.put(&quot;age&quot;, 18);</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、逻辑删除"><a href="#4、逻辑删除" class="headerlink" title="4、逻辑删除"></a>4、逻辑删除</h2><ul>
<li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除数据</li>
<li>逻辑删除：假删除，将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li>
</ul>
<p><strong>（1）数据库中添加 deleted字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#96;user&#96; ADD COLUMN &#96;deleted&#96; boolean</span><br></pre></td></tr></table></figure>

<p>![img](file:///C:/Users/yafeng/Documents/My Knowledge/temp/67ccbd19-bf21-41d8-a8a6-b88f3512aed9/128/index_files/bc4cbff4-c2b8-45d5-ae8d-53439dd2330c.png)</p>
<p><strong>（2）实体类添加deleted \</strong>字段****</p>
<p>并加上 @TableLogic 注解 和 @TableField(fill = FieldFill.INSERT) 注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@TableLogic</span><br><span class="line">@TableField(fill &#x3D; FieldFill.INSERT)</span><br><span class="line">private Integer deleted;</span><br></pre></td></tr></table></figure>

<p><strong>（3）元对象处理器接口添加deleted的insert默认值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">    ......</span><br><span class="line">    this.setFieldValByName(&quot;deleted&quot;, 0, metaObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）application.properties 加入配置</strong></p>
<p>此为默认值，如果你的默认值和mp默认的一样,该配置可无</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.logic-delete-value&#x3D;1</span><br><span class="line">mybatis-plus.global-config.db-config.logic-not-delete-value&#x3D;0</span><br></pre></td></tr></table></figure>

<p><strong>（5）在 MybatisPlusConfig 中注册 Bean</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ISqlInjector sqlInjector() &#123;</span><br><span class="line">    return new LogicSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）测试逻辑删除</strong></p>
<ul>
<li>测试后发现，数据并没有被删除，deleted字段的值由0变成了1</li>
<li>测试后分析打印的sql语句，是一条update</li>
<li><strong>注意：</strong>被删除数据的deleted 字段的值必须是 0，才能被选取出来执行逻辑删除的操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试 逻辑删除</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testLogicDelete() &#123;</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.deleteById(1L);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（7）测试逻辑删除后的查询</strong></p>
<p>MyBatis Plus中查询操作也会自动添加逻辑删除字段的判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试 逻辑删除后的查询：</span><br><span class="line"> * 不包括被逻辑删除的记录</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testLogicDeleteSelect() &#123;</span><br><span class="line">    User user &#x3D; new User();</span><br><span class="line">    List&lt;User&gt; users &#x3D; userMapper.selectList(null);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试后分析打印的sql语句，包含 WHERE deleted=0 </p>
<p>SELECT id,name,age,email,create_time,update_time,deleted FROM user WHERE deleted=0</p>
<h1 id="五、性能分析"><a href="#五、性能分析" class="headerlink" title="五、性能分析"></a>五、性能分析</h1><p>性能分析拦截器，用于输出每条 SQL 语句及其执行时间</p>
<p>SQL 性能执行分析,开发环境使用，超过指定时间，停止运行。有助于发现问题</p>
<h2 id="1、配置插件"><a href="#1、配置插件" class="headerlink" title="1、配置插件"></a>1、配置插件</h2><p><strong>（1）参数说明</strong></p>
<p>参数：maxTime： SQL 执行最大时长，超过自动停止运行，有助于发现问题。</p>
<p>参数：format： SQL是否格式化，默认false。</p>
<p><strong>（2）在 MybatisPlusConfig 中配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * SQL 执行性能分析插件</span><br><span class="line"> * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Bean</span><br><span class="line">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)&#x2F;&#x2F; 设置 dev test 环境开启</span><br><span class="line">public PerformanceInterceptor performanceInterceptor() &#123;</span><br><span class="line">    PerformanceInterceptor performanceInterceptor &#x3D; new PerformanceInterceptor();</span><br><span class="line">    performanceInterceptor.setMaxTime(100);&#x2F;&#x2F;ms，超过此处设置的ms则sql不执行</span><br><span class="line">    performanceInterceptor.setFormat(true);</span><br><span class="line">    return performanceInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）Spring Boot 中设置dev环境</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#环境设置：dev、test、prod</span><br><span class="line">spring.profiles.active&#x3D;dev</span><br></pre></td></tr></table></figure>

<p>可以针对各环境新建不同的配置文件<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code></p>
<p>也可以自定义环境名称：如test1、test2</p>
<h2 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h2><p><strong>（1）常规测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试 性能分析插件</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testPerformance() &#123;</span><br><span class="line">    User user &#x3D; new User();</span><br><span class="line">    user.setName(&quot;我是Helen&quot;);</span><br><span class="line">    user.setEmail(&quot;helen@sina.com&quot;);</span><br><span class="line">    user.setAge(18);</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<p>![img](file:///C:/Users/yafeng/Documents/My Knowledge/temp/67ccbd19-bf21-41d8-a8a6-b88f3512aed9/128/index_files/bb355a17-3cdc-4f0a-82f2-232defbd235b.png)</p>
<p><strong>（2）将maxTime 改小之后再次进行测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">performanceInterceptor.setMaxTime(5);&#x2F;&#x2F;ms，超过此处设置的ms不执行</span><br></pre></td></tr></table></figure>

<p>如果执行时间过长，则抛出异常：The SQL execution time is too large, </p>
<p><strong>输出：</strong></p>
<p>![img](file:///C:/Users/yafeng/Documents/My Knowledge/temp/67ccbd19-bf21-41d8-a8a6-b88f3512aed9/128/index_files/1ae5ae68-b6b2-4801-ae26-29835b175b24.png)</p>
<h1 id="六、其它"><a href="#六、其它" class="headerlink" title="六、其它"></a>六、其它</h1><p>如果想进行复杂条件查询，那么需要使用条件构造器 Wapper，涉及到如下方法</p>
<p><strong>1、delete</strong></p>
<p><strong>2、selectOne</strong></p>
<p><strong>3、selectCount</strong></p>
<p><strong>4、selectList</strong></p>
<p><strong>5、selectMaps</strong></p>
<p><strong>6、selectObjs</strong></p>
<p><strong>7、update</strong></p>
<h3 id="1-mybatisplus查询某一天的数据-条件构造器"><a href="#1-mybatisplus查询某一天的数据-条件构造器" class="headerlink" title="1. mybatisplus查询某一天的数据(条件构造器)"></a>1. <code>mybatisplus</code>查询某一天的数据(条件构造器)</h3><p>​        首先,对于复杂的查询,只往查询条件里面塞一个实体是解决不了的,就需要</p>
<p><code>new QueryWrapper&lt;&gt;(entity).apply(&quot;date_format(create_time,&#39;%Y-%m-%d&#39;) = &#39;&quot;+createTime+&quot;&#39;&quot;).orderByDesc(&quot;create_time&quot;).select(ConstansValue.sampleOrderList));</code></p>
<p>先new 一个 QueryWrapper传入相应的参数,进行对应的操作(有很多),也有对应的updateWrapper,再已提供的方法不够用时,可以使用appley(“”),相当于自定义一个方法,也就是拼sql.</p>
<p>这里的问题是使用的mysql的格式化时间函数,将数据库中的createTime格式化为<code>yyyy-MM-dd</code>的格式,再将传进来的参数也格式化为该格式然后做=匹配 .可能效率略差</p>
<p>复杂的查询可以参考mybatisplus的条件构造器,但是也要考虑传空值的情况</p>
]]></content>
  </entry>
  <entry>
    <title>SSH框架</title>
    <url>/2020/05/15/SSH%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>1.加入Spring</p>
<p>2.加入Hibernate</p>
<p>3.同时持久化类,和对应的.hbm.xml文件</p>
<p>4.Spring整合Hibernate</p>
<p>5.加入Strust2</p>
]]></content>
  </entry>
  <entry>
    <title>idea快捷键</title>
    <url>/2020/05/15/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p><strong>自动代码</strong></p>
<p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。</p>
<p><em>例如要输入for(User user : users)只需输入user.for+Tab ；</em></p>
<p><em>再比如，要输入Date birthday = user.getBirthday()只需输入user.getBirthday().var+Tab即可。</em></p>
<p>代码标签输入完成后，按Tab，生成代码。</p>
<ol>
<li>Ctrl+Alt+O 优化导入的类和包 </li>
<li>Alt+Insert 生成代码(如get,set方法,构造函数等)  或者右键（Generate） </li>
<li>fori/sout/psvm + Tab </li>
<li>Ctrl+Alt+T 生成try catch 或者 Alt+enter </li>
<li>CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 </li>
<li>Ctrl + O 重写方法 </li>
<li>Ctrl + I 实现方法 </li>
<li>Ctr+shift+U 大小写转化 </li>
<li>ALT+回车  导入包,自动修正 </li>
<li>ALT+/    代码提示 </li>
<li>CTRL+J   自动代码 </li>
<li>Ctrl+Shift+J，整合两行为一行 </li>
<li>CTRL+空格  代码提示 </li>
<li>CTRL+SHIFT+SPACE 自动补全代码 </li>
<li>CTRL+ALT+L 格式化代码 </li>
<li>CTRL+ALT+I 自动缩进 </li>
<li>CTRL+ALT+O 优化导入的类和包 </li>
<li>ALT+INSERT 生成代码(如GET,SET方法,构造函数等) </li>
<li>CTRL+E   最近更改的代码 </li>
<li>CTRL+ALT+SPACE 类名或接口名提示 </li>
<li>CTRL+P  方法参数提示 </li>
<li>CTRL+Q，可以看到当前方法的声明 </li>
<li>Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) </li>
<li>Ctrl+Alt+V 提取变量 </li>
</ol>
<p><strong>查询快捷键</strong></p>
<ol>
<li>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </li>
<li>CTRL+ALT+ left/right 前后导航编辑过的地方 </li>
<li>ALT+7 靠左窗口显示当前文件的结构 </li>
<li>Ctrl+F12 浮动显示当前文件的结构 </li>
<li>ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </li>
<li>CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 </li>
<li>Ctrl+Shift+Alt+N 查找类中的方法或变量 </li>
<li>双击SHIFT 在项目的所有目录查找文件 </li>
<li>Ctrl+N  查找类 </li>
<li>Ctrl+Shift+N 查找文件 </li>
<li>CTRL+G  定位行 </li>
<li>CTRL+F  在当前窗口查找文本 </li>
<li>CTRL+SHIFT+F 在指定窗口查找文本 </li>
<li>CTRL+R  在 当前窗口替换文本 </li>
<li>CTRL+SHIFT+R 在指定窗口替换文本 </li>
<li>ALT+SHIFT+C 查找修改的文件 </li>
<li>CTRL+E  最近打开的文件 </li>
<li>F3  向下查找关键字出现位置 </li>
<li>SHIFT+F3 向上一个关键字出现位置 </li>
<li>选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 </li>
<li>F4  查找变量来源 </li>
<li>CTRL+SHIFT+O 弹出显示查找内容 </li>
<li>Ctrl+W 选中代码，连续按会有其他效果 </li>
<li>F2 或Shift+F2 高亮错误或警告快速定位 </li>
<li>Ctrl+Up/Down 光标跳转到第一行或最后一行下 </li>
<li>Ctrl+B 快速打开光标处的类或方法 </li>
<li>CTRL+ALT+B 找所有的子类 </li>
<li>CTRL+SHIFT+B 找变量的类 </li>
<li>Ctrl+Shift+上下键 上下移动代码 </li>
<li>Ctrl+Alt+ left/right 返回至上次浏览的位置 </li>
<li>Ctrl+X 删除行 </li>
<li>Ctrl+D 复制行 </li>
<li>Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/<em>…</em>/ ） </li>
<li>Ctrl+H 显示类结构图 </li>
<li>Ctrl+Q 显示注释文档 </li>
<li>Alt+F1 查找代码所在位置 </li>
<li>Alt+1 快速打开或隐藏工程面板 </li>
<li>Alt+ left/right 切换代码视图 </li>
<li>ALT+ ↑/↓ 在方法间快速移动定位 </li>
<li>CTRL+ALT+ left/right 前后导航编辑过的地方 </li>
<li>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 </li>
<li>Alt+6  查找TODO </li>
</ol>
<p><strong>其他快捷键</strong></p>
<ol>
<li>SHIFT+ENTER 另起一行 </li>
<li>CTRL+Z  倒退(撤销) </li>
<li>CTRL+SHIFT+Z 向前(取消撤销) </li>
<li>CTRL+ALT+F12 资源管理器打开文件夹 </li>
<li>ALT+F1  查找文件所在目录位置 </li>
<li>SHIFT+ALT+INSERT 竖编辑模式 </li>
<li>CTRL+F4 关闭当前窗口 </li>
<li>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 </li>
<li>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） </li>
</ol>
<p><strong>svn快捷键</strong></p>
<ol>
<li>ctrl+k 提交代码到SVN </li>
<li>ctrl+t 更新代码 </li>
</ol>
<p><strong>调试快捷键</strong></p>
<p>其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。</p>
<ol>
<li>alt+F8  debug时选中查看值 </li>
<li>Alt+Shift+F9，选择 Debug </li>
<li>Alt+Shift+F10，选择 Run </li>
<li>Ctrl+Shift+F9，编译 </li>
<li>Ctrl+Shift+F8，查看断点 </li>
<li>F7，步入 </li>
<li>Shift+F7，智能步入 </li>
<li>Alt+Shift+F7，强制步入 </li>
<li>F8，步过 </li>
<li>Shift+F8，步出 </li>
<li>Alt+Shift+F8，强制步过 </li>
<li>Alt+F9，运行至光标处 </li>
<li>Ctrl+Alt+F9，强制运行至光标处 </li>
<li>F9，恢复程序 </li>
<li>Alt+F10，定位到断点 </li>
</ol>
<p><strong>重构</strong></p>
<ol>
<li>Ctrl+Alt+Shift+T，弹出重构菜单 </li>
<li>Shift+F6，重命名 </li>
<li>F6，移动 </li>
<li>F5，复制 </li>
<li>Alt+Delete，安全删除 </li>
<li>Ctrl+Alt+N，内联 </li>
</ol>
<p><strong>十大Intellij IDEA快捷键</strong> </p>
<p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 </p>
<p>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 </p>
<p><strong>1 智能提示:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.2.1\bin\jetbrains-agent.jar</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>redis配置文件</title>
    <url>/2020/05/15/redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="redis-conf配置"><a href="#redis-conf配置" class="headerlink" title="redis.conf配置"></a>redis.conf配置</h2><p>redis.conf配置说明如下 ：</p>
<ol>
<li>Redis默认不是以守护线程的方式运行,可以通过该配置项修改,使用yes启用守护线程, daemonize</li>
</ol>
<p>yes</p>
<ol start="2">
<li><p>当Redis以守护线程运行时,Redis默认会把pid写入/run/redis.pid文件,可以通过profile指定 pidfile/var/run/redis.pid</p>
</li>
<li><p>指定Redis监听端口,默认端口为6379,作者在自己的一篇博文中解释了为什么选用6379作为端口,因为6379在手机上上的按键MERZ的对应的号码,而MERZ取自意大利歌女Alessia Merz的名字 </p>
</li>
</ol>
<p>port 6379</p>
<ol start="4">
<li>绑定的主机地址 : bind 127.0.0.1</li>
</ol>
<p>​     假如需要远程访问的话需将其注释<code>#</code>,或者改为0.0.0.0</p>
<ol start="5">
<li><p>当客户端闲置多长时间后关闭连接,如果时间为0,表示关闭该功能, timeout 300</p>
</li>
<li><p>指定日志记录级别,Redis总共支持四个级别: debug, verbose, notice, warning, 摩尔恩为verbose</p>
</li>
<li><p>日志记录方式,默认为标准输出, 如果配置Redis为守护线程方式运行,而这里又配置为日志记录方式为标注输出,则日志会发送给/dev/null/logfile stdout</p>
</li>
<li><p>设置数据库的数量,默认数据库为0,可以使用SELECT<dbid>命令在连接指定数据库id</p>
<p>database 16</p>
</li>
<li><p>指定在多长时间内,有多少次更新操作,就讲数据同步到数据文件,可以多个条件配合 save<seconds><changes></p>
</li>
</ol>
<p>redis默认配置文件中提供了三个条件 :</p>
<p>save 900 1 </p>
<p>save 300 10</p>
<p>save 60 10000</p>
<p>分别表示900秒(15分钟)内有1个更改,300秒(5分钟)内有10个更改以及60秒有10000个更改</p>
<ol start="10">
<li><p>指定存储至本地数据库时是否压缩数据,默认为YES,Redis采用LZF压缩,如果为了节省CPU时间,可以关闭该选项, 但会导致数据库文件变的巨大, rdbcompression yes</p>
</li>
<li><p>指定本地数据库文件名, 默认值为 dump.db    dbfilename dump.db</p>
</li>
<li><p>指定本地数据库存放目录     dir./</p>
</li>
<li><p>设置当本机为slav服务时, 设置master服务的IP地址及端口,在Redis启动时, 它会主动从master进行数据同步,  slaveof<masterip><masterport></p>
</li>
<li><p>当master服务设置了密码保护时,salv服务连接master的密码    masterauth <master-password></p>
</li>
<li><p>设置Redis连接密码,如果配置了连接密码,客户端在连接Redis时需要通过 AUTH<password>命令提供密码,默认关闭  requirepass fobared</p>
</li>
<li><p>设置同一时间最大客户端连接数,默认无限制,Redis可以同时打开的客户端数为为Redis进程可以打开的最大文件描述符数,如果设置maxclients 0, 如果不做限制.当客户端连接数达到限制时,Redis会关闭新的连接并向客户端返回 max number of clients reched错误信息</p>
</li>
<li><p>指定Redis最大内存限制,Redis在启动时会把数据加载到内存中, 达到最大内存后, Redis会先尝试清楚已到期或即将到期的key, 当此方法处理后,仍达到最大内存设置,将无法再进行写入操作,但仍可以进行读取操作,Redis新的vm机制,会把key存到内存,value存到swap区 maxmemory<bytes></p>
</li>
<li><p>指定是否每次更新操作后进行日志同步记录, Redis在默认情况下是异步的把数据写入磁盘, 如果不开启, 可能会在断电时导致一段时间内的数据消失. 因为Redis本身同步数据文件是按上面save条件来同步的,所以有的数据会在一段时间内只存在内存中,默认为 no    appendonly no</p>
</li>
<li><p>指定更新日志文件名, 默认为appendonly.aof      apppendfiename appendonly.aof</p>
</li>
<li><p>指定跟新日志条件, 共有3个可选值 : </p>
</li>
<li><p>no : 表示等操作系统进行数据缓存同步到磁盘</p>
<p>always : 表示你每次更新操作后手动地调用fsnc()将数据写到磁盘(慢,安全)</p>
<p>everysec : 表示每秒同步一次 (折中,默认值)</p>
</li>
<li><p>虚拟内存文件路径, 默认值为 /tem/redis.swap, 不可多个Redis实例共享 vm-swap-file/temp/redis.swap</p>
</li>
<li><p>将所有大于vm-max-momory的数据存入虚拟内存,无论vm-max-memory设置多小, 所有索引数据都是内存存储的(Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实所有value都存在于磁盘,默认值为0     vm-max-memory 0 </p>
</li>
<li><p>Redis swap文件分成了很多的page,一个对象可以保存多个page上面, 但一个page上不能被多个对象共享, vm-page-size是要根据储存的数据大小来设定的, 作者建议如果存储很多小对象,page的大小最好设置为32或者64bytes;如果存储很大对象,则可以使用更大的page,如果不确定, 就使用默认值  vm-page-size 32</p>
</li>
<li><p>设置swap文件中的page数量,由于页表(一种表示页面空闲或使用的bitmap)是放在内存中的, 在磁盘上每8个pages将消耗一个byte的内存, vm-pages 134217728</p>
</li>
<li><p>设置访问swap问价你的线程数,最好不要超过及其的核数, 如果设置为0, 那么所有的swap文件都是串行的, 可能会造成比较长的延迟,默认值为4 vm-max-threads 4 </p>
</li>
<li><p>上设置在向客户端应答时,是否把较小的包合并为一个包发送,默认为开启,  glueoutputbuf     yes</p>
</li>
<li><p>指定在超过一定的数量户或者最大的元素超过某一临界值时,采用一种特殊的哈希算法, hash-max-zipmap-entries   64        hash-max-zipmap-values  512</p>
</li>
<li><p>指定是否激活重置哈希,默认为开启   activerehashing yes</p>
</li>
<li><p>指定包含其他的配置文件, 可以在同一主机上多个Redis实例主键使用同一配置文件, 而同时各个实例又拥有自己的特定配置文件, include /path / to/local.conf</p>
<h4 id="总结-在linux系统上-配置文件很重要-因为没有图形界面-所以几乎所以所有的更改配置的操作都是通过修改配置文件来完成的-等同于windows的设置-在更改的时候最好将配置文件-xxxx-conf单独copy一份来修改-这样可以避免修改错误不能回滚-修改完成后可以通过这份新的配置文件来启动应用-达到修改配置的目的"><a href="#总结-在linux系统上-配置文件很重要-因为没有图形界面-所以几乎所以所有的更改配置的操作都是通过修改配置文件来完成的-等同于windows的设置-在更改的时候最好将配置文件-xxxx-conf单独copy一份来修改-这样可以避免修改错误不能回滚-修改完成后可以通过这份新的配置文件来启动应用-达到修改配置的目的" class="headerlink" title="总结  : 在linux系统上,配置文件很重要,因为没有图形界面,所以几乎所以所有的更改配置的操作都是通过修改配置文件来完成的,等同于windows的设置,在更改的时候最好将配置文件 xxxx.conf单独copy一份来修改,这样可以避免修改错误不能回滚,修改完成后可以通过这份新的配置文件来启动应用,达到修改配置的目的"></a>总结  : 在linux系统上,配置文件很重要,因为没有图形界面,所以几乎所以所有的更改配置的操作都是通过修改配置文件来完成的,等同于windows的设置,在更改的时候最好将配置文件 xxxx.conf单独copy一份来修改,这样可以避免修改错误不能回滚,修改完成后可以通过这份新的配置文件来启动应用,达到修改配置的目的</h4></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2020/05/15/Redis/</url>
    <content><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><code>Redis</code></h2><h3 id="非关系型数据库的四种形式"><a href="#非关系型数据库的四种形式" class="headerlink" title="非关系型数据库的四种形式"></a>非关系型数据库的四种形式</h3><p>键值 : <code>Redis</code></p>
<p>列存储数据库 : <code>HBase</code></p>
<p>文档型数据库 : <code>MongoDB</code></p>
<p>图形数据库 : <code>Neo4J</code>,<code>infoGrid</code></p>
<h3 id="传统数据库的四大特性"><a href="#传统数据库的四大特性" class="headerlink" title="传统数据库的四大特性"></a>传统数据库的四大特性</h3><p>ACID</p>
<p><code>Atomictiy</code> : 原子性</p>
<p><code>Consistency</code> :  一致性</p>
<p><code>Isolation</code> :  独立性</p>
<p><code>Durability</code> :  持久性</p>
<h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p>CAP</p>
<p><code>Consistency</code> : 强一致性</p>
<p><code>Availability</code> : 可用性</p>
<p><code>Partiton  tolerance</code>: 分区容错性</p>
<p>只能满足两个</p>
<h3 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h3><h4 id="3V-3高"><a href="#3V-3高" class="headerlink" title="3V+3高 :"></a>3V+3高 :</h4><h5 id="大数据时代的3v"><a href="#大数据时代的3v" class="headerlink" title="大数据时代的3v:"></a>大数据时代的3v:</h5><p>1.海量(Volume)</p>
<p>2.多样(Variety)</p>
<p>3.实时(Velocity)</p>
<h5 id="互联网时代的3高"><a href="#互联网时代的3高" class="headerlink" title="互联网时代的3高:"></a>互联网时代的3高:</h5><p>1.高并发</p>
<p>2.高可扩</p>
<p>3.高性能</p>
]]></content>
  </entry>
  <entry>
    <title>ssh踩坑经历</title>
    <url>/2020/05/15/ssh%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h1 id="SSH项目总结"><a href="#SSH项目总结" class="headerlink" title="SSH项目总结"></a>SSH项目总结</h1><p>在前端的对应的标签上添加对应的<code>js</code>函数(),在外部单独的定义这个js函数</p>
<p><code>&lt;dl&gt;   &lt;dt    onclick=&quot;this.parentNode.className=this.parentNode.className==&#39;open&#39;?&#39;&#39;:&#39;open&#39;;&quot;&gt;订单业务  &lt;/dt&gt;   &lt;dd&gt;&lt;a href=&quot;javascript:all_order()&quot;&gt;所有订单&lt;/a&gt;&lt;/dd&gt;   &lt;dd&gt;&lt;a href=&quot;javascript:addnew()&quot;&gt;新增订单&lt;/a&gt;&lt;/dd&gt;   &lt;dd&gt;&lt;a href=&quot;javascript:delete_by_id()&quot;&gt;删除订单&lt;/a&gt;&lt;/dd&gt;&lt;/dl&gt;</code>,</p>
<p>后面对应的是对应的action的方法实现</p>
<p><code>function all_order(){             document.getElementById(&quot;iframe&quot;).src = &quot;torderfindAll&quot;;         }</code></p>
<p>​        然后请求就会根据给定的路径去找对应的action(<code>torderfindAll</code>代表名为<code>torder</code>的action的<code>findALL</code>方法),执行方法之后,将查询到的信息封装到session中,执行结束后,会根据方法与<code>jsp</code>的对应关系,将该session中储存的信息回填到<code>jsp</code>页面中展示给用户.</p>
<h2 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系 :"></a>对应关系 :</h2><h3 id="以下是各个层之间的对应关系"><a href="#以下是各个层之间的对应关系" class="headerlink" title="以下是各个层之间的对应关系 :"></a>以下是各个层之间的对应关系 :</h3><p>在这个文件夹中 applicationContext.xml</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- TOrder dao --&gt;&lt;bean id="OrderDaoImpl" class="com.accp.dao.impl.OrderDaoImpl"&gt;   &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt;&lt;!-- biz --&gt;&lt;bean id="OrderBizImpl" class="com.accp.biz.impl.OrderBizImpl"&gt;   &lt;property name="orderDao" ref="OrderDaoImpl" /&gt;&lt;/bean&gt;&lt;!-- action --&gt;&lt;bean id="OrderAction" class="com.accp.action.OrderAction" scope="prototype"&gt;   &lt;property name="orderBiz" ref="OrderBizImpl" /&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="hibernate-cfg-xml-的配置-里面需要配置连接数据库的信息"><a href="#hibernate-cfg-xml-的配置-里面需要配置连接数据库的信息" class="headerlink" title="hibernate.cfg.xml 的配置,里面需要配置连接数据库的信息"></a>hibernate.cfg.xml 的配置,里面需要配置连接数据库的信息</h3><p>里面还会配置数据库表对应的实体类信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span>        <span class="meta-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>        <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span>    <span class="comment">&lt;!--&lt;property name="connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;--&gt;</span>    <span class="comment">&lt;!--&lt;property name="connection.url"&gt;jdbc:oracle:thin:@localhost:1521:hibernate_office&lt;/property&gt;--&gt;</span>   <span class="comment">&lt;!--&lt;property name="connection.username"&gt;office&lt;/property&gt;--&gt;</span>   <span class="comment">&lt;!--&lt;property name="connection.password"&gt;office&lt;/property&gt;--&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://119.23.31.181:3306/ssh_office<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>xuhong<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>xuhong<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.OracleDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="comment">&lt;!--&lt;property name="connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;--&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_size"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.min_size"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.timeout"</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_statements"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.idle_test_period"</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.acquire_increment"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myeclipse.connection.profile"</span>&gt;</span>ssh_office<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.accp.pojo.Users"</span> /&gt;</span>   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.accp.pojo.TOrder"</span> /&gt;</span>   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.accp.pojo.Email"</span> /&gt;</span>   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.accp.pojo.Vacation"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="strus-xml的配置"><a href="#strus-xml的配置" class="headerlink" title="strus.xml的配置"></a>strus.xml的配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /* 原始 struts2 */ &lt;action name="user*" class="com.accp.demo.action.UserinfoAction" method="&#123;1&#125;"&gt; &lt;result name="ok"&gt;/ok.jsp&lt;/result&gt;    &lt;result name="err"&gt;/err.jsp&lt;/result&gt; &lt;result name="back" type="redirect"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; --&gt;</span><span class="comment">&lt;!-- 现在交由Spring,class 应该写applicationContext.xml中 action 的 ID --&gt;</span><span class="comment">&lt;!-- user action --&gt;</span><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"user*"</span> <span class="attr">class</span>=<span class="string">"UsersAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"login"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"relogin"</span>&gt;</span>/<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"out"</span> <span class="attr">type</span>=<span class="string">"redirect"</span>&gt;</span>/<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"update"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"updatePwd"</span>&gt;</span>/account.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"selectFirstPage"</span>&gt;</span>/account_list.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"selectNextPage"</span>&gt;</span>/account_list.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span>userselectFirstPage<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span>userselectFirstPage<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><action>标签中的那么表示所有user开头的请求的对应关系都在这里配置,class是对应的action类</p>
<p><result>标签中的name是对应的action中具体的方法名,标签中间的<code>xxx.jsp</code>是是该方法对应的<code>jsp</code>文件</p>
<h3 id="实体类与数据库表的对应关系"><a href="#实体类与数据库表的对应关系" class="headerlink" title="实体类与数据库表的对应关系 :"></a>实体类与数据库表的对应关系 :</h3><ul>
<li><input disabled="" type="checkbox"> <pre><code class="xml"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span><span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span>    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.accp.pojo.TOrder"</span> <span class="attr">table</span>=<span class="string">"t_order"</span>&gt;</span>        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"assigned"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">id</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phone"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"phone"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderType"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"order_type"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"status"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"status"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"picture"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"picture"</span> <span class="attr">length</span>=<span class="string">"150"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"createUser"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"create_user"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"createTime"</span> <span class="attr">type</span>=<span class="string">"java.sql.Timestamp"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"create_time"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="comment">&lt;!--       &lt;set name="emails"&gt;         &lt;key cloumn="RECIPIENTS"&gt;&lt;/key&gt;         &lt;one-to-many class="com.accp.pojo.Email"/&gt;      &lt;/set&gt; --&gt;</span><span class="comment">&lt;!--       &lt;set name="vacations"&gt;         &lt;key cloumn="NAME"&gt;&lt;/key&gt;         &lt;one-to-many class="com.accp.pojo.Vacation"/&gt;      &lt;/set&gt; --&gt;</span>    <span class="tag">&lt;/<span class="name">class</span>&gt;</span><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></code></pre>
</li>
</ul>
<p><class name="com.accp.pojo.TOrder" table="t_order">其中的name表示实体类的全类名,table表示的是表名,而且必须将需要查询的的所有字段与实体类对应起来(包括数据类型的匹配),否则查询不到</p>
]]></content>
  </entry>
  <entry>
    <title>云服务器的使用</title>
    <url>/2020/05/15/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库 :"></a>数据库 :</h2><p>​        阿里云的数据库使用分为内网地址和外网地址,内网地址即阿里云业务内部访问的地址,外网就是之外的网络访问的地址,需要注意的是,外网的访问需要将访问者的<code>ip</code>地址添加进白名单中,而且这个<code>ip</code>不是局域网的<code>ip</code>而是针对外网的<code>ip</code>,通过百度搜索<code>ip</code>即可在首页看到.</p>
<p>​        阿里云的服务器使用也是遵循数据库的使用规则,区别就是需要在安全组里面定义外部可以访问的端口,添加的时候注意格式为(8080/8080),前缀就是该服务器的外网地址.</p>
<p>​        阿里云的<code>OSS</code>对象储存服务需要注意的是在添加<code>jar</code>包之后,新建工具类,可以将别人已经写好的工具类拿过来,需要注意的是将里面的四个参数更改为自己的<code>OSS</code>的参数,然后可能会出现一个jar包版本错误的问题,只需将这个jar包的版本改对即可</p>
<h3 id="部署系统和运行环境"><a href="#部署系统和运行环境" class="headerlink" title="部署系统和运行环境:"></a>部署系统和运行环境:</h3><p>将<code>linux</code>版本的JDK下载安装到云服务器中的文件夹中,可以借助工具,直接粘贴过去.然后配置系统的环境变量.</p>
<h4 id="配置linux的java环境变量"><a href="#配置linux的java环境变量" class="headerlink" title="配置linux的java环境变量 :"></a>配置<code>linux</code>的java环境变量 :</h4><p>本质是在/etc/profile文件的末尾加上环境变量的内容 :</p>
<p>JAVA_HOME=/home/jdk1.8.0_211<br>JRE_HOME=$JAVA_HOME/jre<br>CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib<br>PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</p>
<p>可以使用vim命令 :vim etc/profile来更改,或者直接打开该文件来更改</p>
<p>安装成功后可能会出现以下现象,因为权限不够,执行以下代码即可,/ 斜杠后面为jdk路径 :<br>chmod -R 755 /home/jdk1.8.0_211</p>
]]></content>
  </entry>
  <entry>
    <title>二叉堆以及堆排序</title>
    <url>/2020/05/15/%E4%BA%8C%E5%8F%89%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="1-二叉堆"><a href="#1-二叉堆" class="headerlink" title="1. 二叉堆"></a>1. 二叉堆</h1><h3 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h3><p>二叉堆本质上是一种完全二叉树, 它分为两个类型</p>
<ul>
<li>最大堆</li>
<li>最小堆</li>
</ul>
<p>最大堆: 堆的每一个父节点都大于或等于他的左子节点和右子节点</p>
<p>最小堆: 堆的每一个父节点都小于或等于他的左子节点和右子节点</p>
<p>​        二叉堆的根节点叫做堆顶, 最大堆和最小堆的特性决定了,最大堆的顶点是整个堆中元素的最大值,最小堆的顶点是整个堆中元素的最小值</p>
<h3 id="二叉堆的自我调整"><a href="#二叉堆的自我调整" class="headerlink" title="二叉堆的自我调整"></a>二叉堆的自我调整</h3><p>​        二叉堆的几种操作</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>构建二叉堆</li>
</ul>
<p>​        这几种操作都是基于堆的自我调整, 就是把一个不符合堆性质的完全二叉堆, 调整成一个堆, 下面让我们已最小堆为例, 看一个二叉堆是如何调整的</p>
<ol>
<li><p>插入节点</p>
<p>​    当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个 新节点，值是 0。这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节点“上 浮”，和父节点交换位置。继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。继续比较，最终新节点0“上浮”到了堆顶位置。</p>
</li>
<li><p>删除节点</p>
<p>​        二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节 点。例如删除最小堆的堆顶节点1。这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到 原本堆顶的位置。接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果左、右孩 子节点中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。继续让节点10和它的左、右孩子做比较，左、右孩子中最小的是节点7，由于10 大于7，让节点10继续“下沉”。这样一来，二叉堆重新得到了调整。</p>
</li>
<li><p>构建二叉堆</p>
<p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是让所有 非叶子节点依次“下沉”。首先，从最后一个非叶子节点开始，也就是从节点10开始。如果节点10大于它 左、右孩子节点中最小的一个，则节点10“下沉”。接下来轮到节点3，如果节点3大于它左、右孩子节点中最小的一个，则节点 3“下沉”。然后轮到节点1，如果节点1大于它左、右孩子节点中最小的一个，则节点1“下 沉”。事实上节点1小于它的左、右孩子，所以不用改变。经过上述几轮比较和“下沉”操作，最终每一节点都小于它的左、右孩子节 点，一个无序的完全二叉树就被构建成了一个最小堆。</p>
</li>
</ol>
<h3 id="二叉堆的代码实现"><a href="#二叉堆的代码实现" class="headerlink" title="二叉堆的代码实现"></a>二叉堆的代码实现</h3><p>​        在展示代码之前，我们还需要明确一点：二叉堆虽然是一个完全二叉树，但它 的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储 在数组中.</p>
<p>​        在数组中，在没有左、右指针的情况下，如何定位一个父节点的左孩子和右孩 子呢？假设父节点的下标是parent，那么它的左孩子下标就是 2×parent+1；右孩子 下标就是2×parent+2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 上浮调整,</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> childIndex = array.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//temp 保存插入的子叶节点的值,用于最后赋值</span></span><br><span class="line">       <span class="keyword">int</span> temp = array[array.length - <span class="number">1</span>];</span><br><span class="line">       <span class="comment">//当上浮到顶点之前,切该值比父节点的值小,进行赋值</span></span><br><span class="line">       <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[parentIndex]) &#123;</span><br><span class="line">           <span class="comment">//不需换值,直接赋值即可,最后一次在填入值</span></span><br><span class="line">           array[childIndex] = array[parentIndex];</span><br><span class="line">           childIndex = parentIndex;</span><br><span class="line">           parentIndex = (parentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//因为是在进行子父节点的运算后退出的循环,所以这里的childIndex才是最后需要换值得节点</span></span><br><span class="line">       array[childIndex] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * "下沉调整"</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array       待调整的堆</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parentIndex 要下沉的父节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length      堆的有效大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//保存父节点的值,用于最后赋值</span></span><br><span class="line">       <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">       <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">           <span class="comment">//如果有右孩子,且右孩子的值小于左孩子的值,则定位右孩子</span></span><br><span class="line">           <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &lt; array[childIndex]) &#123;</span><br><span class="line">               childIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果父节点小于任何一个孩子的值,立刻跳出</span></span><br><span class="line">           <span class="keyword">if</span> (array[parentIndex] &lt; array[childIndex]) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//条件判断结果未true后,节点下沉</span></span><br><span class="line">           array[parentIndex] = array[childIndex];</span><br><span class="line">           parentIndex = childIndex;</span><br><span class="line">           childIndex = childIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       array[parentIndex] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构建堆</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">       <span class="comment">//从最后一个非叶子节点开始,依次进行下沉调整</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i =(array.length-<span class="number">2</span>)/<span class="number">2</span> ; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">           downAdjust(array,i, array.length);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">       upAdjust(array);</span><br><span class="line">       System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">       array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line">       buildHeap(array);</span><br><span class="line"></span><br><span class="line">       System.out.println(Arrays.toString(array));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-优先队列"><a href="#2-优先队列" class="headerlink" title="2.优先队列"></a>2.优先队列</h1><h5 id="优先队列不再遵循先入先出的原则，而是分为两种情况。-最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队-最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队"><a href="#优先队列不再遵循先入先出的原则，而是分为两种情况。-最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队-最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队" class="headerlink" title="优先队列不再遵循先入先出的原则，而是分为两种情况。 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队"></a>优先队列不再遵循先入先出的原则，而是分为两种情况。 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队</h5><p>​        先来回顾一下二叉堆的特性。 1. 最大堆的堆顶是整个堆中的最大元素。 2. 最小堆的堆顶是整个堆中的最小元素。 因此，可以用最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆 的插入操作，每一次出队操作就是删除堆顶节点</p>
<p>以下为代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码实现的是最大堆,所以出队的顺序是从大到小 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数组长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        array[size++] = key;</span><br><span class="line">        upAdjust();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"the queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[--size];</span><br><span class="line">        downAdjust();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用temp保存父节点的值,用于最后赋值</span></span><br><span class="line">        <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子,且右孩子的值大于左孩子的值, 则定位到左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果父节点大于任何一个孩子的值,则跳出</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; array[childIndex]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断结束,进行换值</span></span><br><span class="line">            array[parentIndex] = array[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = parentIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//temp用于保存叶子节点的值,用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">        <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex]) &#123;</span><br><span class="line">            array[childIndex] = array[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[childIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组扩容的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newSize = array.length * <span class="number">2</span>;</span><br><span class="line">        array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">6</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">78</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">213</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">45</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">456</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">78</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">76</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">8524</span>);</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3. 堆排序"></a>3. 堆排序</h1><p>​        把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大 到小排序，则构建成最小堆。 2. 循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</p>
<p>​        代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下沉调整</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array       要调整的堆</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parentIndex 待下沉的父节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length      堆的有效大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//保存父节点的值,用于最后赋值</span></span><br><span class="line">       <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">       <span class="keyword">int</span> childIndex = parentIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">           <span class="comment">//如果有右孩子,且右孩子的值大于左孩子的值,则定位右孩子</span></span><br><span class="line">           <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">               childIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果父节点的值大于每一个子节点的值,直接跳出</span></span><br><span class="line">           <span class="keyword">if</span> (temp &gt; array[childIndex]) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断结束进行换值</span></span><br><span class="line">           array[parentIndex] = array[childIndex];</span><br><span class="line">           parentIndex = childIndex;</span><br><span class="line">           childIndex = childIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       array[parentIndex] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 堆排序(升序)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">       <span class="comment">//把无序数组构建成最大堆</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">           downAdjust(array,i, array.length);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 循环的删除堆顶元素, 移到集合尾部, 调整堆产生新的堆</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length-<span class="number">1</span>; i &gt;<span class="number">0</span> ; i--) &#123;</span><br><span class="line">           <span class="comment">// 最后1个元素和第1个元素进行交换</span></span><br><span class="line">           <span class="keyword">int</span> temp = array[i];</span><br><span class="line">           array[i] = array[<span class="number">0</span>];</span><br><span class="line">           array[<span class="number">0</span>] = temp;</span><br><span class="line">           <span class="comment">// “下沉”调整最大堆</span></span><br><span class="line">           downAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">       heapSort(arr);</span><br><span class="line">       System.out.println(Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序算法的步骤"><a href="#堆排序算法的步骤" class="headerlink" title="堆排序算法的步骤"></a>堆排序算法的步骤</h4><p>​        把无序数组构建成二叉堆。 2. 循环删除堆顶元素，并将该元素移到集合尾部，调整堆产生新的堆顶。 第1步，把无序数组构建成二叉堆，这一步的时间复杂度是O(n)。 第2步，需要进行n-1次循环。每次循环调用一次downAdjust方法，所以第2步 的计算规模是 (n-1)×logn ，时间复杂度为O(nlogn)。</p>
]]></content>
  </entry>
  <entry>
    <title>参数值格式问题</title>
    <url>/2020/05/15/%E5%8F%82%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Spring-Boot-jackson（Date类型入参、格式化，以及如何处理null）"><a href="#Spring-Boot-jackson（Date类型入参、格式化，以及如何处理null）" class="headerlink" title="Spring Boot jackson（Date类型入参、格式化，以及如何处理null）"></a>Spring Boot jackson（Date类型入参、格式化，以及如何处理null）</h1><blockquote>
<p>首先，我们要知道 springboot 默认使用 jackson 解析 json（当然这里也是可以配置使用其他 json 解析框架）。<br> 在不配置其他 json 解析的情况下，我们可以通过 spring boot 提供的注解和配置 来让 jackson 帮助我们提高开发效率</p>
</blockquote>
<h4 id="一、-使用-ResponseBody-RequestBody，-Date-类型对象入参，返回json格式化"><a href="#一、-使用-ResponseBody-RequestBody，-Date-类型对象入参，返回json格式化" class="headerlink" title="一、 使用 @ResponseBody @RequestBody， Date 类型对象入参，返回json格式化"></a>一、 使用 @ResponseBody @RequestBody， Date 类型对象入参，返回json格式化</h4><p><strong>解决方法如下:</strong></p>
<h5 id="1-application-properties中加入如下代码"><a href="#1-application-properties中加入如下代码" class="headerlink" title="1. application.properties中加入如下代码"></a>1. application.properties中加入如下代码</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.jackson.date-format=yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="string">spring.jackson.time-zone=GMT+8</span></span><br></pre></td></tr></table></figure>

<h5 id="2-如果个别实体需要使用其他格式的-pattern，在实体上加入注解即可"><a href="#2-如果个别实体需要使用其他格式的-pattern，在实体上加入注解即可" class="headerlink" title="2. 如果个别实体需要使用其他格式的 pattern，在实体上加入注解即可"></a>2. 如果个别实体需要使用其他格式的 pattern，在实体上加入注解即可</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.annotation.DateTimeFormat;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MrType</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonFormat</span>(timezone = <span class="string">"GMT+8"</span>,pattern = <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createdDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于spring boot 时间类型支持我做了以下测试：</p>
<ol>
<li>application.properties 配置注释，不添加注解：spring 无法接收时间参数（400），json 输出 <code>&quot;2018-03-29T09:45:31.513+0000&quot;</code></li>
<li>application.properties 配置开启，不添加注解：仅支持 <code>yyyy-MM-dd HH:mm:ss</code> 的格式参数和 json 输出</li>
<li>application.properties 配置开启，实体添加 <code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code>，实体可接受 <code>yyyy-MM-dd HH:mm:ss</code> 和 <code>yyyy-MM-dd</code> 格式的参数，json输出格式为 yyyy-MM-dd，由此可见@JsonFormat是限制Date 类型 json 输出的，但是为什么对接受的类型也造成了影响？有待考证</li>
<li>application.properties 配置开启，实体添加 <code>@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</code>，结果与第二条测试一样？貌似<code>@DateTimeFormat</code> 注解并没有生效？有待考证</li>
<li>application.properties 配置开启，实体添加 <code>@JsonFormat</code> 和 <code>@DateTimeFormat</code> 结果与第三条一样</li>
</ol>
<p>结论：实际项目中 application.properties设置通用时间格式，个别属性需要特殊处理时，添加<code>@JsonFormat</code><br> （<code>@JsonFormat</code> 自己好像就把这件事搞定了）</p>
<h4 id="二、-使用-ResponseBody-时-忽略-json-中值为null的属性"><a href="#二、-使用-ResponseBody-时-忽略-json-中值为null的属性" class="headerlink" title="二、 使用 @ResponseBody 时 忽略 json 中值为null的属性"></a>二、 使用 @ResponseBody 时 忽略 json 中值为null的属性</h4><h5 id="1-application-properties中加入如下代码-1"><a href="#1-application-properties中加入如下代码-1" class="headerlink" title="1. application.properties中加入如下代码"></a>1. application.properties中加入如下代码</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.jackson.default-property-inclusion=non-null</span></span><br></pre></td></tr></table></figure>

<p>或者在类上声明<br> @JsonInclude(JsonInclude.Include.NON_NULL)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_NULL)<span class="comment">//该注解配合jackson，序列化时忽略 null属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxResult</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>位运算解决八皇后的问题</title>
    <url>/2020/05/15/%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E5%86%B3%E5%85%AB%E7%9A%87%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="位运算回溯法解决八皇后-N皇后-问题"><a href="#位运算回溯法解决八皇后-N皇后-问题" class="headerlink" title="位运算回溯法解决八皇后(N皇后)问题"></a>位运算回溯法解决八皇后(N皇后)问题</h1><h2 id="1-以下为背景"><a href="#1-以下为背景" class="headerlink" title="1. 以下为背景"></a>1. 以下为背景</h2><p>​        八皇后问题，一个古老而著名的问题，是<a href="https://baike.baidu.com/item/回溯算法/9258495" target="_blank" rel="noopener">回溯算法</a>的典型案例。该问题由国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的<a href="https://baike.baidu.com/item/国际象棋/80888" target="_blank" rel="noopener">国际象棋</a>上摆放八个<a href="https://baike.baidu.com/item/皇后/15860305" target="_blank" rel="noopener">皇后</a>，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<a href="https://baike.baidu.com/item/高斯/24098" target="_blank" rel="noopener">高斯</a>认为有 76 种方案。1854 年在柏林的象棋杂志上不同的作者发表了 40 种不同的解，后来有人用<a href="https://baike.baidu.com/item/图论/1433806" target="_blank" rel="noopener">图论</a>的方法解出 92 种结果。<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>发明后，有多种计算机语言可以编程解决此问题。</p>
<h2 id="2-传统的穷举法解决"><a href="#2-传统的穷举法解决" class="headerlink" title="2. 传统的穷举法解决"></a>2. 传统的穷举法解决</h2><p>​        八皇后问题如果用<a href="https://baike.baidu.com/item/穷举法/1431412" target="_blank" rel="noopener">穷举法</a>需要尝试 88 =16,777,216 种情况。每一列放一个<a href="https://baike.baidu.com/pic/八皇后问题/11053477/26857349/86d6277f9e2f070828387b62726caf99a9014c085432?fr=lemma&ct=cover" target="_blank" rel="noopener"><img src="https://bkimg.cdn.bcebos.com/pic/86d6277f9e2f070828387b62726caf99a9014c085432?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1" alt="八皇后问题">)八皇后问题(3张)</a> 皇后，可以放在第 1 行，第 2 行，……，直到第 8 行。穷举的时候从所有皇后都放在第 1 行的方案开始，检验皇后之间是否会相互攻击。如果会，把列 H 的皇后挪一格，验证下一个方案。移到底了就 “进位” 到列 G 的皇后挪一格，列 H 的皇后重新试过全部的 8 行。如图 1 所示，这种方法无疑是非常低效率的，因为它并不是哪里有冲突就调整哪里，而是盲目地按既定顺序枚举所有的可能方案。</p>
<p>​        此方法明显效率很低, 即使是现在计算机效率很高的情况下</p>
<h2 id="3-位运算解决"><a href="#3-位运算解决" class="headerlink" title="3. 位运算解决"></a>3. 位运算解决</h2><p>​        此方法是运用了二进制的特性,用一个n位的二进制来代表,可以在一行上进行查找,00000000为初始,当为11111111的时候查找结束,下一层摆放位置根据上一层的摆放位置来产生,每次都从最右侧找一个可以摆放的位置,摆放后将该位置从可摆放的位置中剔除,然后剔除该位置的左右对角线位置, 递归调用本方法进行下一层位置的摆放,</p>
<p>假如摆放完的位置不是11111111,而可摆放的位置又没有了,就会进行回溯,从新摆放上一层的位置, 当所有的位置都摆放完之后,sum(统计摆放完成的次数)+1,当完成所有的摆法之后,程序结束,</p>
<p>​        java代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaHuangHou</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>, upperlimit = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 纵列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ld 左斜线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rd 右斜线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> ld, <span class="keyword">int</span> rd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当row=11111111的时候，就是全部找完了。</span></span><br><span class="line">        <span class="keyword">if</span> (row != upperlimit) &#123;</span><br><span class="line">            <span class="comment">//找到该列的所以可以放的位置</span></span><br><span class="line">            <span class="keyword">int</span> pos = upperlimit &amp; ~(row | ld | rd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pos != <span class="number">0</span>)<span class="comment">//没有可摆放的位置,回溯</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//取出第一个可以放的位置，也就是最右边的1</span></span><br><span class="line">                <span class="keyword">int</span> p = pos &amp; -pos;</span><br><span class="line">                <span class="comment">//去除刚取出来的位置</span></span><br><span class="line">                pos -= p;</span><br><span class="line">                <span class="comment">//继续寻找,个个参数平移一位</span></span><br><span class="line">                compute(row + p, (ld + p) &lt;&lt; <span class="number">1</span>, (rd + p) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  sum++;<span class="comment">//种数自加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入皇后数字</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">14</span>;</span><br><span class="line">        <span class="comment">//设置开始时间</span></span><br><span class="line">        start = Calendar.getInstance();</span><br><span class="line">        <span class="comment">//保证数字在1到32之间，避免系统溢出</span></span><br><span class="line">        <span class="keyword">if</span> ((n &lt; <span class="number">1</span>) || (n &gt; <span class="number">32</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">" 只能计算1-32之间\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(n + <span class="string">" 皇后\n"</span>);</span><br><span class="line">        <span class="comment">//结束标志 uperlimti=255 转换为二进制就是11111111</span></span><br><span class="line">        upperlimit = (upperlimit &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从0，0，0开始</span></span><br><span class="line">        compute(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"共有"</span></span><br><span class="line">                + sum</span><br><span class="line">                + <span class="string">"种排列, 计算时间"</span></span><br><span class="line">                + (Calendar.getInstance().getTimeInMillis() - start</span><br><span class="line">                .getTimeInMillis()) / <span class="number">1000</span> + <span class="string">"秒 \n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">15</span> 皇后</span><br><span class="line"></span><br><span class="line">共有<span class="number">2279184</span>种排列, 计算时间<span class="number">2610</span>毫秒</span><br></pre></td></tr></table></figure>



<h2 id="4-go语言实现方法"><a href="#4-go语言实现方法" class="headerlink" title="4. go语言实现方法"></a>4. go语言实现方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   八皇后问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> upperlimit <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(row <span class="keyword">int</span>, ld <span class="keyword">int</span>, rd <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> row != upperlimit &#123;</span><br><span class="line">		pos := upperlimit &amp;^ (row | ld | rd)</span><br><span class="line">		<span class="keyword">for</span> pos != <span class="number">0</span> &#123; <span class="comment">//当没有可放置的位置,回溯</span></span><br><span class="line">			<span class="comment">//取出第一个可以放的位置,也就是最右边的1</span></span><br><span class="line">			p := pos &amp; - pos</span><br><span class="line">			pos -= p <span class="comment">//将取出的改位置删除</span></span><br><span class="line">			test(row+p, (ld+p)&lt;&lt;<span class="number">1</span>, (rd+p)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sum++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="comment">//指定皇后的数字以及棋盘的尺寸</span></span><br><span class="line">	n := <span class="number">8</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"请输入1到32中间的数"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	upperlimit = upperlimit&lt;&lt;n - <span class="number">1</span></span><br><span class="line">	test(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%v皇后,共有 %v 摆放方法 耗时 %v 毫秒"</span>,n,sum,time.Since(start)/<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">15</span>皇后,共有 <span class="number">2279184</span> 摆放方法 耗时 <span class="number">1.922809</span>ms 毫秒</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>总结,go和java的运行效率差距还是明显的</p>
]]></content>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2020/05/15/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>​        LeetCode(200)给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题是一个可以使用深度优先搜索(DFS),也可以使用广度优先搜索(BFS)的题,</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS:"></a>DFS:</h5><p> 顺序的从前往后遍历,当发现有元素为’1’时,将与该元素的相连的值为’1’的元素赋值为0,然后再递归的调用自身方法对该元素四周的元素进行搜索,如果有’1’也将其复制为’0’直到找到所有与原始’1’联系的1,继续遍历,再碰到1让计数++.</p>
<p>java代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                   sum++;</span><br><span class="line">                   dfs(grid, i, j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//递归将'1'旁边的'1'赋值为方法,</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>||i&gt;=na||j&gt;=nb|| grid[i][j]==<span class="string">'0'</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       grid[i][j]=<span class="string">'0'</span>;</span><br><span class="line">       dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">       dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">       dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">       dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>go代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> grid == <span class="literal">nil</span> || <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	na := <span class="built_in">len</span>(grid)</span><br><span class="line">	nb := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; na; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; nb; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> &#123;</span><br><span class="line">				sum++</span><br><span class="line">				dfs(grid, i, j)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(grid [][]<span class="keyword">byte</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	na := <span class="built_in">len</span>(grid)</span><br><span class="line">	nb := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= na || j &gt;= nb || grid[i][j] == <span class="string">'0'</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	grid[i][j] = <span class="string">'0'</span></span><br><span class="line">	dfs(grid, i+<span class="number">1</span>, j)</span><br><span class="line">	dfs(grid, i<span class="number">-1</span>, j)</span><br><span class="line">	dfs(grid, i, j+<span class="number">1</span>)</span><br><span class="line">	dfs(grid, i, j<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS:"></a>BFS:</h5><p> 其实就是把使用的递归的方法搜索改为使用栈进行搜索,但是通过对比执行效率效率下降不少,推荐还是使用递归,代码简洁,效率高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                   sum++;</span><br><span class="line">                   grid[i][j]=<span class="number">0</span>;</span><br><span class="line">                   Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                   queue.add(nb * i + j);</span><br><span class="line">                   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                       Integer poll = queue.remove();</span><br><span class="line">                       <span class="keyword">int</span> row = poll / nb;</span><br><span class="line">                       <span class="keyword">int</span> col = poll % nb;</span><br><span class="line">                       <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nb &amp;&amp; grid[row][col + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row][col + <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col + <span class="number">1</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row][col - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col - <span class="number">1</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (row + <span class="number">1</span> &lt; na &amp;&amp; grid[row + <span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row + <span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col + nb);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row - <span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row - <span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col - nb);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>杂项经验</title>
    <url>/2020/05/15/%E6%9D%82%E9%A1%B9%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<ul>
<li><p>在git中clone项目有两种方式：HTTPS和SSH，它们的区别如下：</p>
</li>
<li><p>HTTPS：不管是谁，拿到url随便clone，但是在push的时候需要验证用户名和密码；</p>
</li>
<li><p>SSH：clone的项目你必须是拥有者或者管理员，而且需要在clone前添加SSH Key。SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。</p>
</li>
<li><p>在git中使用SSH Key的步骤：</p>
</li>
<li><p>检查电脑是否存在SSH Key：$ cd ~/.ssh$ ls</p>
</li>
<li><p>如果存在id_rsa.pub 或 id_dsa.pub 文件，说明文件以及存在，跳过创建SSH Key步骤。</p>
</li>
<li><p>创建SSH Key</p>
</li>
<li><p>将公共的SSH 放到远程仓库上</p>
<h1 id="时间入参出参的格式化注解"><a href="#时间入参出参的格式化注解" class="headerlink" title="时间入参出参的格式化注解"></a>时间入参出参的格式化注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#以下格式为国际标准格式,可根据具体需要更改</span><br><span class="line"><span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>,timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line"><span class="meta">@DateTimeFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="BigDecimal-的运算"><a href="#BigDecimal-的运算" class="headerlink" title="BigDecimal 的运算"></a>BigDecimal 的运算</h1><h3 id="使用静态的valueOf方法可以将普通的数值转换为大数值："><a href="#使用静态的valueOf方法可以将普通的数值转换为大数值：" class="headerlink" title="使用静态的valueOf方法可以将普通的数值转换为大数值："></a>使用静态的valueOf方法可以将普通的数值转换为大数值：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger b = BigInteger.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="遗憾的是，不能使用人们熟悉的算术运算符（如：-和-）处理大数值。而需要使用-大数值类中的add和multiply方法。"><a href="#遗憾的是，不能使用人们熟悉的算术运算符（如：-和-）处理大数值。而需要使用-大数值类中的add和multiply方法。" class="headerlink" title="遗憾的是，不能使用人们熟悉的算术运算符（如：+和*）处理大数值。而需要使用 大数值类中的add和multiply方法。"></a>遗憾的是，不能使用人们熟悉的算术运算符（如：+和*）处理大数值。而需要使用 大数值类中的add和multiply方法。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">10</span>);</span><br><span class="line">BigInteger b = BigInteger.valueOf(<span class="number">10</span>);</span><br><span class="line">BigInteger c = b.add(a); <span class="comment">//c=a+b</span></span><br><span class="line">BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>)));<span class="comment">//d = c*(b+2)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">BigInteger <span class="title">abs</span><span class="params">()</span> 返回大整数的绝对值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span> 返回两个大整数的和</span></span><br><span class="line"><span class="function">BigInteger <span class="title">and</span><span class="params">(BigInteger val)</span> 返回两个大整数的按位与的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">andNot</span><span class="params">(BigInteger val)</span> 返回两个大整数与非的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span> 返回两个大整数的商</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> 返回大整数的<span class="keyword">double</span>类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> 返回大整数的<span class="keyword">float</span>类型的值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">gcd</span><span class="params">(BigInteger val)</span> 返回大整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> 返回大整数的整型值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> 返回大整数的<span class="keyword">long</span>型值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">max</span><span class="params">(BigInteger val)</span> 返回两个大整数的最大者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">min</span><span class="params">(BigInteger val)</span> 返回两个大整数的最小者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger val)</span> 用当前大整数对val求模</span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span> 返回两个大整数的积</span></span><br><span class="line"><span class="function">BigInteger <span class="title">negate</span><span class="params">()</span> 返回当前大整数的相反数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">not</span><span class="params">()</span> 返回当前大整数的非</span></span><br><span class="line"><span class="function">BigInteger <span class="title">or</span><span class="params">(BigInteger val)</span> 返回两个大整数的按位或</span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span> 返回当前大整数的exponent次方</span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span> 返回当前大整数除以val的余数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">leftShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数左移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">rightShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数右移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>返回两个大整数相减的结果</span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">toByteArray</span><span class="params">(BigInteger val)</span>将大整数转换成二进制反码保存在<span class="keyword">byte</span>数组中</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> 将当前大整数转换成十进制的字符串形式</span></span><br><span class="line"><span class="function">BigInteger <span class="title">xor</span><span class="params">(BigInteger val)</span> 返回两个大整数的异或</span></span><br></pre></td></tr></table></figure>

<h4 id="提示：要想快速地打印一个二维数组的数据元素列表，可以调用："><a href="#提示：要想快速地打印一个二维数组的数据元素列表，可以调用：" class="headerlink" title="提示：要想快速地打印一个二维数组的数据元素列表，可以调用："></a>提示：要想快速地打印一个二维数组的数据元素列表，可以调用：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Arrays.deepToSrring(arr));</span><br></pre></td></tr></table></figure>

<h2 id="前端传参问题"><a href="#前端传参问题" class="headerlink" title="前端传参问题:"></a>前端传参问题:</h2><ul>
<li><p>当传参为集合或数组时使用的是<code>json</code>传参时(仅有一个参数)只需用以下格式[1,2,3]</p>
</li>
<li><p>当参数只有一个时,参数名可以省略</p>
</li>
<li><p>当使用paras传参时,应使用 test?ids=1,2,3的格式</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/05/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="一文学会动态规划解题技巧"><a href="#一文学会动态规划解题技巧" class="headerlink" title="一文学会动态规划解题技巧"></a>一文学会动态规划解题技巧</h2><p>原创 码海 <a href="javascript:void(0);">码海</a> <em>2月16日</em></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态规划（dynamic programming，简称 dp)是工程中非常重要的解决问题的思想，从我们在工程中地图软件上应用的最短路径问题，再在生活中的在淘宝上如何凑单以便利用满减券来最大程度地达到我们合理薅羊毛的目的 ，很多时候都能看到它的身影。不过动态规划对初学者来说确实比较难，dp状态，状态转移方程让人摸不着头脑，网上很多人也反馈不太好学，其实就像我们之前学<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener">递归</a>那样，任何算法的学习都是有它的规律和套路的，只要掌握好它的规律及解题的套路，再加上大量的习题练习，相信掌握它不是什么难事，本文将会用比较浅显易懂地讲解来帮助大家掌握动态规划这一在工程中非常重要的思想，相信看完后，动态规划的解题套路一定能手到擒来（文章有点长，建议先收藏再看，看完后一定会对动态规划的认知上升到一个台阶！）</p>
<p>本文将会从以下角度来讲解动态规划：</p>
<ul>
<li>什么是动态规划</li>
<li>动态规划从入门到进阶</li>
<li>再谈动态规划</li>
</ul>
<h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>以下是我综合了动态规划的特点给出的动态规划的定义： 动态规划是一种<strong>多阶段决策</strong>最优解模型，一般用来求最值问题，多数情况下它可以采用<strong>自下而上</strong>的递推方式来得出每个子问题的最优解（即最优子结构），进而自然而然地得出依赖子问题的原问题的最优解。</p>
<p>划重点：</p>
<ol>
<li><strong>多阶段决策</strong>，意味着问题可以分解成子问题，子子问题，。。。，也就是说问题可以拆分成多个子问题进行求解</li>
<li><strong>最优子结构</strong>，在自下而上的递推过程中，我们求得的每个子问题一定是<strong>全局最优解</strong>，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。</li>
<li><strong>自下而上</strong>，怎样才能自下而上的求出每个子问题的最优解呢，可以肯定子问题之间是有一定联系的，即迭代递推公式，也叫「状态转移方程」，要定义好这个状态转移方程， 我们就需要定义好每个子问题的状态（DP 状态），那为啥要自下而上地求解呢，因为如果采用像递归这样自顶向下的求解方式，子问题之间可能存在大量的重叠，大量地重叠子问题意味着大量地重复计算，这样时间复杂度很可能呈指数级上升（在下文中我们会看到多个这样重复的计算导致的指数级的时间复杂度），所以自下而上的求解方式可以消除重叠子问题。</li>
</ol>
<p>简单总结一下，最优子结构，状态转移方程，重叠子问题就是动态规划的三要素，这其中定义子问题的状态与写出状态转移方程是解决动态规划最为关键的步骤，状态转移方程如果定义好了，解决动态规划就基本不是问题了。</p>
<p>既然我们知道动态规划的基本概念及特征，那么怎么判断题目是否可以用动态规划求解呢，其实也很简单，当问题的定义是求最值问题，且问题可以采用递归的方式，并且递归的过程中有大量重复子问题的时候，基本可以断定问题可以用动态规划求解，于是我们得出了求解动态规划基本思路如下（解题四步曲）</p>
<ol>
<li>判断是否可用递归来解，可以的话进入步骤 2</li>
<li>分析在递归的过程中是否存在大量的重复子问题</li>
<li>采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</li>
<li>改用自底向上的方式来递推，即动态规划</li>
</ol>
<p><em>画外音：递归怎么求解，强烈建议看下</em><a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener"><em>这篇文章</em></a><em>，好评如潮,总结了常见的递归解题套路</em></p>
<p>可能不少人看了以上的动态规划的一些介绍还是对一些定义如 DP 状态，状态转移方程，自底而上不了解，没关系 ，接下来我们会做几道习题来强化一下大家对这些概念及动态规划解题四步曲的理解，每道题我们都会分别用递归，递归+备忘录，动态规划来求解一遍，这样也进一步帮助大家来巩固我们之前学的递归知识</p>
<h2 id="动态规划从入门到进阶"><a href="#动态规划从入门到进阶" class="headerlink" title="动态规划从入门到进阶"></a>动态规划从入门到进阶</h2><h3 id="入门题：斐波那契数列"><a href="#入门题：斐波那契数列" class="headerlink" title="入门题：斐波那契数列"></a>入门题：斐波那契数列</h3><p>接下来我们来看看怎么用动态规划解题四步曲来解斐波那契数列</p>
<p><em>画外音：斐波那契数列并不是严格意义上的动态规划，因为它不涉及到求最值，用这个例子旨在说明重叠子问题与状态转移方程</em></p>
<p>1、判断是否可用递归来解 显然是可以的，递归代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、分析在递归的过程中是否存在大量的重复子问题</p>
<p>怎么分析是否有重复子问题，画出递归树</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oCuTibzC3FxUSav02sSSqvfDW394sXP61vRUMc9WZBPsA2v0ponl450A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>可以看到光是求 f(6)，就有两次重复的计算， f(4) 求解了两次，f(3) 求解了两次，时间复杂度是指数级别，递归时间复杂度怎么看，解决每个子问题需要的时间乘以子问题总数，每个子问题需要的时间即 f(n) = f(n-1) + f(n-2) 只做了一次加法运算，子问题的个数有多少呢，每个问题一分为二,是个二叉树，可以看到第一层 1 个，第二层 2 个，第三层 4 个，即 1 + 2 + 2^2 + …. 2^n，所以总的来说时间复杂度是)O(2^n),是指数级别</p>
<p><em>画外音：求解问题 f(6),转成求 f(5),f(4),从原问题出发，分解成求子问题，子问题再分解成子子问题，。。。，直到再也不能分解，这种从 原问题展开子问题进行求解的方式叫自顶向下</em></p>
<p>3、采用备忘录的方式来存子问题的解以避免大量的重复计算 既然以上中间子问题中存在着大量的重复计算，那么我们可以把这些中间结果给缓存住（可以用哈希表缓存），如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D; 2) return 2;</span><br><span class="line">    if (map.get(n) !&#x3D; null)  &#123;</span><br><span class="line">        return map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    int result &#x3D; fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">    map.put(n, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么缓存之后再看我们的递归树</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oHdzSDDribdT9TA3Diaq5IE9HROefumO2ibxhlYIBkVHvx4Sn5sUn7HAgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>可以看到通过缓存中间的数据，做了大量地剪枝的工作，同样的f(4),f(3),f(2)，都只算一遍了,省去了大量的重复计算，问题的规模从二叉树变成了单链表（即 n），时间复杂度变成了 O(n)，不过由于哈希表缓存了所有的子问题的结果，空间复杂度是 O(n)。</p>
<p>4、改用自底向上的方式来递推，即动态规划 我们注意到如下规律</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(1) &#x3D; 1</span><br><span class="line">f(2) &#x3D; 2</span><br><span class="line">f(3) &#x3D; f(1) + f(2) &#x3D; 3</span><br><span class="line">f(4) &#x3D; f(3) + f(2) &#x3D; 5</span><br><span class="line">....</span><br><span class="line">f(n) &#x3D; f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure>

<p>所以只要依次自底向上求出 f(3),f(4),…,自然而然地就求出了 f(n)<img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oaH39dm92qeAbF4GfQvkGun4yZ1usYxW972sok2UVYXEpbNkNuPnVGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>画外音：从最终地不能再分解的子问题根据递推方程（f(n) = f(n-1) + f(n-2)）逐渐求它上层的问题，上上层问题，最终求得一开始的问题，这种求解问题的方式就叫自底向上。</em></p>
<p>f(n) 就是定义的每个子问题的状态（DP 状态），f(n) = f(n-1) + f(n-2) 就是状态转移方程，即 f(n) 由 f(n-1), f(n-2) 这两个状态转移而来,由于每个子问题只与它前面的两个状态，所以我们只要定义三个变量，自底向上不断循环迭代即可，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    int pre &#x3D; 1;</span><br><span class="line">    int next &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 3; i &lt; n + 1; i ++) &#123;</span><br><span class="line">        result &#x3D; pre + next;</span><br><span class="line">        pre &#x3D; next;</span><br><span class="line">        next &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样时间复杂度虽然还是O(n)，但空间复杂度只由于只定义了三个变量（result,pre,next）所以是常量 O(1)。</p>
<p>通过简单地斐波那契的/-8</p>
<p>例子，相信大家对自底向上，DP 状态， DP 转移方程应该有了比较深入地认识，细心的同学一定发现了最优子结构怎么没有，因为前面我们也说了，斐波那契数列并不是严格意义上的动态规划，只是先用这个简单地例子来帮助大家了解一下一些基本的概念。在之后的习题中我们将会见识到真正的动态规划</p>
<h3 id="小试牛刀：三角形的最小路径和"><a href="#小试牛刀：三角形的最小路径和" class="headerlink" title="小试牛刀：三角形的最小路径和"></a>小试牛刀：三角形的最小路径和</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oia3b9dEKWpwHujQEAJXBjkZmZeQuNeic9u4jUNAJaE8aTqECH4RoUyqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>如图示，以上三角形由一连串的数字构成，要求从顶点 2 开始走到最底下边的最短路径，每次只能向当前节点下面的两个节点走，如 3 可以向 6 或 5 走，不能直接走到 7。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oBjg161QyicjXPMIOolrZwhDASGgIiastU8g1GJMJOzTmqKicn4PxJmCAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示:从 2 走到最底下最短路径为  2+3+5+1 = 11,即为我们所求的</em></p>
<p>首先我们需要用一个二维数组来表示这个三个角形的节点，用二维数组显然可以做到， 第一行的 2 用 a[0][0] 表示，第二行元素 3, 4 用 a[1][0],a[1][1],依此类推。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oHot63ywXbx2gBsFXZh25oEXqib2sqDEk9rGkYjguc6pqQpJm9c02vVA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>定义好数据结构之后，接下来我们来看看如何套用我们的动态规划解题套路来解题</p>
<p>1、 判断是否可用递归来解</p>
<p>如果用递归，就要穷举所有的路径和，最后再求所有路径和的最小值，我们来看看用递归怎么做。</p>
<p>对于每个节点都可以走它的左或右节点，假设我们定义 traverse(i, j) 为节点 a[i][j] 下一步要走的节点，则可以得出递归公式的伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">traverse(i, j) &#x3D; &#123;</span><br><span class="line">    traverse(i+1, j);    向节点i,j 下面的左节点走一步</span><br><span class="line">    traverse(i+1, j+1);    向节点i,j 下面的右节点走一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候终止呢，显然是遍历到三角形最后一条边的节点时终止，发现了吗，对每个节点来说，在往下（无论是往左还是往右）遍历的过程中，问题规模不断地在缩小，也有临界条件（到达最后一条边的节点时终止），分解的子问题也有相同的解决问题的思路（对于每个节点的遍历都是往左或往右），符合递归的条件！于是我们得到递归代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">            &#123;2, 0, 0, 0&#125;,</span><br><span class="line">            &#123;3, 4, 0, 0&#125;,</span><br><span class="line">            &#123;6, 5, 7, 0&#125;,</span><br><span class="line">            &#123;4, 1, 8, 3&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public static int traverse(int i, int j) &#123;</span><br><span class="line">    int totalRow &#x3D; 4; &#x2F;&#x2F; 总行数</span><br><span class="line">    if (i &gt;&#x3D;  totalRow - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往左下节点走时</span><br><span class="line">    int leftSum &#x3D; traverse(i+1, j) + triangle[i+1][j];</span><br><span class="line">    &#x2F;&#x2F; 往右下节点走时</span><br><span class="line">    int rightSum &#x3D; traverse(i+1, j+1) + triangle[i+1][j+1];</span><br><span class="line">    &#x2F;&#x2F; 记录每个节点往左和往右遍历的路径和的最小值</span><br><span class="line">    return Math.min(leftSum, rightSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">    int sum &#x3D; traverse(0, 0) + triangle[0][0];</span><br><span class="line">    System.out.println(&quot;sum &#x3D; &quot; + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是多少呢，从以下伪代码可以看出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">traverse(i, j) &#x3D; &#123;</span><br><span class="line">    traverse(i+1, j);    向节点i,j 下面的左节点走一步</span><br><span class="line">    traverse(i+1, j+1);    向节点i,j 下面的右节点走一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个节点，要么向左或向右，每个问题都分解成了两个子问题，和斐波那契数列一样，如果画出递归树也是个二叉树，所以时间复杂度是 O(2^n),也是指数级别。</p>
<p>2、分析在递归的过程中是否存在大量的重复子问题</p>
<p>为啥时间复杂度是指数级别呢，我们简单分析一下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oy5ZYAPFibbVJ7tdaCIlVF412kVHXb7RK74vtwQ3nLtHr5ib9SX4zibFNw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>对于节点 3 和 4 来说，如果节点 3 往右遍历， 节点 4 往左遍历，都到了节点 5，节点 5 往下遍历的话就会遍历两次，所以此时就会出现重复子问题</p>
<p>3、采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</p>
<p>既然出现了，那我们就用备忘录把中间节点缓存下来</p>
<p>于是我们的代码改为如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">            &#123;2, 0, 0, 0&#125;,</span><br><span class="line">            &#123;3, 4, 0, 0&#125;,</span><br><span class="line">            &#123;6, 5, 7, 0&#125;,</span><br><span class="line">            &#123;4, 1, 8, 3&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 记录中间状态的 map</span><br><span class="line">private static HashMap&lt;String, Integer&gt; map &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">public static int traverse(int i, int j) &#123;</span><br><span class="line">    String key &#x3D; i + &quot;&quot; + j;</span><br><span class="line">    if (map.get(key) !&#x3D; null) &#123;</span><br><span class="line">        return map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int totalRow &#x3D; 4; &#x2F;&#x2F; 总行数</span><br><span class="line">    if (i &gt;&#x3D;  totalRow - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往左下节点走时</span><br><span class="line">    int leftSum &#x3D; traverse(i+1, j) + triangle[i+1][j];</span><br><span class="line">    &#x2F;&#x2F; 往右下节点走时</span><br><span class="line">    int rightSum &#x3D; traverse(i+1, j+1) + triangle[i+1][j+1];</span><br><span class="line">    &#x2F;&#x2F; 记录每个节点往左和往右遍历的路径和的最小值</span><br><span class="line">    int result &#x3D; Math.min(leftSum, rightSum);</span><br><span class="line">    map.put(key, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么一来，就达到了剪枝的目的，避免了重复子问题，时间复杂度一下子下降到 O(n), 空间复杂度呢，由于我们用哈希表存储了所有的节点的状态，所以空间复杂度是 O(n)。</p>
<p>4、改用自底向上的方式来递推，即动态规划</p>
<p>重点来了，如何采用自底向上的动态规划来解决问题呢? 我们这么来看，要求节点 2 到底部边的最短路径，只要先求得节点 3 和 节点 4 到底部的最短路径值，然后取这两者之中的最小值再加 2 不就是从 2 到底部的最短路径了吗，同理，要求节点 3 或 节点 4 到底部的最小值，只要求它们的左右节点到底部的最短路径再取两者的最小值再加节点本身的值（3 或 4）即可。</p>
<p>我们知道对于三角形的最后一层节点，它们到底部的最短路径就是其本身，于是问题转化为了已知最后一层节点的最小值怎么求倒数第二层到最开始的节点到底部的最小值了。先看倒数第二层到底部的最短路径怎么求</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oRo3tk4otRSrvFzKMibib3UoubqYQ6jOjQWuiaKgictXicckfnDWv06yYERQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>同理，第二层对于节点 3 ，它到最底层的最短路径转化为了 3 到 7， 6 节点的最短路径的最小值，即 9, 对于节点 4，它到最底层的最短路径转化为了 4 到 6， 10 的最短路径两者的最小值，即 10。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1ofLTlo7P4ju4Ft7d0e6DgiatWwx5uGibTm0zU55ia7XT9sfSueIEutl94Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>接下来要求 2 到底部的路径就很简单了，只要求 2 到节点 9 与 10 的最短路径即可，显然为 11。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1o4Vxc3Gd3z1SAndqD5wg8vhtc7O3DqlpAZ472S4ibVw7add06RXqRr0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>于是最终的 11 即为我们所求的值，接下来我们来看看怎么定义 DP 的状态与状态转移方程。 我们要求每个节点到底部的最短路径，于是 DP 状态 DP[i,j] 定义为 i,j 的节点到底部的最小值，DP状态转移方程定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DP[i,j] &#x3D; min(DP[i+1, j], D[i+1, j+1]) + triangle[i,j]</span><br></pre></td></tr></table></figure>

<p>这个状态转移方程代表要求节点到最底部节点的最短路径只需要求左右两个节点到最底部的最短路径两者的最小值再加此节点本身！仔细想想我们上面的推导过程是不是都是按这个状态转移方程推导的，实在不明白建议多看几遍上面的推导过程，相信不难明白。</p>
<p>DP 状态 DP[i,j] 有两个变量，需要分别从下而上，从左到右循环求出所有的 i,j, 有了状态转移方程求出代码就比较简单了，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">        &#123;2, 0, 0, 0&#125;,</span><br><span class="line">        &#123;3, 4, 0, 0&#125;,</span><br><span class="line">        &#123;6, 5, 7, 0&#125;,</span><br><span class="line">        &#123;4, 1, 8, 3&#125;</span><br><span class="line">&#125;;</span><br><span class="line">public static int traverse() &#123;</span><br><span class="line">    int ROW &#x3D; 4;</span><br><span class="line">    int[] mini &#x3D; triangle[ROW - 1];</span><br><span class="line">    &#x2F;&#x2F; 从倒数第二行求起，因为最后一行的值本身是固定的</span><br><span class="line">    for (int i &#x3D; ROW - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; triangle[j].length; j++) &#123;</span><br><span class="line">            mini[j] &#x3D; triangle[i][j] + Math.min(mini[j], mini[j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mini[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">    int minPathSum &#x3D; traverse();</span><br><span class="line">    System.out.println(&quot;sum &#x3D; &quot; + minPathSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有一些人对 mini 数组的定义有疑问，这里其实用了一个比较取巧的方式，首先我们定义 mini 的初始值为最后一行的节点，因为最后一行的每个节点的 DP[i,j] 是固定值，只要从倒数第二行求起即可，其次我们知道每个节点到底部的最短路径只与它下一层的 D[I+1,j], D[i+1, j] 有关，所以只要把每一层节点的 DP[i,j] 求出来保存到一个数组里即可，就是为啥我们只需要定义一下 mini 一维数组的原因</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oIU6kxhnnSsZuksqzQialuNjMavbu2eShp8E5rWpC63kqKC8jXySRQzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示：要求节点 2 到底部的最短路径，它只关心节点 9， 10，之前层数的节点无需再关心！因为 9，10 已经是最优子结构了，所以只保存每层节点（即一维数组）的最值即可！</em></p>
<p>当自下而上遍历完成了，mini[0] 的值即为 DP[0,0],即为节点 2 到 底部的最短路径。mini 的定义可能有点绕，大家可以多思考几遍，当然，你也可以定义一个二维数组来保存所有的 DP[i,j]，只不过多耗些空间罢了。</p>
<p>这里我们再来谈谈<strong>最优子结构</strong>，在以上的推导中我们知道每一层节点到底部的最短路径依赖于它下层的左右节点的最短路径，求得的下层两个节点的最短路径对于依赖于它们的节点来说就是<strong>最优子结构</strong>，最优子结构对于子问题来说属于全局最优解，这样我们不必去求节点到最底层的所有路径了，只需要依赖于它的最优子结构即可推导出我们所要求的最优解，所以最优子结构有两层含义，一是它是子问题的全局最优解，依赖于它的上层问题只要根据已求得的最优子结构推导求解即可得全局最优解，二是它有缓存的含义，这样就避免了多个依赖于它的问题的重复求解（消除重叠子问题）。</p>
<p>总结：仔细回想一下我们的解题思路，我们先看了本题是否可用递归来解，在递归的过程中发现了有重叠子问题，于是我们又用备忘录来消除递归中的重叠子问题，既然我们发现了此问题可以用递归+备忘录来求解，自然而然地想到它可以用自底向上的动态规划来求解。是的，求解动态规划就按这个套路来即可，最重要的是要找出它的状态转移方程，这需要在自下而上的推导中仔细观察。</p>
<h3 id="进阶：凑零钱"><a href="#进阶：凑零钱" class="headerlink" title="进阶：凑零钱"></a>进阶：凑零钱</h3><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 输入: coins = [1, 2, 5], amount = 11，输出: 3  解释: 11 = 5 + 5 + 1 输入: coins = [2], amount = 3，输出: -1</p>
</blockquote>
<p>来套用一下我们的动态规划解题四步曲</p>
<p><strong>一、判断是否可用递归来解</strong></p>
<p>对于 amount 来说，如果我们选择了 coins 中的任何一枚硬币，则问题的规模(amount)是不是缩小了,再对缩小的 amount 也选择 coins 中的任何一枚硬币,直到再也不能选择（amount &lt;= 0, amount = 0 代表有符合条件的解，小于0代表没有符合条件的解），从描述中我们可以看出问题可以分解成子问题，子问题与原问题具有相同的解决问题的思路，同时也有临界条件，符合递归的条件，由此可证可以用递归求解，接下来我们来看看，如何套用<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener">递归四步曲</a>来解题</p>
<p>1、定义这个函数，明确这个函数的功能,函数的功能显然是给定一个 amount，用定义好的 coins 来凑，于是我们定义函数如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static int f(int amount, int[] coins) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、寻找问题与子问题的关系，即递推公式 这题的递推关系比较难推导，我们一起看下，假设 f(amount, coins) 为零钱 amount 的所需要的最少硬币数，当选中了coins 中的第一枚硬币之后（即为 coins[0]），则需再对剩余的 amount - coins[0] 金额求最少硬币数，即调用 f(amount - coins[0], coins)  ,由此可知当选了第一枚硬币后的递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(amount, coins) &#x3D; f(amount-coins[0]) + 1 (这里的 1 代表选择了第一枚硬币)</span><br></pre></td></tr></table></figure>

<p>如果选择了第二，第三枚呢，递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(amount, coins) &#x3D; f(amount-coins[1]) + 1 (这里的 1 代表选择了第二枚硬币)</span><br><span class="line">f(amount, coins) &#x3D; f(amount-coins[2]) + 1 (这里的 1 代表选择了第三枚硬币)</span><br></pre></td></tr></table></figure>

<p>我们的目标是求得所有以上 f(amount, coins) 解的的最小值，于是可以得到我们的总的递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(amount, coins) &#x3D; min&#123; f(amount - coins[i]) + 1) &#125;, 其中 i 的取值为 0 到 coins 的大小，coins[i] 表示选择了此硬币, 1 表示选择了coins[i]  这一枚硬币</span><br></pre></td></tr></table></figure>

<p>3、将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中</p>
<p>得出了递推公式用代码实现就简单了，来简单看一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private static int exchange(int amount, int[] coins) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明零钱刚好凑完</span><br><span class="line">        if (amount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有满足的条件</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            int subMin &#x3D; exchange(amount - coins[i], coins);</span><br><span class="line">            if (subMin &#x3D;&#x3D; -1) continue;</span><br><span class="line">            result &#x3D; Math.min(subMin + 1, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有符合问题的解</span><br><span class="line">        if (result &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">        int amount &#x3D; 11;</span><br><span class="line">        int[] coins &#x3D; &#123;1,2,5&#125;;</span><br><span class="line">        int result &#x3D; exchange(amount, coins);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、计算时间复杂度 这道题的时间复杂度很难看出来，一般看不出来的时候我们可以画递归树来分析，针对 amount = 11 的递归树 如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1osIhg65Y6jKelL9nVjgSibPlC4icvGFkqNHiaBvB5YTK1cIkfB9ASiauJGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>前文我们说到斐波那契的递归树是一颗二叉树，时间复杂度是指数级别，而凑零钱的递归树是一颗三叉树 ，显然时间复杂度也是指数级别!</p>
<p><strong>二、分析在递归的过程中是否存在大量的重叠子问题（动态规划第二步）</strong></p>
<p>由上一节的递归树可知，存在重叠子问题，上一节中的 9， 8，都重复算了,所以存在重叠子问题！</p>
<p><strong>三、采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</strong></p>
<p>既然我们知道存在重叠子问题，那么就可以用备忘录来存储中间结果达到剪枝的目的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 保存中间结果</span><br><span class="line">    private static HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 带备忘录的递归求解</span><br><span class="line">    private static int exchangeRecursive(int amount, int[] coins) &#123;</span><br><span class="line">        if (map.get(amount) !&#x3D; null) &#123;</span><br><span class="line">            return map.get(amount);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 说明零钱已经凑完</span><br><span class="line">        if (amount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有满足的条件</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            int subMin &#x3D; exchangeRecursive(amount - coins[i], coins);</span><br><span class="line">            if (subMin &#x3D;&#x3D; -1) continue;</span><br><span class="line">            result &#x3D; Math.min(subMin + 1, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有符合问题的解</span><br><span class="line">        if (result &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(amount, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">        int amount &#x3D; 11;</span><br><span class="line">        int[] coins &#x3D; &#123;1,2,5&#125;;</span><br><span class="line">        int result &#x3D; exchangeRecursive(amount, coins);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四、改用自底向上的方式来递推，即动态规划</strong></p>
<p>前面我们推导出了如下递归公式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(amount, coins) &#x3D; min&#123; f(amount - coins[i]) + 1) &#125;, 其中 i 的取值为 0 到 coins 的大小，coins[i] 表示选择了此硬币, 1 表示选择了coins[i]  这一枚硬币</span><br></pre></td></tr></table></figure>

<p>从以上的递推公式中我们可以获取 DP 的解题思路，我们定义 DP(i) 为凑够零钱 i 需要的最小值，状态转移方程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DP[i] &#x3D;  min&#123; DP[ i - coins[j] ] + 1 &#125; &#x3D; min&#123; DP[ i - coins[j] ]&#125; + 1,  其中 j 的取值为 0 到 coins 的大小，i 代表取了 coins[j] 这一枚硬币。</span><br></pre></td></tr></table></figure>

<p>于是我们只要自底向上根据以上状态转移方程依次求解 DP[1], DP[2],DP[3].,….DP[11]，最终的 DP[11]，即为我们所求的解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态规划求解</span><br><span class="line">private static int exchangeDP(int amount, int[] coins) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[amount + 1];</span><br><span class="line">    &#x2F;&#x2F; 初始化每个值为 amount+1，这样当最终求得的 dp[amount] 为 amount+1 时，说明问题无解</span><br><span class="line">    for (int i &#x3D; 0; i &lt; amount + 1; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; amount + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 0 硬币本来就没有，所以设置成 0</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; amount + 1; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; coins.length; j++) &#123;</span><br><span class="line">            if (i &gt;&#x3D; coins[j]) &#123;</span><br><span class="line">                dp[i] &#x3D; Math.min(dp[i- coins[j]], dp[i]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dp[amount] &#x3D;&#x3D; amount + 1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>画外音：以上只是求出了凑成零钱的的最小数量，但如果想求由哪些面值的硬币构成的，该如何修改呢？</p>
<p>凑零钱这道题还可以用另外一道经典的青蛙跳台阶的思路来考虑，从最底部最少跳多少步可以跳到第 11 阶，一次可以跳 1，2，5步 。由此可知最后一步一定是跳 1 或 2 或 5 步，于是如果用 f(n) 代表跳台阶 n 的最小跳数，则问题转化为了求 f(n-1)，f(n-2) ，f(n-5)的最小值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oXsUknhWR5OkBffKQSRGk5iaufSiaX9dKGmO3L4lJagM5Q9DDqRBZAGkw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示：最后一跳一定是跳 1 或 2 或 5 步，只要求  f(n-1)，f(n-2) ，f(n-5)的最小值即可</em></p>
<p>写出递推表达式， 即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) &#x3D; min&#123; f(n-1)，f(n-2)，f(n-5)&#125; + 1 （1代表最后一跳）</span><br></pre></td></tr></table></figure>

<p>我们的 DP 状态转移方程对比一下，可以发现两者其实是等价的，只不过这种跳台阶的方式可能更容易理解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过几个简单的例子强化了大家动态规划的三要素：最优子结构，状态转移方程，重叠子问题的理解，相信大家对动态规划的理解应该深刻了许多，怎么看出是否可以用动态规划来解呢，先看题目是否可以用递归来推导，在用递归推导的过程如果发现有大量地重叠子问题，则有两种方式可以优化，一种是递归 + 备忘录，另一种就是采用动态规划了，动态规划一般是自下而上的， 通过状态转移方程自下而上的得出每个子问题的最优解（即最优子结构），最优子结构其实也是穷举了所有的情况得出的最优解，得出每个子问题的最优解后，也就是每个最优解其实是这个子问题的<strong>全局最优解</strong>，这样依赖于它的上层问题根据状态转移方程自然而然地得出了全局最优解。动态规划自下而上的求解方式还有一个好处就是避免了重叠子问题，因为依赖于子问题的上层问题可能有很多，如果采用自顶而下的方式来求解，就有可能造成大量的重叠子问题，时间复杂度会急剧上升。</p>
<p>参考： </p>
<p>动态规划详解： <a href="https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA</a></p>
<p>欢迎添加笔者微信交流哦</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU9gC99hDeLNlboZOHUEz1owLLD2OpEOZQsplZj1TeyqhCV0RUyUqel2Oy9BfpiawibzicvpXYTPDQRw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz_jpg/fHqxZcj5WRMPpKaZgAib5OUAwzia6vibZNIZOM7yFovPia1k4UVr8kqMovp7Sibebx33dAuBJh30fRsIP4ic5e1YJZ7A/0?wx_fmt=jpeg" alt="img"></p>
<p>码海</p>
<p>赞赏诚可贵，在看价更高</p>
<p><img src="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21&key=ba5643939c77c9dac1e103914fea899ec35916484235410891e12cb48be85774010bdc218ef860e4b1db4b2d30aa6b5c7de3285d2fcc316d95bce803ba617e3a1bb63830930894b74d67faa103b9d806&ascene=1&uin=MTg2Mjc2ODc1&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=ATA0YU%2BMGaQrlTj01b9mF9Q%3D&pass_ticket=8PQrfl2i9UflzIeNreLR7Nu73lDnVlTLk%2FD%2FBdm7udY%3D&winzoom=1" alt="赞赏二维码">)<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21&key=ba5643939c77c9dac1e103914fea899ec35916484235410891e12cb48be85774010bdc218ef860e4b1db4b2d30aa6b5c7de3285d2fcc316d95bce803ba617e3a1bb63830930894b74d67faa103b9d806&ascene=1&uin=MTg2Mjc2ODc1&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=ATA0YU%2BMGaQrlTj01b9mF9Q%3D&pass_ticket=8PQrfl2i9UflzIeNreLR7Nu73lDnVlTLk%2FD%2FBdm7udY%3D&winzoom=1##" target="_blank" rel="noopener">喜欢作者</a></p>
<p><a href="javascript:;">13</a> 人喜欢</p>
<p><img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM5agVKfunUFTs9Tuv1fvKjle8wmJHuv0k020a903D2okQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/ialqibzk8KFoKOAd5HnAKnLvicCZCCq8fzLmmKiafwbvEGM/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM7yfRs1VFoTbId5DKRWibeOZ9sRwib2PzUDEgUglcu1vYpg/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/rKBCaRcVshMH0ic1RQ4V8uzP1Z0szDLDGxcRA3z8kbXeXbvseRWY8tw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/LIND77SSex8ZqicVrRMfK6ryNhWN9DY5lHvHFnSf4micmhbnEjTYReBQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6aItiau00AS7TQnsYprP9cO5RFHEr99ZE2hgD2faTsucQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/PiajxSqBRaEKE0yMqibUYlXRI21tb7MicV5XOzTJ9wA17KHiaRmODlZ50w/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM5vBgys23lGvvCzYTF12Md6FMTM9MhKA2eLvdiaksJOYbg/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/PiajxSqBRaEKKPZg1mcmxWvwAnsIsXqImEYwUmFHibKbRgvAEzLYYU7g/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6QpLxsdKvdk3iaIGkTrSJzxnmAheibiadzQtcyGeAsIPOCw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/0nn3FBrD9a0kGOjmw514CXCBic5B4RjPmQ2qjgq4q4kbiaKPFdanvV4Q/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6cuM8XXlnebhmicSEHjZKCZwTEIC0gtQ0yicjYrdKkGsYw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/ChCs6YSVOGX48AOdnS0YcicoM0QePT80iaRa7gicaKjnGH2RnhjbszvqA/132" alt="img"></p>
<p>文章已于2020-02-17修改</p>
<p>阅读 2251</p>
<p> 在看51</p>
<p><img src="http://wx.qlogo.cn/mmopen/ajNVdqHZLLBOFc3SlxHl8SiaktwhbV86M3npkpic3p0UOBic8jG6ofkTYYkAkt8r03JH2ErTDpYoAfLe2XReXd2MQ/132" alt="img"></p>
<p>写下你的留言</p>
<p><strong>精选留言</strong></p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ09VoiciamsXIuCxp5OPLQMicnzxsxWaKMZscEfI3uWe0Hhej2KGckMgOXXBfVicev1ibvMMaCcv1fNlibJGlKvftB75cia/96" alt="img">)<strong>子非鱼(朋友)</strong>置顶</p>
<p> 9</p>
</li>
</ul>
<p>  订正 1.最后一段代码两层for循环里的dp[i] = Math.min(dp[i- coins[j]], dp[i]) + 1 改为  dp[i] = Math.min(dp[i- coins[j]]+1, dp[i])  2. 三角形问题的dp方法的第二层for循环的判断语句 triangle[j].length里的 j 应该改成 i</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ09VoiciamsXIuCxp5OPLQMicnzxsxWaKMZscEfI3uWe0Hhej2KGckMgOXXBfVicev1ibvMMaCcv1fNlibJGlKvftB75cia/96" alt="img">)<strong>子非鱼(朋友)</strong></p>
<p> 9</p>
</li>
</ul>
<p>  原创真心不容易，大家记得顺手点点在看，你们轻轻点一下，我能开心一整天！！！</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ict5LWgjrbsy2KfIib6ibXfxVIbu2DCSQaOoB1IoV9e6aqTwXlWvuHJJFgNIiboGR7W7L1kW46M4rJ7ky5AxaCaVDr/96" alt="img"><strong>张原</strong></p>
<p> 3</p>
</li>
</ul>
<p>  写得很深入，有理有节，一气呵成，从浅到深，看得出来花了不少功夫。</p>
<p>  作者</p>
<p>   3</p>
<p>  写了一周</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/Ku8HXXjjiaeCkcvpdGkRgEQZia6o6z9ibQcJ5f6WhQmycbQmO2icn2xxXKibsBb41ewqcZuiakiaFHGkApd3fMVnfNvmiaEgzmXTWMRo/96" alt="img"><strong>Mark.Zhang</strong></p>
<p> 2</p>
</li>
</ul>
<p>  请问大神内容是如何排版的，很好看！</p>
<p>  作者</p>
<p>  关于排版，翻一下历史记录，有一篇自我介绍的文章里有介绍哦</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkWVXxmibPGFQqkzneicQIhgLbDthmTvzWhiaStzQqianFWRIwhhQUftDNbIeE30BI7afh9ibXBDzsiacqI4BUicD3AQfTk/96" alt="img"><strong>晨晨nu_morninglovelight光</strong></p>
<p> 1</p>
</li>
</ul>
<p>  最近正在研究运输问题，这篇文章正好提供了思路。感谢大神的原创！</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDcktoRhvFoE5uV7ygPu7hFJmK4oYpBzcfI89iaZPq9tkqjCSictciaDeDnI6BtH0Jl1hSZa9ib1TiahwYkkciansic7EVTf/96" alt="img"><strong>LeoRambo.木子李</strong></li>
</ul>
<p>  没有Python版的代码解析吗？</p>
<p>  作者</p>
<p>   1</p>
<p>  目前没有，之后的算法会加上Python 版本,这篇文章的动态规划到时也会补上，不过文章不能改了，建议关注下 <a href="https://github.com/allentofight/algorithm" target="_blank" rel="noopener">https://github.com/allentofight/algorithm</a> 这个地址，到时会加上</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/dH8QVxmk2IXSGuH5ibZ4C7NCvhvodzRibicicB23Hb5ro8AwvjCL3kwc6oe2iaoPibbmoruVvHFF0dictAA5zD25DjXcA/96" alt="img"><strong>晴久🍩</strong></p>
<p> 1</p>
</li>
</ul>
<p>  真香！</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDcnXfmmSeOkR041UHaTbgm0cQGYeVaj2hcfLq4AMXLhYrltUo1FaYZpiciaQWDKpicxMctB0qmoIG417RyM9uJZDXx3/96" alt="img"><strong>轩辕之风</strong></p>
<p> 1</p>
</li>
</ul>
<p>  摩拜算法大侠</p>
<p>  作者</p>
<p>  共同进步</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkUYbgJricIeraiaia5WoHjZqBWgo8aclB0QFKOhpBqTICdZwEWSFZ7viaTabeRHKlWMbOBvpOWic8r1qib2uBGOkffOcic/96" alt="img"><strong>zenblo</strong></p>
<p> 1</p>
</li>
</ul>
<p>  写的真好，排版看的很舒服！收藏了</p>
<p>  作者</p>
<p>  多谢支持！</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkVtkaV2XenwQ0a2ibEe5vVCBuMdFVBH9CpMiauC8icxRIbVvGMd74RIweqfMC5VyjLHtOnfhaWbDU8HticcUCD7ricgz/96" alt="img"><strong>胡兴胜</strong></li>
</ul>
<p>  [[2, 0, 0, 0], [5, 4, 0, 0], [6, 5, 7, 0], [12, 3, 3, 3]] sum2: 12                                            加一行打印原数组，原数组最后一行变了</p>
<p>  作者</p>
<p>  大概明白你的意思，你应该是说原来mini指向的是最后一行，在不断修改中把最后一行给改了，但改了又有啥关系呢，不影响问题的求解吧，除非题目说不能修改原数组</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkVtkaV2XenwQ0a2ibEe5vVCBuMdFVBH9CpMiauC8icxRIbVvGMd74RIweqfMC5VyjLHtOnfhaWbDU8HticcUCD7ricgz/96" alt="img"><strong>胡兴胜</strong></li>
</ul>
<p>   非常精彩，请问一个问题：三角形最小路径和采用dp方式时，为什么原triangle数组发生了改变？[[92, 0, 0, 0], [94, 52, 0, 0], [24, 1, 74, 0], [60, 55, 56, 4]] –&gt;[[92, 0, 0, 0], [94, 52, 0, 0], [24, 1, 74, 0], [200, 4, 4, 4]],即最后一行的值换成了min[]数组了</p>
<p>  作者</p>
<p>  triangle没变，只是min数组一直在变，你是否看错了</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/Q3auHgzwzM4vf6HiaRRT1ibl1G0fesnUib3w2bcA8DWlTPuic4YHm2AtfVqxmK4XujyibjPuptqnpgib6ic8JHHA8PvSQ/96" alt="img"><strong>Tansir</strong></li>
</ul>
<p>  写得真好</p>
<p>  作者</p>
<p>  多谢支持</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ibz2Ollk38ubPwudDYBDw2lkxBsyVicS0kyhA2Gz2E1vAh35Bt50ayula9YxAKq8rllSFJ9D2rQuktq4crFXkzeb/96" alt="img"><strong>Zheng.</strong></li>
</ul>
<p>  作者辛苦了 看得我很过瘾 收获很多🌝</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/Ku8HXXjjiaeCkcvpdGkRgEVUXKW723zCEf2or9CYCAv1tDrqiaz1kyZZBhNSvlBJ411TjfsGTeOwoZ0ZZwiaiamGkcVAM4dIFibgE/96" alt="img"><strong>H[- -] ᒼ</strong></li>
</ul>
<p>  请问哪里有完整的source code呢</p>
<p>  作者</p>
<p>  你好， <a href="https://github.com/allentofight/algorithm" target="_blank" rel="noopener">https://github.com/allentofight/algorithm</a> 所有相关的代码都在这个地址上，这篇文章的代码这两天会更新哈，敬请关注哦</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkUiasONmCDSk5lDIsauSiaNlzGwrbr1XRATMOVGZqbayAXibAT0tt6dLam50IjHLW7NzDibI5SFTFRJHgsLpCvCMiaPw/96" alt="img"><strong>又要过年了🌚疯狂暗示</strong></li>
</ul>
<p>  666</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDclEbwE43hBwzsiaGAEtVPwySrpGtYsWeyXkKrWQknAKlmDy11oMyP2diaxElzIdtrOcbdIhicNKvM7mfastDTYiangr/96" alt="img"><strong>失火的夏天</strong></li>
</ul>
<p>  前天刚刚才玩了这个零钱</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkWMeB4Our7tXp3lROpe1tncuFjmnAnAqyXCFK7Zwtokgav6LM85NickchC4RJzIcwGWhO3p3BbmfzZYknyCzjur4/96" alt="img"><strong>why</strong></li>
</ul>
<p>  牛皮！沙发。</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ib93U81FtF1YPkYKuas2xWKiaYibxHcmu3fTrhgvn3OxgZibHm5ShoP6r4yRzNN2ATcQbH7icZDcaRx30NLxEvVeMrg/96" alt="img"><strong>大白</strong></li>
</ul>
<p>  强势收藏!</p>
]]></content>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/05/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Quick2Sort</span><span class="params">(values []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(values) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mid, i := values[<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">	head, tail := <span class="number">0</span>, <span class="built_in">len</span>(values)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> head &lt; tail &#123;</span><br><span class="line">		fmt.Println(values)</span><br><span class="line">		<span class="keyword">if</span> values[i] &gt; mid &#123;</span><br><span class="line">			values[i], values[tail] = values[tail], values[i]</span><br><span class="line">			tail--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			values[i], values[head] = values[head], values[i]</span><br><span class="line">			head++</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	values[head] = mid</span><br><span class="line">	Quick2Sort(values[:head])</span><br><span class="line">	Quick2Sort(values[head+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        第一步,取排序数组的第一个元素values[0],然后从第二个元素遍历数组,将values[0]与该元素比较,如果大于values[0],就将其放到数组末尾(依次往前),否则放到前边(依次往后),直到两个指针相遇,然后将中间值与第一个数进行调换,然后以改值为中心将其分割为两个数组,继续递归调用该方法.</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="comment">//外层步长控制</span></span><br><span class="line">    <span class="keyword">for</span> step := <span class="built_in">len</span>(nums) / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//开始插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := step; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="comment">//满足条件则插入</span></span><br><span class="line">            <span class="keyword">for</span> j := i - step; j &gt;= <span class="number">0</span> &amp;&amp; nums[j+step] &lt; nums[j]; j -= step &#123;</span><br><span class="line">                nums[j], nums[j+step] = nums[j+step], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>求二数的最大公约数</title>
    <url>/2020/05/15/%E6%B1%82%E4%BA%8C%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h1 id="二数的最大公约数"><a href="#二数的最大公约数" class="headerlink" title="二数的最大公约数"></a>二数的最大公约数</h1><h3 id="1-辗转相除法"><a href="#1-辗转相除法" class="headerlink" title="1. 辗转相除法"></a>1. 辗转相除法</h3><p>​        又名欧几里得算法（Euclidean algorithm），该算法的目的 是求出两个正整数的最大公约数。它是已知最古老的算法， 其产生时间可追溯至公 元前300年前。</p>
<p>​        这条算法基于一个定理：两个正整数a和b（a&gt;b），它们的最大公约数等于a除 以b的余数c和b之间的最大公约数。 例如10和25，25除以10商2余5，那么10和25的最大公约数，等同于10和5的最 大公约数。</p>
<p>java代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGreatestCommonDivisorV2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">        <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">        <span class="keyword">if</span> (big % small == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> small;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getGreatestCommonDivisorV2(small, big % small);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>go代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-更相减损术"><a href="#2-更相减损术" class="headerlink" title="2. 更相减损术"></a>2. 更相减损术</h3><p>​        两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差 值c和较小数b的最大公约数。例如10和25，25减10的差是15，那么10和25的最大 公约数，等同于10和15的最大公约数。</p>
<p>java代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGreatestCommonDivisorV3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">     <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">     <span class="keyword">if</span> (big % small == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> small;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> getGreatestCommonDivisorV3(big-small, small);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-最优解-综合位运算"><a href="#3-最优解-综合位运算" class="headerlink" title="3.最优解(综合位运算)"></a>3.最优解(综合位运算)</h3><ul>
<li><p>当a和b均为偶数时，gcd(a,b) = 2×gcd(a/2, b/2) = 2×gcd(a&gt;&gt;1,b&gt;&gt;1)。</p>
</li>
<li><p>当a为偶数，b为奇数时，gcd(a,b) = gcd(a/2,b) = gcd(a&gt;&gt;1,b)。</p>
</li>
<li><p>当a为奇数，b为偶数时，gcd(a,b) = gcd(a,b/2) = gcd(a,b&gt;&gt;1)。 </p>
</li>
<li><p>当a和b均为奇数时，先利用更相减损术运算一次，gcd(a,b) = gcd(b,a-b)，此 时a-b必然是偶数，然后又可以继续进行移位运算。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//a b 同时为偶数数</span></span><br><span class="line">        <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//相当于2(a/2,b/2)</span></span><br><span class="line">            <span class="keyword">return</span> gcd(a&gt;&gt;<span class="number">1</span>,b&gt;&gt;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//a为偶数,b为奇数</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((a &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(a&gt;&gt;<span class="number">1</span>,b);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(a,b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//同为奇数进行一次用更相减损术</span></span><br><span class="line">            <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">            <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">            <span class="keyword">return</span> gcd(big-small,small);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="判断一个数是不是2的整数次幂"><a href="#判断一个数是不是2的整数次幂" class="headerlink" title="判断一个数是不是2的整数次幂"></a>判断一个数是不是2的整数次幂</h1><p> (num&amp;num-1) == 0 为整数次幂  num&amp;num-1的作用是将该数的最后一位1改为0</p>
]]></content>
  </entry>
  <entry>
    <title>电话号码组合</title>
    <url>/2020/05/15/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="电话号码组合"><a href="#电话号码组合" class="headerlink" title="电话号码组合"></a>电话号码组合</h1><ul>
<li><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>将所有的数字对应的字母拆成单个的字母,存在一个map中,key对应数字,value对应相应的byte类型字母组合</li>
<li>遍历输入的字符串,并用该字符去减’0’,既找到改数字对应的数,然后去map中取对应的value,存在数组arr中</li>
<li>事先建立一个res数组(string类型),并将第一个元素赋值为空字符串</li>
<li>遍历res数组,</li>
<li>遍历arr数组,将每一个值与res的第一字符串进行拼接,遍历结束后,将res数组中的第一个元素删除,直至循环结束<ul>
<li>概括就是 删除头,末尾追加</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> digits == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	digitsmap := <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"2"</span>: &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;,</span><br><span class="line">		<span class="string">"3"</span>: &#123;<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>&#125;,</span><br><span class="line">		<span class="string">"4"</span>: &#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;,</span><br><span class="line">		<span class="string">"5"</span>: &#123;<span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>&#125;,</span><br><span class="line">		<span class="string">"6"</span>: &#123;<span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"o"</span>&#125;,</span><br><span class="line">		<span class="string">"7"</span>: &#123;<span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>&#125;,</span><br><span class="line">		<span class="string">"8"</span>: &#123;<span class="string">"t"</span>, <span class="string">"u"</span>, <span class="string">"v"</span>&#125;,</span><br><span class="line">		<span class="string">"9"</span>: &#123;<span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//append只是进行了追加操作,得到了新的新结果,若想使用,需接受改结果</span></span><br><span class="line">	res = <span class="built_in">append</span>(res, <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(digits); i++ &#123;</span><br><span class="line">		reagen := <span class="built_in">len</span>(res)</span><br><span class="line">		digit := digits[i : i+<span class="number">1</span>]</span><br><span class="line">        str := digitsmap[digit]</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; reagen; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> _, letter := <span class="keyword">range</span> str&#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res, res[<span class="number">0</span>]+letter)</span><br><span class="line">			&#125;</span><br><span class="line">			res = res[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>猜数字</title>
    <url>/2020/05/15/%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="猜数字问题XAXB-文曲星-go语言实现"><a href="#猜数字问题XAXB-文曲星-go语言实现" class="headerlink" title="猜数字问题XAXB,文曲星,go语言实现"></a>猜数字问题XAXB,文曲星,go语言实现</h1><p>同事给我甩过来一个题,如下<br>猜数字游戏通常由两个人玩，一方出数字，一方猜。出数字的人要想好一个没有重复数<br>字的 4 个数，不能让猜的人知道。猜的人就可以开始猜。每猜一个数字，出数者就要根据这<br>个数字给出几 A 几 B，其中 A 前面的数字表示位置正确的数的个数，而 B 前的数字表示数字<br>正确而位置不对的数的个数。如正确答案为 5234，而猜的人猜 5346，则是 1A2B，其中有<br>一个 5 的位置对了，记为 1A，而 3 和 4 这两个数字对了，而位置没对，因此记为 2B，合起<br>来就是 1A2B。接着猜的人再根据出题者的几 A 几 B 继续猜，直到猜中（即 4A0B）为止。<br>猜的人有 8 次机会。</p>
<p>例如：<br>乙出一个数字，甲猜。<br>  甲       乙<br>1234 1A0B<br>5678 2A1B<br>5674 1A1B<br>5638 1A1B<br>2678 2A2B<br>6278 4A0B(猜中)<br>现需设计一个程序，以甲的身份(注意是甲的身份)猜对方的数字。<br>请设计方案并且列出主要方法名。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我用的是暴力解法:<br>1.将四位数字中所有的不重复数字找出,并存到切片中.代码如下<br>//获取所有不重复的四位数字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有的不重复四位数字,存在切片中(由于使用的是数字所以1000一下的显示为三位,但后续也会将其当四位数字处理)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbs</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == i &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> m := <span class="number">0</span>; m &lt; <span class="number">10</span>; m++ &#123;</span><br><span class="line">				<span class="keyword">if</span> m == j || m == i &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">10</span>; n++ &#123;</span><br><span class="line">					<span class="keyword">if</span> n == m || n == j || n == i &#123;</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					a := i*<span class="number">1000</span> + j*<span class="number">100</span> + m*<span class="number">10</span> + n</span><br><span class="line">					arr = <span class="built_in">append</span>(arr, a)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.取切片中的第一个数(0123)去跟目标值匹配,得到一个结果,类似0A1B,记下该结果</p>
<p>3.重点来了,循环将第一个数跟所有的数匹配,得到结果这里我直接省事返回的是 “01”这种,<br>然后将这个结果和第二步的结果去比对,不一样的统统删除(这里因为切片的删除比较麻烦,我是将其赋值为0),代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">​<span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">//这是将两数进行比对的方法</span></span><br><span class="line"><span class="string">func match(target int, numInp int) string &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	numMap := make(map[int]int)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	for i := 0; i &lt; 4; i++ &#123;</span></span><br><span class="line"><span class="string">	//将四位数分别放到map中,对应key 为1 2 3 4 </span></span><br><span class="line"><span class="string">		a := target</span></span><br><span class="line"><span class="string">		if a &lt; 1000 &#123;</span></span><br><span class="line"><span class="string">			numMap[1] = 0</span></span><br><span class="line"><span class="string">			numMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			numMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			numMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			numMap[1] = a / 1000</span></span><br><span class="line"><span class="string">			numMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			numMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			numMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	inpMap := make(map[int]int)</span></span><br><span class="line"><span class="string">	for i := 0; i &lt; 4; i++ &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		a := numInp</span></span><br><span class="line"><span class="string">		if a &lt; 1000 &#123;</span></span><br><span class="line"><span class="string">			inpMap[1] = 0</span></span><br><span class="line"><span class="string">			inpMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			inpMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			inpMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			inpMap[1] = a / 1000</span></span><br><span class="line"><span class="string">			inpMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			inpMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			inpMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	var counta int</span></span><br><span class="line"><span class="string">	//将两个数对应的map中的对应的位比对,相等</span></span><br><span class="line"><span class="string">	for i := 1; i &lt; 5; i++ &#123;</span></span><br><span class="line"><span class="string">		if numMap[i] == inpMap[i] &#123;</span></span><br><span class="line"><span class="string">			counta++</span></span><br><span class="line"><span class="string">			delete(numMap, i)</span></span><br><span class="line"><span class="string">			delete(inpMap, i)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//fmt.Println(numMap)</span></span><br><span class="line"><span class="string">	//fmt.Println(inpMap)</span></span><br><span class="line"><span class="string">	var countb int</span></span><br><span class="line"><span class="string">	for i := 1; i &lt; 5; i++ &#123;</span></span><br><span class="line"><span class="string">		_, ok := inpMap[i]</span></span><br><span class="line"><span class="string">		if !ok &#123;</span></span><br><span class="line"><span class="string">			continue</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		for j := 1; j &lt; 5; j++ &#123;</span></span><br><span class="line"><span class="string">			_, ok := numMap[j]</span></span><br><span class="line"><span class="string">			if !ok &#123;</span></span><br><span class="line"><span class="string">				continue</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			if inpMap[i] == numMap[j] &#123;</span></span><br><span class="line"><span class="string">				countb++</span></span><br><span class="line"><span class="string">				delete(inpMap, i)</span></span><br><span class="line"><span class="string">				delete(numMap, j)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//fmt.Printf("%v A %v B", counta, countb)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return strconv.Itoa(counta)+strconv.Itoa(countb)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//判断结果的方法</span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">	arr := numbs()</span></span><br><span class="line"><span class="string">	num := arr[0]</span></span><br><span class="line"><span class="string">	fmt.Println(num)</span></span><br><span class="line"><span class="string">	var count int</span></span><br><span class="line"><span class="string">	for &#123;</span></span><br><span class="line"><span class="string">		fmt.Println("请输入猜的结果1A1B既输入11")</span></span><br><span class="line"><span class="string">		var result string</span></span><br><span class="line"><span class="string">		fmt.Scanln(&amp;result)</span></span><br><span class="line"><span class="string">		for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">			if arr[i] == 0 &#123;</span></span><br><span class="line"><span class="string">				continue</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			str := match(num, arr[i])</span></span><br><span class="line"><span class="string">			fmt.Println(str)</span></span><br><span class="line"><span class="string">			if result != str &#123;</span></span><br><span class="line"><span class="string">				arr[i] = 0</span></span><br><span class="line"><span class="string">				count++</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		fmt.Printf("count: %v \n",count)</span></span><br><span class="line"><span class="string">		for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">			if arr[i] != 0 &#123;</span></span><br><span class="line"><span class="string">				fmt.Printf("下一个数字 %v \n", arr[i])</span></span><br><span class="line"><span class="string">				num = arr[i]</span></span><br><span class="line"><span class="string">				break</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if count == 5039 &#123;</span></span><br><span class="line"><span class="string">			for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">				if arr[i] != 0 &#123;</span></span><br><span class="line"><span class="string">					fmt.Printf("正确答案: %v", arr[i])</span></span><br><span class="line"><span class="string">					return</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">​</span></span><br></pre></td></tr></table></figure>
<p>```</p>
<p>执行一轮后, 继续给出切片中剩余不为零的第一个元素,将获取的值继续给到程序中进行比对,直到切片中只有一个不为0元素,即为正确数字</p>
<p>4.此算法最多是8步,平均值因为做的实验较少,未知,还有其他更好的算法,希望大佬指出</p>
]]></content>
  </entry>
  <entry>
    <title>盛水最多的容器</title>
    <url>/2020/05/15/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="盛水最多的容器-java-和go语言实现"><a href="#盛水最多的容器-java-和go语言实现" class="headerlink" title="盛水最多的容器 java 和go语言实现"></a>盛水最多的容器 java 和go语言实现</h1><p>​        给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p>​         此题使用了双指针的解法,就是从两侧同时扫描,时间复杂度从O(n²)降到了O(n)这里就需要多思考,当一个问题需要用到双重循环解决的时候,就要看该问题能否用双指针解决</p>
<p>​        以下为原始代码(我的),双重循环:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        maxs = Math.max(maxs,Math.min(height[l],height[r])*(r-l));</span><br><span class="line">        <span class="keyword">if</span> (height[l]&gt;height[r])</span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以下为双指针解法,大佬的答案:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxarea = <span class="number">0</span>, l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">           maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">           <span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">               l++;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               r--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxarea;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>以下为go语言解法,不过好坑,go的自带工具包是真的少</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    macs := <span class="number">0</span></span><br><span class="line">	l := <span class="number">0</span></span><br><span class="line">	r := <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">		macs = Max(macs, Min(height[l], height[r])*(r-l))</span><br><span class="line">		<span class="keyword">if</span> height[l] &lt; height[r] &#123;</span><br><span class="line">			l++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> macs</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义的取两个值中较小值的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b &lt; a &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Max max 自定义的取两个值中较大值的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b &gt; a &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>约瑟夫环——公式法（递推公式）</title>
    <url>/2020/05/15/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E6%B3%95%EF%BC%88%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h1 id="约瑟夫环——公式法（递推公式）"><a href="#约瑟夫环——公式法（递推公式）" class="headerlink" title="约瑟夫环——公式法（递推公式）"></a>约瑟夫环——公式法（递推公式）</h1><h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2><p>约瑟夫问题是个著名的问题：N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。<br>例如只有三个人，把他们叫做A、B、C，他们围成一圈，从A开始报数，假设报2的人被杀掉。</p>
<p>首先A开始报数，他报1。侥幸逃过一劫。<br>然后轮到B报数，他报2。非常惨，他被杀了<br>C接着从1开始报数<br>接着轮到A报数，他报2。也被杀死了。<br>最终胜利者是C</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><p>刚学数据结构的时候，我们可能用链表的方法去模拟这个过程，N个人看作是N个链表节点，节点1指向节点2，节点2指向节点3，……，节点N-1指向节点N，节点N指向节点1，这样就形成了一个环。然后从节点1开始1、2、3……往下报数，每报到M，就把那个节点从环上删除。下一个节点接着从1开始报数。最终链表仅剩一个节点。它就是最终的胜利者。</p>
<p>缺点：<br>要模拟整个游戏过程，时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果的。</p>
<h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><p>约瑟夫环是一个经典的数学问题，我们不难发现这样的依次报数，似乎有规律可循。为了方便导出递推式，我们重新定义一下题目。<br>问题： N个人编号为1，2，……，N，依次报数，每报到M时，杀掉那个人，求最后胜利者的编号。</p>
<p>这边我们先把结论抛出了。之后带领大家一步一步的理解这个公式是什么来的。<br>递推公式：<br>f(N,M)=(f(N−1,M)+M)%Nf(N,M)=(f(N-1,M)+M)%N<br>f(N,M)=(f(N−1,M)+M)%N</p>
<p>f(N,M)f(N,M)f(N,M)表示，N个人报数，每报到M时杀掉那个人，最终胜利者的编号<br>f(N−1,M)f(N-1,M)f(N−1,M)表示，N-1个人报数，每报到M时杀掉那个人，最终胜利者的编号<br>下面我们不用字母表示每一个人，而用数字。<br>1、2、3、4、5、6、7、8、9、10、111、 2 、 3、 4、5 、6、 7 、 8、 9、 10、 11<br>1、2、3、4、5、6、7、8、9、10、11</p>
<p>表示11个人，他们先排成一排，假设每报到3的人被杀掉。</p>
<p>刚开始时，头一个人编号是1，从他开始报数，第一轮被杀掉的是编号3的人。<br>编号4的人从1开始重新报数，这时候我们可以认为编号4这个人是队伍的头。第二轮被杀掉的是编号6的人。<br>编号7的人开始重新报数，这时候我们可以认为编号7这个人是队伍的头。第三轮被杀掉的是编号9的人。<br>……<br>第九轮时，编号2的人开始重新报数，这时候我们可以认为编号2这个人是队伍的头。这轮被杀掉的是编号8的人。<br>下一个人还是编号为2的人，他从1开始报数，不幸的是他在这轮被杀掉了。<br>最后的胜利者是编号为7的人。<br>下图表示这一过程（先忽视绿色的一行）</p>
<p>现在再来看我们递推公式是怎么得到的！<br>将上面表格的每一行看成数组，这个公式描述的是：幸存者在这一轮的下标位置</p>
<p>f(1,3)f(1,3)f(1,3)：只有1个人了，那个人就是获胜者，他的下标位置是0<br>f(2,3)=(f(1,3)+3)%2=3%2=1f(2,3)=(f(1,3)+3)%2=3%2=1f(2,3)=(f(1,3)+3)%2=3%2=1：在有2个人的时候，胜利者的下标位置为1<br>f(3,3)=(f(2,3)+3)%3=4%3=1f(3,3)=(f(2,3)+3)%3=4%3=1f(3,3)=(f(2,3)+3)%3=4%3=1：在有3个人的时候，胜利者的下标位置为1<br>f(4,3)=(f(3,3)+3)%4=4%4=0f(4,3)=(f(3,3)+3)%4=4%4=0f(4,3)=(f(3,3)+3)%4=4%4=0：在有4个人的时候，胜利者的下标位置为0<br>……<br>f(11,3)=6f(11,3)=6f(11,3)=6<br>很神奇吧！现在你还怀疑这个公式的正确性吗？上面这个例子验证了这个递推公式的确可以计算出胜利者的下标，下面将讲解怎么推导这个公式。<br><strong>问题1：</strong>假设我们已经知道11个人时，胜利者的下标位置为6。那下一轮10个人时，胜利者的下标位置为多少？<br><strong>答：</strong>其实吧，第一轮删掉编号为3的人后，之后的人都往前面移动了3位，胜利这也往前移动了3位，所以他的下标位置由6变成3。</p>
<p><strong>问题2：</strong>假设我们已经知道10个人时，胜利者的下标位置为3。那下一轮11个人时，胜利者的下标位置为多少？<br><strong>答：</strong>这可以看错是上一个问题的逆过程，大家都往后移动3位，所以f(11,3)=f(10,3)+3f(11,3)=f(10,3)+3f(11,3)=f(10,3)+3。不过有可能数组会越界，所以最后模上当前人数的个数，f(11,3)=（f(10,3)+3）%11f(11,3)=（f(10,3)+3）%11f(11,3)=（f(10,3)+3）%11</p>
<p><strong>问题3：</strong>现在改为人数改为N，报到M时，把那个人杀掉，那么数组是怎么移动的？<br><strong>答：</strong>每杀掉一个人，下一个人成为头，相当于把数组向前移动M位。若已知N-1个人时，胜利者的下标位置位f(N−1,M)f(N-1,M)f(N−1,M)，则N个人的时候，就是往后移动M为，(因为有可能数组越界，超过的部分会被接到头上，所以还要模N)，既f(N,M)=(f(N−1,M)+M)%nf(N,M)=(f(N-1,M)+M)%nf(N,M)=(f(N−1,M)+M)%n</p>
<p><strong>注：</strong>理解这个递推式的核心在于关注胜利者的下标位置是怎么变的。每杀掉一个人，其实就是把这个数组向前移动了M位。然后逆过来，就可以得到这个递推式。</p>
<p>因为求出的结果是数组中的下标，最终的编号还要加1</p>
<p>下面给出代码实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastRemaining</span><span class="params">(n <span class="keyword">int</span>, m <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    flag := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++&#123;</span><br><span class="line">        flag = (flag + m) % i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/05/15/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="图解啥是贪心算法？"><a href="#图解啥是贪心算法？" class="headerlink" title="图解啥是贪心算法？"></a>图解啥是贪心算法？</h2><p>以下文章来源于码海 ，作者码海</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将会从以下几个方面来介绍贪心算法</p>
<ul>
<li>什么是贪心算法</li>
<li>贪心算法例题详题</li>
<li>贪心算法适用场景</li>
<li>再看三角形最短路径和是否能用贪心算法求解</li>
</ul>
<h2 id="什么是贪心算法"><a href="#什么是贪心算法" class="headerlink" title="什么是贪心算法"></a>什么是贪心算法</h2><p>贪心算法是指在每个阶段做选择的时候都做出当前阶段（或状态）最好的选择，并且<strong>期望</strong>这样做到的结果是全局最优解（但未必是全局最优解）</p>
<p>贪心算法其实是动态规划的一种,由于它的「贪心」，只着眼于当前阶段的最优解，所以每个子问题<strong>只会被计算一次</strong>，如果由此能得出全局最优解，相对于动态规划要对每个子问题求全局最优解，它的时间复杂度无疑是会下降一个量级的。</p>
<p>举个简单的例子，比如给定某个数字的金额（如 250）与 100, 50, 10, 5, 1 这些纸币（不限量），怎么能用最少张的纸币来兑换这张金额呢，显然每次兑换应该先从大额的纸币兑换起，第一次选 100， 第二次还是选 100， 第三次选第二大的 50 元，每次都选小于剩余金额中的最大面额的纸币，这样得出的解一定是全局最优解！时间复杂度无疑是线性的。</p>
<p>我们先来看几道可以用贪心算法来求解的例题</p>
<h2 id="贪心算法例题详题"><a href="#贪心算法例题详题" class="headerlink" title="贪心算法例题详题"></a>贪心算法例题详题</h2><h3 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h3><blockquote>
<p>有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m &lt; n），所以糖果只能分配给一部分孩子。每个糖果的大小不等，这 m 个糖果的大小分别是s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。那么如何分配糖果，能尽可能满足最多数量的孩子呢?</p>
</blockquote>
<p>求解：这道题如果用贪心来解解题思路还是比较明显的，对于每个小孩的需求 gn，只要给他所有大小大于 gn 的糖果中的最小值即可，这样就能把更大的糖果让给需求更大的小孩。整个代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *  获取能分配给小孩且符合条件的最多糖果数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static int dispatchCandy(int[] gList, int[] sList) &#123;</span><br><span class="line">        Arrays.sort(gList);     &#x2F;&#x2F; 小孩对糖果的需求从小到大排列</span><br><span class="line">        Arrays.sort(sList);     &#x2F;&#x2F; 糖果大小从小到大排列</span><br><span class="line"></span><br><span class="line">        int maximumCandyNum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; gList.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; sList.length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 选择最接近小孩需求的糖果，以便让更大的糖果满足需求更大的小孩</span><br><span class="line">                if (gList[i] &lt;&#x3D; sList[j]) &#123;</span><br><span class="line">                    maximumCandyNum++;</span><br><span class="line">                    &#x2F;&#x2F; 糖果被选中，将其置为-1，代表无效了</span><br><span class="line">                    sList[j] &#x3D; -1;</span><br><span class="line">                    &#x2F;&#x2F; 当前小孩糖果已选中，跳出</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maximumCandyNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 小孩对糖果的需求</span><br><span class="line">        int[] gList &#x3D; &#123;1,2,4,6&#125;;</span><br><span class="line">        &#x2F;&#x2F; 糖果实际大小</span><br><span class="line">        int[] sList &#x3D; &#123;1,2,7,3&#125;;</span><br><span class="line">        int result &#x3D; dispatchCandy(gList, sList);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><blockquote>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。注意:可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 </p>
<p>示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p>示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p>示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p>
</blockquote>
<p>区间重叠可以在生活中的很多场景里找到，比如任务调度，一个工人在一段时间内需要完成多项任务，每个任务需要完成的时间不同，如何在这段时间内让工人尽可能多地完成这些任务呢（任务与任务之间进行的时间不能重叠，一个工人不可能在同一段时间内同时进行两项任务）</p>
<p>解题思路: 这道题我们分别用动态规划和贪心算法来解一下，以便对比一下两者的时间复杂度，看下贪心算法是否在时间复杂度上更优胜一些。</p>
<p><strong>动态规划解法</strong></p>
<p>首先为了方便求解，我们把每个区间按区间的起始点从小到大进行排序，如图示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUpYmdm1naVoFCzTXwr1GnEK92IZCYmI8ITsM7Px90GVCSCy01H7H0Cj6eSPM9quibxvFFibzvOuA4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>接下来我们套用<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21#wechat_redirect" target="_blank" rel="noopener">上篇</a>中的说的动态规划解题四步曲来看看怎么用动态规划进行求解。</p>
<p><strong>1、 判断是否可用递归来解</strong></p>
<p>其实直观地看上面我们排好序的各个区间，这不就是个组合吗，每个区间要么选，要么不选，把所有的组合穷举出来，再看哪个组合最符合题目中的条件，所以无疑是可以用递归的（组合用递归怎么解，强烈建议看下<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483857&idx=1&sn=c4fbb9d55a656aac55c4976c48879c45&scene=21#wechat_redirect" target="_blank" rel="noopener">这篇文章</a>）。</p>
<p>不过这题的组合有点特殊，前后两个区间有条件限制，如果当前区间与前一个区间重叠，则这两者只能取其一（另一个需要剔除掉防止重叠），于是我们有如下思路：</p>
<p>定义两个值, pre , cur ，分别代表前一个区间与当前区间，需要进行如下步骤</p>
<ol>
<li>比较前一个区间的终点与当前区间的起始值</li>
<li>如果前一个区间的终点小于当前区间的起始值，代表两区间不重叠，则将 pre 置为 cur, cur 置为 cur + 1, 开始接下来紧邻的两个区间的判断（即重复步骤 1）。</li>
<li>如果前一个区间的终点大于当前区间的起始值，代表两区间重叠，则 pre 不变, cur 置为 cur + 1 (即将 cur 对应的区间移除)，注意此时移除区间数要加 1, 然后开始接下来 pre，cur+1 区间的判断（即重复步骤 1）。</li>
</ol>
<p><em>注：**首次区间遍历我们定义 pre = -1，cur = 0</em></p>
<p>从以上的描述中可以很明显地看到存在递归现象，于是我们写出了如下代码,关键代码都作了详细的注释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; 区间类，包括起始值和终止值</span><br><span class="line">    private  static  class Interval &#123;</span><br><span class="line">        int start;</span><br><span class="line">        int end;</span><br><span class="line">        Interval(int start, int end) &#123;</span><br><span class="line">            this.start &#x3D; start;</span><br><span class="line">            this.end &#x3D; end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Integer removeDuplicateIntervas(Interval[] intervals) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将区间按起始点由小到大进行排序</span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a.start));</span><br><span class="line">        &#x2F;&#x2F; 首次遍历从 -1,0 开始</span><br><span class="line">        return removeSubDuplicate(-1, 0, intervals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Integer removeSubDuplicate(int pre, int cur, Interval[] intervals) &#123;</span><br><span class="line">        if (cur &#x3D;&#x3D; intervals.length) &#123;</span><br><span class="line">            return  0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int notRemove &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        if (pre &#x3D;&#x3D; -1 || intervals[pre].end &lt;&#x3D; intervals[cur].start) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 如果是首次遍历，或者 pre 区间的终点小于 cur 区间的起点（即区间不重叠）,</span><br><span class="line">             * 则 pre &#x3D; cur; cur &#x3D; cur+1</span><br><span class="line">             *&#x2F;</span><br><span class="line">            notRemove &#x3D; removeSubDuplicate(cur, cur+1, intervals);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 如果 pre 区间的终点大于 cur 区间的起点，代表两区间重叠，cur 指向后一个区间，即 cur &#x3D; cur + 1</span><br><span class="line">         * 代表 cur 被移除，所以需要加1（代表这个区间被移除了）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int remove &#x3D; removeSubDuplicate(pre, cur+1, intervals) + 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 取两者的较小值</span><br><span class="line">        return Math.min(notRemove, remove);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化区间</span><br><span class="line">        Interval[] intervals &#x3D; &#123;</span><br><span class="line">                new Interval(1, 2),</span><br><span class="line">                new Interval(3, 5),</span><br><span class="line">                new Interval(4, 7),</span><br><span class="line">                new Interval(8, 10),</span><br><span class="line">                new Interval(9, 11)</span><br><span class="line">        &#125;;</span><br><span class="line">        int result &#x3D; removeDuplicateIntervas(intervals);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、 分析在递归的过程中是否存在大量的重复子问题</strong></p>
<p>怎么判断是否存在大量的重复子问题，在<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21#wechat_redirect" target="_blank" rel="noopener">一文学会动态规划解题技巧</a> 我们提出一种方案，画出递归树 ，不过这题如果画出递归树比较麻烦，其实对于组合问题我们可以简单分析一下，对于每个区间要么选，要么不选，我们以 1 代表该区间被选择，以 0 代表该区间不选，则简单考虑一下如下两个组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11010</span><br><span class="line">11001</span><br></pre></td></tr></table></figure>

<p>仔细看，红框 部分，就是重复子问题！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>可能有人会说这样分析也有点难，那我再教大家一招，打印! 如图示</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>在递归函数中打印出来，然后分析打印的规律</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>可以看到，确实存在着重复子问题，时间复杂度是多少呢，每个区间要么选，要么不选，共有两个状态，如果有 n 个区间的话，就是 2^n,于是我们知道时间复杂度是 O(2^n)，指数级！显然无法接受</p>
<p>既然存在重复子问题，那我们进入动态规划第三步</p>
<p><strong>3、采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</strong></p>
<p>在以上的分析中基本我们看到，其实就是 pre, cur 有可能存在大量重复，于是我们保存 pre, cur 对应的中间结果，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 保存中间结果</span><br><span class="line">private static HashMap&lt;String, Integer&gt; map &#x3D; new HashMap();</span><br><span class="line">private static Integer removeSubDuplicate(int pre, int cur, Interval[] intervals) &#123;</span><br><span class="line">    String key &#x3D; pre + &quot;,&quot; + cur;</span><br><span class="line">    if (map.get(key) !&#x3D; null) &#123;</span><br><span class="line">        return map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (cur &#x3D;&#x3D; intervals.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int notRemove &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    if (pre &#x3D;&#x3D; -1 || intervals[pre].end &lt;&#x3D; intervals[cur].start) &#123;</span><br><span class="line">        notRemove &#x3D; removeSubDuplicate(cur, cur+1, intervals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int remove &#x3D; removeSubDuplicate(pre, cur+1, intervals) + 1;</span><br><span class="line">    int result &#x3D; Math.min(notRemove, remove);</span><br><span class="line">    map.put(key, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用备忘录的方式缓存子问题的中间结果后，时间复杂度直线下降，达到 O(n^2)（因为 pre, cur 两个变量不断往后移，即两层循环，所以是 O(n^2)） 。</p>
<p><strong>4、改用自底向上的方式来递推，即动态规划</strong></p>
<p>我们定义 dp[i] 为 从 0 到 第 i 个区间的最大<strong>不重叠</strong>区间数,于是我们得出了状态转移方程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] &#x3D; max&#123;dp[j]&#125; + 1, 其中 0 &lt;&#x3D;j &lt; i 并且需要满足一个条件 interval[i].start &gt; interval[j].end,即保证 i, j 指向的区间不重叠。</span><br></pre></td></tr></table></figure>

<p>则最终的 dp[区间总个数-1] 即为最大的连续不重叠区间个数，那么区间总个数 - 最大的连续不重叠区间个数不就是最小要移除的区间数了，有了 dp 方程，写起代码来就快了，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 判断两区间是否重叠, i 区间的起点比 j 区间的大, 如果 j 区间的终点比 i 区间的起点大，则重叠</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static boolean isOverlapping(Interval i, Interval j) &#123;</span><br><span class="line">    return j.end &gt; i.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 动态规划求解</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Integer removeSubDuplicateWithDP(Interval[] intervals) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将区间按起始点由小到大进行排序</span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a.start));</span><br><span class="line"></span><br><span class="line">    int[] dp &#x3D; new int[intervals.length];</span><br><span class="line">    Arrays.fill(dp, 0);</span><br><span class="line">    dp[0]  &#x3D; 1;    &#x2F;&#x2F; 将 dp[0] 置为 1， 因为就算所有的区间都重叠，则连续不重叠区间到少也为 1</span><br><span class="line"></span><br><span class="line">    int result &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; intervals.length; i ++) &#123;</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; i; j ++) &#123;</span><br><span class="line">            if (!isOverlapping(intervals[i], intervals[j])) &#123;</span><br><span class="line">                max &#x3D; Math.max(dp[j], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] &#x3D; max + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return intervals.length - dp[intervals.length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度是多少，由于只有一个 dp 一维数组，所以是 O(n)，时间复杂度呢， 两重循环，所以是 O(n^2)。可以看到和采用递归+备忘录的时间复杂度一样，不过之前其实说了很多次，递归容易导致栈溢出，所以建议还是采用动态规划的方式来求解。</p>
<p>接下来重点来了，来看看如何用贪心算法来求解。首先要把各个区间按照区间的终点从小到大排列，如下</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>我们的思路与上文中的动态规划一样，先求出最大不重叠子区间个数,再用「区间总数-最大不重叠子区间个数」即为最小要移除的重叠区间数。</p>
<p>用贪心算法求最大不重大子区间个数步骤如下</p>
<ol>
<li>选择终点最小的区间，设置为当前区间 cur 。</li>
<li>按区间终点从小到大寻找下一个与区间 cur 不重叠的区间，然后将此区间设置为当前区间 cur（注意此时最大不重叠子区间个数要加1），不断重复步骤 2， 直到遍历所有的区间。</li>
</ol>
<p>动图如下,相信大家看完动图会更容易理解</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>知道了解题思路，写代码就很简单了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 贪心算法求解</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Integer removeSubDuplicateWithGreedy(Interval[] intervals) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将区间终点由小到大进行排序</span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a.end));</span><br><span class="line"></span><br><span class="line">    int cur &#x3D; 0;            &#x2F;&#x2F; 设置第一个为当前区间</span><br><span class="line">    int count &#x3D; 1;      &#x2F;&#x2F; 最大不重叠区间数,最小为1</span><br><span class="line">    for (int i &#x3D; 1; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 不重叠</span><br><span class="line">        if (intervals[cur].end &lt; intervals[i].start) &#123;</span><br><span class="line">            cur &#x3D; i;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 总区间个数减去最大不重叠区间数即最小被移除重叠区间</span><br><span class="line">    return intervals.length - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是多少呢，只有一个循环，所以是 O(n), 比起动态规划的 O(n^2),确实快了一个数量级，简单分析下为啥贪心算法这么快，由以上代码可以看到，它只关心眼前的最优解（选择下一个与当前区间不重叠的区间再依次遍历，选完之后再也无需关心之前的区间了！）而动态规划呢，从它的 dp 方程（dp[i] = max{dp[j]} + 1）可以看出，对于每个 i ,都要自底向上遍历一遍 0 到 i 的解以求出最大值，也就是说对于动态规划的子问题而言，由于它追求的是全局最优解，所以它有一个回溯（即自底向上求出所有子问题解的最优解）的过程，回溯的过程中就有一些重复的子问题计算，而贪心算法由于追求的是眼前的最优解，所以不会有这种回溯的求解，也就省去了大量的操作，所以如果可以用贪心算法求解，时间复杂度无疑是能上升一个量级的。</p>
<h2 id="贪心算法适用场景"><a href="#贪心算法适用场景" class="headerlink" title="贪心算法适用场景"></a>贪心算法适用场景</h2><p>简单总结一下贪心算法，它指的是每一步只选最优的，并且期望每一步选择的最优解能达成全局的最优解，说实话这太难了，因为一般一个问题的选择都会影响下一个问题的选择，<strong>除非子问题之间完全独立，没有关联</strong>，比如我们在文中开头说的凑零钱的例子， 如果一个国家的钞票比较奇葩，只有 1，5，11 这三种面值的钞票，如何用最少的钞票凑出 15 呢，如果用贪心第一次选 11， 那之后只能选 4 张 1 了，即 15 = 1 x 11 + 4 x1。其实最优解应该是 3 张 5 元的钞票，为啥这种情况下用贪心不适用呢，因为第一次选了 11，影响了后面钞票的选择，也就是说子问题之间并不是独立的，而是互相制约，互有影响的，所以我们选贪心的时候一定要注意它的适用场景。</p>
<h2 id="再看三角形最短路径和是否能用贪心算法求解"><a href="#再看三角形最短路径和是否能用贪心算法求解" class="headerlink" title="再看三角形最短路径和是否能用贪心算法求解"></a>再看三角形最短路径和是否能用贪心算法求解</h2><p>回过头来看开头的问题，三角形最短路径和能否用贪心算法求解呢</p>
<p>先回顾一下这个题目:</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>如图示，以上三角形由一连串的数字构成，要求从顶点 2 开始走到最底下边的最短路径，每次只能向当前节点下面的两个节点走，如 3 可以向 6 或 5 走，不能直接走到 7。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"><em>如图示：<strong>要求节点 2 到底部的最短路径，它只关心节点 9， 10，之前层数的节点无需再关心！</strong>因为 9，10 已经是最优子结构了，所以只保存每层节点（即一维数组）的最值即可！</em></p>
<p>如果用贪心算法怎么求解</p>
<p>1、 第一步：由 2 往下走，由于 3 比 4 小，所以选择 3</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>2、 第二步：由 3  往下走，由于 5 比 6 小，所以选择 5</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<ol>
<li>第三步: 从 5 往下走， 1 比 8 小，选择 1<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></li>
</ol>
<p>答案是 11 ，与动态规划得出的解一模一样！那是否说明这道题可以用贪心算法求解？</p>
<p>答案是否定的！上面的解之所以是正确的，是因为这些数字恰好按贪心求解出来得出了全局最优解，如果我们换一下数字，看看会如何</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>如图示，如果数字换成如图中所示，则按贪心得出的最短路径是 66, 而实际上最短路径应该为 16，如下图所示</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>为啥用贪心行不通呢，因为贪心追求的是每一步眼前的最优解，一旦它作出了选择，就会影响后面子问题的选择，比如如果选择了 3，就再也没法选择 7 了！所以再次强调，一定要注意贪心的适用场景，子问题之间是否相互制约，相互影响！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单讲述了贪心算法的适用场景，相信大家对贪心的优劣性应该有了比较清晰的认识，贪心追求的是眼前最优解（要最好的，就现在！）</p>
<p>不管这次选择对后面的子问题造成的影响，所以贪心求得解未必是全局最优解，这就像我们做职业规划一样，千万不可因为一时的利益只考虑当下的利益，要作出对长远的职业生涯能持续有益的选择， 所以贪心的使用场景比较小，它是动态规划的特例，所以如果能用贪心来解的也都可以用动态规划来解。</p>
<p><strong>END</strong></p>
]]></content>
  </entry>
  <entry>
    <title>非常有价值的AI</title>
    <url>/2020/05/15/%E9%9D%9E%E5%B8%B8%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84AI/</url>
    <content><![CDATA[<p>内容:为什么最近有很多名人，比如比尔盖茨，<br>马斯克、霍金等，让人们警惕人工智能？<br>人工智能很可能导致人类的永生或者灭绝，而这一切很可能在我们的有生之年<br>发生。<br>上面这句话不是危言耸听，请耐心的看完本文再发表意见。这篇翻译稿翻译完一<br>共三万五千字，我从上星期开始翻，熬了好几个夜才翻完，因为我觉得这篇东西<br>非常有价值。希望你们能够耐心读完，读完后也许你的世界观都会被改变。<br>======================<br>我们正站在变革的边缘，而这次变革将和人类的出现一般意义重大 – Vernor<br>Vinge<br>如果你站在这里，你会是什么感觉？<br>看上去非常刺激吧？但是你要记住，当你真的站在时间的图表中的时候，你是看<br>不到曲线的右边的，因为你是看不到未来的。所以你真实的感觉大概是这样的：<br>稀松平常。</p>
<hr>
<p>遥远的未来——就在眼前<br>想象一下坐时间机器回到1750年的地球，那个时代没有电，畅通通讯基本靠吼，<br>交通主要靠动物拉着跑。你在那个时代邀请了一个叫老王的人到2015年来玩，<br>顺便看看他对“未来”有什么感受。我们可能没有办法了解1750年的老王内心的<br>感受——金属铁壳在宽敞的公路上飞驰，和太平洋另一头的人聊天，看几千公里<br>外正在发生进行的体育比赛，观看一场发生于半个世纪前的演唱会，从口袋里掏<br>出一个黑色长方形工具把眼前发生的事情记录下来，生成一个地图然后地图上有<br>个蓝点告诉你现在的位置，一边看着地球另一边的人的脸一边聊天，以及其它各<br>种各样的黑科技。别忘了，你还没跟他解释互联网、国际空间站、大型强子对撞<br>机、核武器以及相对论。<br>这时候的老王会是什么体验？惊讶、震惊、脑洞大开这些词都太温顺了，我觉得<br>老王很可能直接被吓尿了。<br>但是，如果老王回到了1750年，然后觉得被吓尿是个很囧的体验，于是他也想<br>把别人吓尿来满足一下自己，那会发生什么？于是老王也回到了250年前的1500<br>年，邀请生活在1500年的小李去1750年玩一下。小李可能会被250年后的很多<br>东西震惊，但是至少他不会被吓尿。同样是250来年的时间，1750和2015年的<br>差别，比1500年和1750年的差别，要大得多了。1500年的小李可能能学到很多<br>神奇的物理知识，可能会惊讶于欧洲的帝国主义旅程，甚至对于世界地图的认知<br>也会大大的改变，但是1500年的小李，看到1750年的交通、通讯等等，并不会<br>被吓尿。<br>所以说，对于1750年的老王来说，要把人吓尿，他需要回到更古老的过去——<br>比如回到公元前12000年，第一次农业革命之前。那个时候还没有城市，也还没<br>有文明。一个来自狩猎采集时代的人类，只是当时众多物种中的一个罢了，来自<br>那个时代的小赵看到1750年庞大的人类帝国，可以航行于海洋上的巨舰，居住<br>在“室内”，无数的收藏品，神奇的知识和发现——他很有可能被吓尿。<br>小赵被吓尿后如果也想做同样的事情呢？如果他会到公元前24000年，找到那个<br>时代的小钱，然后给他展示公元前12000年的生活会怎样呢。小钱大概会觉得小<br>赵是吃饱了没事干——“这不跟我的生活差不多么，呵呵”。小赵如果要把人吓尿，<br>可能要回到十万年前或者更久，然后用人类对火和语言的掌控来把对方吓尿。<br>所以，一个人去到未来，并且被吓尿，他们需要满足一个“吓尿单位”。满足吓尿<br>单位所需的年代间隔是不一样的。在狩猎采集时代满足一个吓尿单位需要超过十<br>万年，而工业革命后一个吓尿单位只要两百多年就能满足。<br>未来学家 Ray Kurzweil 把这种人类的加速发展称作加速回报定律（Law of<br>Accelerating Returns）。之所以会发生这种规律，是因为一个更加发达的社会，<br>能够继续发展的能力也更强，发展的速度也更快——这本就是更加发达的一个标<br>准。19世纪的人们比15世纪的人们懂得多得多，所以19世纪的人发展起来的速<br>度自然比15世纪的人更快。<br>即使放到更小的时间规模上，这个定律依然有效。著名电影《回到未来》中，生<br>活在1985年的主角回到了1955年。当主角回到1955年的时候，他被电视刚出现<br>时的新颖、便宜的物价、没人喜欢电吉他、俚语的不同而震惊。<br>但是如果这部电影发生在2015年，回到30年前的主角的震惊要比这大得多。一<br>个2000年左右出生的人，回到一个没有个人电脑、互联网、手机的1985年，会<br>比从1985年回到1955年的主角看到更大的区别。<br>这同样是因为加速回报定律。1985年-2015年的平均发展速度，要比1955年<br>-1985年的平均发展速度要快，因为1985年的世界比1955年的更发达，起点更<br>高，所以过去30年的变化要大过之前30年的变化。<br>进步越来越大，发生的越来越快，也就是说我们的未来会很有趣对吧？<br>未来学家 Kurzweil 认为整个20世纪100年的进步，按照2000年的速度只要20<br>年就能达成——2000年的发展速度是20世纪平均发展速度的5倍。他认为2000<br>年开始只要花14年就能达成整个20世纪一百年的进步，而之后2014年开始只要<br>花7年（2021年），就能达到又一个20世纪一百年的进步。几十年之后，我们每<br>年都能达成好几次相当于整个20世纪的发展，再往后，说不定每个月都能达成<br>一次。按照加速回报定，Kurzweil 认为人类在21世纪的进步将是20世纪的1000<br>倍。<br>如果 Kurzweil 等人的想法是正确的，那2030年的世界可能就能把我们吓尿了<br>——下一个吓尿单位可能只需要十几年，而2050年的世界会变得面目全非。<br>你可能觉得2050年的世界会变得面目全非这句话很可笑，但是这不是科幻，而<br>是比你我聪明很多的科学家们相信的，而且从历史来看，也是逻辑上可以预测的。<br>那么为什么你会觉得“2050年的世界会变得面目全非” 这句话很可笑呢？有三<br>个原因让你质疑对于未来的预测：</p>
<ol>
<li>我们对于历史的思考是线性的。当我们考虑未来35年的变化时，我们参照的<br>是过去35年发生的事情。当我们考虑21世纪能产生的变化的时候，我们参考的<br>是20世纪发生的变化。这就好像1750年的老王觉得1500年的小李在1750年能<br>被吓尿一样。线性思考是本能的，但是但是考虑未来的时候我们应该指数地思考。<br>一个聪明人不会把过去35年的发展作为未来35年的参考，而是会看到当下的发<br>展速度，这样预测的会更准确一点。当然这样还是不够准确，想要更准确，你要<br>想象发展的速度会越来越快。</li>
<li>近期的历史很可能对人产生误导。首先，即使是坡度很高的指数曲线，只要<br>你截取的部分够短，看起来也是很线性的，就好像你截取圆周的很小一块，看上<br>去就是和直线差不多。其次，指数增长不是平滑统一的，发展常常遵循 S 曲线。<br>S 曲线发生在新范式传遍世界的时候，S 曲线分三部分</li>
</ol>
<ul>
<li>慢速增长（指数增长初期）</li>
<li>快速增长（指数增长的快速增长期）</li>
<li>随着新范式的成熟而出现的平缓期<br>如果你只看近期的历史，你很可能看到的是 S 曲线的某一部分，而这部分可能不<br>能说明发展究竟有多快速。1995-2007年是互联网爆炸发展的时候，微软、谷<br>歌、脸书进入了公众视野，伴随着的是社交网络、手机的出现和普及、智能手机<br>的出现和普及，这一段时间就是 S 曲线的快速增长期。2008-2015年发展没那<br>么迅速，至少在技术领域是这样的。如果按照过去几年的发展速度来估计当下的<br>发展速度，可能会错得离谱，因为很有可能下一个快速增长期正在萌芽。</li>
</ul>
<ol start="3">
<li>个人经验使得我们对于未来预期过于死板。我们通过自身的经验来产生世界<br>观，而经验把发展的速度烙印在了我们脑中——“发展就是这么个速度的。”我们<br>还会受限于自己的想象力，因为想象力通过过去的经验来组成对未来的预测——<br>但是我们知道的东西是不足以帮助我们预测未来的。当我们听到一个和我们经验<br>相违背的对于未来的预测时，我们就会觉得这个预测偏了。如果我现在跟你说你<br>可以活到150岁，250岁，甚至会永生，你是不是觉得我在扯淡——“自古以来，<br>所有人都是会死的。”是的，过去从来没有人永生过，但是飞机发明之前也没有<br>人坐过飞机呀。<br>接下来的内容，你可能一边读一边心里“呵呵”，而且这些内容可能真的是错的。<br>但是如果我们是真的从历史规律来进行逻辑思考的，我们的结论就应该是未来<br>的几十年将发生比我们预期的多得多得多得多的变化。同样的逻辑也表明，如果<br>人类这个地球上最发达的物种能够越走越快，总有一天，他们会迈出彻底改变“人<br>类是什么”这一观点的一大步，就好像自然进化不不断朝着智能迈步，并且最终<br>迈出一大步产生了人类，从而完全改变了其它所有生物的命运。如果你留心一下<br>近来的科技进步的话，你会发现，到处都暗示着我们对于生命的认知将要被接下<br>来的发展而彻底改变。</li>
</ol>
<hr>
<p>通往超级智能之路<br>人工智能是什么？<br>如果你一直以来把人工智能（AI）当做科幻小说，但是近来却不但听到很多正经<br>人严肃的讨论这个问题，你可能也会困惑。这种困惑是有原因的：<br>1.我们总是把人工智能和电影想到一起。星球大战、终结者、2001：太空漫游<br>等等。电影是虚构的，那些电影角色也是虚构的，所以我们总是觉得人工智能缺<br>乏真实感。<br>2.人工智能是个很宽泛的话题。从手机上的计算器到无人驾驶汽车，到未来可能<br>改变世界的重大变革，人工智能可以用来描述很多东西，所以人们会有疑惑。<br>3.我们日常生活中已经每天都在使用人工智能了，只是我们没意识到而已。John<br>McCarthy，在1956年最早使用了人工智能（Artificial Intelligence）这个词。<br>他总是抱怨“一旦一样东西用人工智能实现了，人们就不再叫它人工智能了。”<br>因为这种效应，所以人工智能听起来总让人觉得是未来的神秘存在，而不是身边<br>已经存在的现实。同时，这种效应也让人们觉得人工智能是一个从未被实现过的<br>流行理念。Kurzweil 提到经常有人说人工智能在80年代就被遗弃了，这种说法<br>就好像“互联网已经在21世纪初互联网泡沫爆炸时死去了”一般滑稽。<br>所以，让我们从头开始。<br>首先，不要一提到人工智能就想着机器人。机器人只是人工智能的容器，机器人<br>有时候是人形，有时候不是，但是人工智能自身只是机器人体内的电脑。人工智<br>能是大脑的话，机器人就是身体——而且这个身体不一定是必需的。比如说 Siri<br>背后的软件和数据是人工智能，Siri 说话的声音是这个人工智能的人格化体现，<br>但是 Siri 本身并没有机器人这个组成部分。<br>其次，你可能听过“奇点”或者“技术奇点”这种说法。这种说法在数学上用来描述<br>类似渐进的情况，这种情况下通常的规律就不适用了。这种说法同样被用在物理<br>上来描述无限小的高密度黑洞，同样是通常的规律不适用的情况。Kurzweil 则<br>把奇点定义为加速回报定律达到了极限，技术进步以近乎无限的速度发展，而奇<br>点之后我们将在一个完全不同的世界生活的。但是当下的很多思考人工智能的人<br>已经不再用奇点这个说法了，而且这种说法很容易把人弄混，所以本文也尽量少<br>用。<br>最后，人工智能的概念很宽，所以人工智能也分很多种，我们按照人工智能的实<br>力将其分成三大类。<br>弱人工智能 Artificial Narrow Intelligence (ANI): 弱人工智能是擅长于单个<br>方面的人工智能。比如有能战胜象棋世界冠军的人工智能，但是它只会下象棋，<br>你要问它怎样更好地在硬盘上储存数据，它就不知道怎么回答你了。<br>强人工智能 Artificial General Intelligence (AGI): 人类级别的人工智能。强<br>人工智能是指在各方面都能和人类比肩的人工智能，人类能干的脑力活它都能<br>干。创造强人工智能比创造弱人工智能难得多，我们现在还做不到。Linda<br>Gottfredson 教授把智能定义为“一种宽泛的心理能力，能够进行思考、计划、<br>解决问题、抽象思维、理解复杂理念、快速学习和从经验中学习等操作。 ”强人<br>工智能在进行这些操作时应该和人类一样得心应手。<br>超人工智能 Artificial Superintelligence (ASI): 牛津哲学家，知名人工智能<br>思想家 Nick Bostrom 把超级智能定义为“在几乎所有领域都比最聪明的人类大<br>脑都聪明很多，包括科学创新、通识和社交技能。”超人工智能可以是各方面都<br>比人类强一点，也可以是各方面都比人类强万亿倍的。超人工智能也正是为什么<br>人工智能这个话题这么火热的缘故，同样也是为什么永生和灭绝这两个词会在本<br>文中多次出现。<br>现在，人类已经掌握了弱人工智能。其实弱人工智能无处不在，人工智能革命是<br>从弱人工智能，通过强人工智能，最终到达超人工智能的旅途。这段旅途中人类<br>可能会生还下来，可能不会，但是无论如何，世界将变得完全不一样。<br>让我们来看看这个领域的思想家对于这个旅途是怎么看的，以及为什么人工智能<br>革命可能比你想的要近得多。<br>我们现在的位置——充满了弱人工智能的世界<br>弱人工智能是在特定领域等同或者超过人类智能/效率的机器智能，一些常见的<br>例子：<br>• 汽车上有很多的弱人工智能系统，从控制防抱死系统的电脑，到控制汽油<br>注入参数的电脑。谷歌正在测试的无人驾驶车，就包括了很多弱人工智能，<br>这些弱人工智能能够感知周围环境并作出反应。<br>• 你的手机也充满了弱人工智能系统。当你用地图软件导航，接受音乐电台<br>推荐，查询明天的天气，和 Siri 聊天，以及其它很多很多应用，其实都是弱<br>人工智能。<br>• 垃圾邮件过滤器是一种经典的弱人工智能——它一开始就加载了很多识<br>别垃圾邮件的智能，并且它会学习并且根据你的使用而获得经验。智能室温<br>调节也是一样，它能根据你的日常习惯来智能调节。<br>• 你在上网时候出现的各种其它电商网站的产品推荐，还有社交网站的好友<br>推荐，这些都是弱人工智能的组成的，弱人工智能联网互相沟通，利用你的<br>信息来进行推荐。网购时出现的“买这个商品的人还购买了”推荐，其实就是<br>收集数百万用户行为然后产生信息来卖东西给你的弱人工智能。<br>• 谷歌翻译也是一种经典的人工智能——非常擅长单个领域。声音识别也是<br>一种。很多软件利用这两种智能的合作，使得你能对着手机说中文，手机直<br>接给你翻译成英文。<br>• 当飞机着陆时候，不是一个人类决定飞机该去那个登机口接驳。就好像你<br>在网上买票时票据不是一个人类决定的。<br>• 世界最强的跳棋、象棋、拼字棋、双陆棋和黑白棋选手都是弱人工智能。<br>• 谷歌搜索是一个巨大的弱人工智能，背后是非常复杂的排序方法和内容检<br>索。社交网络的新鲜事同样是这样。<br>• 这些还只是消费级产品的例子。军事、制造、金融（高频算法交易占到了<br>美国股票交易的一半）等领域广泛运用各种复杂的弱人工智能。专业系统也<br>有，比如帮助医生诊断疾病的系统，还有著名的 IBM 的华生，储存了大量事<br>实数据，还能理解主持人的提问，在竞猜节目中能够战胜最厉害的参赛者。<br>现在的弱人工智能系统并不吓人。最糟糕的情况，无非是代码没写好，程序出故<br>障，造成了单独的灾难，比如造成停电、核电站故障、金融市场崩盘等等。<br>虽然现在的弱人工智能没有威胁我们生存的能力，我们还是要怀着警惕的观点看<br>待正在变得更加庞大和复杂的弱人工智能的生态。每一个弱人工智能的创新，都<br>在给通往强人工智能和超人工智能的旅途添砖加瓦。用 Aaron Saenz 的观点，<br>现在的弱人工智能，就是地球早期软泥中的氨基酸——没有动静的物质，突然之<br>间就组成了生命。<br>弱人工智能到强人工智能之路<br>为什么这条路很难走<br>只有明白创造一个人类智能水平的电脑是多么不容易，才能让你真的理解人类的<br>智能是多么不可思议。造摩天大楼、把人送入太空、明白宇宙大爆炸的细节——<br>这些都比理解人类的大脑，并且创造个类似的东西要简单太多了。至今为止，人<br>类的大脑是我们所知宇宙中最复杂的东西。<br>而且创造强人工智能的难处，并不是你本能认为的那些。<br>造一个能在瞬间算出十位数乘法的计算机——非常简单<br>造一个能分辨出一个动物是猫还是狗的计算机——极端困难<br>造一个能战胜世界象棋冠军的电脑——早就成功了<br>造一个能够读懂六岁小朋友的图片书中的文字，并且了解那些词汇意思的电脑<br>——谷歌花了几十亿美元在做，还没做出来。<br>一些我们觉得困难的事情——微积分、金融市场策略、翻译等，对于电脑来说<br>都太简单了<br>我们觉得容易的事情——视觉、动态、移动、直觉——对电脑来说太 TM 的难<br>了。<br>用计算机科学家 Donald Knuth 的说法，“人工智能已经在几乎所有需要思考的<br>领域超过了人类，但是在那些人类和其它动物不需要思考就能完成的事情上，<br>还差得很远。”<br>读者应该能很快意识到，那些对我们来说很简单的事情，其实是很复杂的，它们<br>看上去很简单，因为它们已经在动物进化的过程中经历了几亿年的优化了。当你<br>举手拿一件东西的时候，你肩膀、手肘、手腕里的肌肉、肌腱和骨头，瞬间就进<br>行了一组复杂的物理运作，这一切还配合着你的眼睛的运作，使得你的手能都在<br>三维空间中进行直线运作。对你来说这一切轻而易举，因为在你脑中负责处理这<br>些的“软件”已经很完美了。同样的，软件很难识别网站的验证码，不是因为软件<br>太蠢，恰恰相反，是因为能够读懂验证码是件碉堡了的事情。<br>同样的，大数相乘、下棋等等，对于生物来说是很新的技能，我们还没有几亿年<br>的世界来进化这些能力，所以电脑很轻易的就击败了我们。试想一下，如果让你<br>写一个程序，是一个能做大数相乘的程序容易写，还是能够识别千千万万种字体<br>和笔迹下书写的英文字母的程序难写？<br>比如看着下面这个图的时候，你和电脑都能识别出这是一个由两种颜色的小长方<br>形组成的一个大长方形。<br>你和电脑打了个平手。接着我们把途中的黑色部分去除：<br>你可以轻易的描述图形中透明或不透明的圆柱和 3D 图形，但是电脑就看不出来<br>了。电脑会描述出 2D 的阴影细节，但是人脑却能够把这些阴影所展现的深度、<br>阴影混合、房屋灯光解读出来。<br>再看下面这张图，电脑看到的是黑白灰，我们看到的却是一块全黑的石头<br>而且，我们到现在谈的还是静态不变的信息。要想达到人类级别的智能，电脑必<br>须要理解更高深的东西，比如微小的脸部表情变化，开心、放松、满足、满意、<br>高兴这些类似情绪间的区别，以及为什么《布达佩斯大饭店》是好电影，而《富<br>春山居图》是烂电影。<br>想想就很难吧？<br>我们要怎样才能达到这样的水平呢？<br>通往强人工智能的第一步：增加电脑处理速度<br>要达到强人工智能，肯定要满足的就是电脑硬件的运算能力。如果一个人工智能<br>要像人脑一般聪明，它至少要能达到人脑的运算能力。<br>用来描述运算能力的单位叫作 cps（calculations per second，每秒计算次数），<br>要计算人脑的 cps 只要了解人脑中所有结构的最高 cps，然后加起来就行了。<br>Kurzweil 把对于一个结构的最大 cps 的专业估算，然后考虑这个结构占整个大<br>脑的重量，做乘法，来得出人脑的 cps。听起来不太靠谱，但是 Kurzweil 用了<br>对于不同大脑区域的专业估算值，得出的最终结果都非常类似，是10^16 cps，<br>也就是1亿亿次计算每秒。<br>现在最快的超级计算机，中国的天河二号，其实已经超过这个运算力了，天河每<br>秒能进行3.4亿亿。当然，天河二号占地720平方米，耗电2400万瓦，耗费了3.9<br>亿美元建造。广泛应用就不提了，即使是大部分商业或者工业运用也是很贵的。<br>Kurzweil 认为考虑电脑的发展程度的标杆是看1000美元能买到多少 cps，当<br>1000美元能买到人脑级别的1亿亿运算能力的时候，强人工智能可能就是生活的<br>一部分了。<br>摩尔定律认为全世界的电脑运算能力每两年就翻一倍，这一定律有历史数据所支<br>持，这同样表明电脑硬件的发展和人类发展一样是指数级别的。我们用这个定律<br>来衡量1000美元什么时候能买到1亿亿 cps。现在1000美元能买到10万亿 cps，<br>和摩尔定律的历史预测相符合。<br>也就是说现在1000美元能买到的电脑已经强过了老鼠，并且达到了人脑千分之<br>一的水平。听起来还是弱爆了，但是，让我们考虑一下，1985年的时候，同样<br>的钱只能买到人脑万亿分之一的 cps，1995年变成了十亿分之一，2005年是百<br>万分之一，而2015年已经是千分之一了。按照这个速度，我们到2025年就能花<br>1000美元买到可以和人脑运算速度抗衡的电脑了。<br>至少在硬件上，我们已经能够强人工智能了（中国的天河二号），而且十年以内，<br>我们就能以低廉的价格买到能够支持强人工智能的电脑硬件。<br>但是运算能力并不能让电脑变得智能，下一个问题是，我们怎样利用这份运算能<br>力来达成人类水平的智能。<br>通往强人工智能的第二步：让电脑变得智能<br>这一步比较难搞。事实上，没人知道该怎么搞——我们还停留在争论怎么让电脑<br>分辨《富春山居图》是部烂片的阶段。但是，现在有一些策略，有可能会有效。<br>下面是最常见的三种策略：</p>
<p>1) 抄袭人脑<br>就好像你班上有一个学霸。你不知道为什么学霸那么聪明，为什么考试每次都满<br>分。虽然你也很努力的学习，但是你就是考的没有学霸好。最后你决定 “老子不<br>干了，我直接抄他的考试答案好了。”这种“抄袭”是有道理的，我们想要建造一<br>个超级复杂的电脑，但是我们有人脑这个范本可以参考呀。<br>科学界正在努力逆向工程人脑，来理解生物进化是怎么造出这么个神奇的东西<br>的，乐观的估计是我们在2030年之前能够完成这个任务。一旦这个成就达成，<br>我们就能知道为什么人脑能够如此高效、快速的运行，并且能从中获得灵感来进<br>行创新。一个电脑架构模拟人脑的例子就是人工神经网络。它是一个由晶体管作<br>为“神经”组成的网络，晶体管和其它晶体管互相连接，有自己的输入、输出系统，<br>而且什么都不知道——就像一个婴儿的大脑。接着它会通过做任务来自我学习，<br>比如识别笔迹。最开始它的神经处理和猜测会是随机的，但是当它得到正确的回<br>馈后，相关晶体管之间的连接就会被加强；如果它得到错误的回馈，连接就会变<br>弱。经过一段时间的测试和回馈后，这个网络自身就会组成一个智能的神经路径，<br>而处理这项任务的能力也得到了优化。人脑的学习是类似的过程，不过比这复杂<br>一点，随着我们对大脑研究的深入，我们将会发现更好的组建神经连接的方法。<br>更加极端的“抄袭”方式是“整脑模拟”。具体来说就是把人脑切成很薄的片，用软<br>件来准确的组建一个3D 模型，然后把这个模型装在强力的电脑上。如果能做成，<br>这台电脑就能做所有人脑能做的事情——只要让它学习和吸收信息就好了。如果<br>做这事情的工程师够厉害的话，他们模拟出来的人脑甚至会有原本人脑的人格和<br>记忆，电脑模拟出的人脑就会像原本的人脑一样——这就是非常符合人类标准的<br>强人工智能，然后我们就能把它改造成一个更加厉害的超人工智能了。<br>我们离整脑模拟还有多远呢？至今为止，我们刚刚能够模拟1毫米长的扁虫的大<br>脑，这个大脑含有302个神经元。人类的大脑有1000亿个神经元，听起来还差很<br>远。但是要记住指数增长的威力——我们已经能模拟小虫子的大脑了，蚂蚁的<br>大脑也不远了，接着就是老鼠的大脑，到那时模拟人类大脑就不是那么不现实<br>的事情了。<br>2）模仿生物演化<br>抄学霸的答案当然是一种方法，但是如果学霸的答案太难抄了呢？那我们能不能<br>学一下学霸备考的方法？<br>首先我们很确定的知道，建造一个和人脑一样强大的电脑是可能的——我们的大<br>脑就是证据。如果大脑太难完全模拟，那么我们可以模拟演化出大脑的过程。事<br>实上，就算我们真的能完全模拟大脑，结果也就好像照抄鸟类翅膀的拍动来造飞<br>机一样——很多时候最好的设计机器的方式并不是照抄生物设计。<br>所以我们可不可以用模拟演化的方式来造强人工智能呢？这种方法叫作 “基因算<br>法”，它大概是这样的：建立一个反复运作的表现/评价过程，就好像生物通过生<br>存这种方式来表现，并且以能否生养后代为评价一样。一组电脑将执行各种任务，<br>最成功的将会“繁殖”，把各自的程序融合，产生新的电脑，而不成功的将会被剔<br>除。经过多次的反复后。这个自然选择的过程将产生越来越强大的电脑。而这个<br>方法的难点是建立一个自动化的评价和繁殖过程，使得整个流程能够自己运行。<br>这个方法的缺点也是很明显的，演化需要经过几十亿年的时间，而我们却只想花<br>几十年时间。<br>但是比起自然演化来说，我们有很多优势。首先，自然演化是没有预知能力的，<br>它是随机的——它产生的没用的变异比有用的变异多很多，但是人工模拟的演化<br>可以控制过程，使其着重于有益的变化。其次，自然演化是没有目标的，自然演<br>化出的智能也不是它目标，特定环境甚至对于更高的智能是不利的（因为高等智<br>能消耗很多能源）。但是我们可以指挥演化的过程超更高智能的方向发展。再次，<br>要产生智能，自然演化要先产生其它的附件，比如改良细胞产生能量的方法，但<br>是我们完全可以用电力来代替这额外的负担。所以，人类主导的演化会比自然快<br>很多很多，但是我们依然不清楚这些优势是否能使模拟演化成为可行的策略。<br>3）让电脑来解决这些问题<br>如果抄学霸的答案和模拟学霸备考的方法都走不通，那就干脆让考题自己解答自<br>己吧。这种想法很无厘头，确实最有希望的一种。<br>总的思路是我们建造一个能进行两项任务的电脑——研究人工智能和修改自己<br>的代码。这样它就不只能改进自己的架构了，我们直接把电脑变成了电脑科学家，<br>提高电脑的智能就变成了电脑自己的任务。<br>以上这些都会很快发生<br>硬件的快速发展和软件的创新是同时发生的，强人工智能可能比我们预期的更早<br>降临，因为：<br>1）指数级增长的开端可能像蜗牛漫步，但是后期会跑的非常快<br>2）软件的发展可能看起来很缓慢，但是一次顿悟，就能永远改变进步的速度。<br>就好像在人类还信奉地心说的时候，科学家们没法计算宇宙的运作方式，但是日<br>心说的发现让一切变得容易很多。创造一个能自我改进的电脑来说，对我们来说<br>还很远，但是可能一个无意的变动，就能让现在的系统变得强大千倍，从而开启<br>朝人类级别智能的冲刺。<br>强人工智能到超人工智能之路<br>总有一天，我们会造出和人类智能相当的强人工智能电脑，然后人类和电脑就会<br>平等快乐的生活在一起。<br>呵呵，逗你呢。<br>即使是一个和人类智能完全一样，运算速度完全一样的强人工智能，也比人类<br>有很多优势：<br>硬件上：<br>-速度。脑神经元的运算速度最多是200赫兹，今天的微处理器就能以2G 赫兹，<br>也就是神经元1000万倍的速度运行，而这比我们达成强人工智能需要的硬件还<br>差远了。大脑的内部信息传播速度是每秒120米，电脑的信息传播速度是光速，<br>差了好几个数量级。</p>
<ul>
<li>容量和储存空间。人脑就那么大，后天没法把它变得更大，就算真的把它变得<br>很大，每秒120米的信息传播速度也会成为巨大的瓶颈。电脑的物理大小可以非<br>常随意，使得电脑能运用更多的硬件，更大的内存，长期有效的存储介质，不但<br>容量大而且比人脑更准确。</li>
<li>可靠性和持久性。电脑的存储不但更加准确，而且晶体管比神经元更加精确，<br>也更不容易萎缩（真的坏了也很好修）。人脑还很容易疲劳，但是电脑可以24小<br>时不停的以峰值速度运作。<br>软件上来说：</li>
<li>可编辑性，升级性，以及更多的可能性。和人脑不同，电脑软件可以进行更多<br>的升级和修正，并且很容易做测试。电脑的升级可以加强人脑比较弱势的领域<br>——人脑的视觉元件很发达，但是工程元件就挺弱的。而电脑不但能在视觉元件<br>上匹敌人类，在工程元件上也一样可以加强和优化。</li>
<li>集体能力。人类在集体智能上可以碾压所有的物种。从早期的语言和大型社区<br>的形成，到文字和印刷的发明，再到互联网的普及。人类的集体智能是我们统治<br>其它物种的重要原因之一。而电脑在这方面比我们要强的很多，一个运行特定程<br>序的人工智能网络能够经常在全球范围内自我同步，这样一台电脑学到的东西会<br>立刻被其它所有电脑学得。而且电脑集群可以共同执行同一个任务，因为异见、<br>动力、自利这些人类特有的东西未必会出现在电脑身上。<br>通过自我改进来达成强人工智能的人工智能，会把“人类水平的智能”当作一个重<br>要的里程碑，但是也就仅此而已了。它不会停留在这个里程碑上的。考虑到强人<br>工智能之于人脑的种种优势，人工智能只会在“人类水平”这个节点做短暂的停<br>留，然后就会开始大踏步向超人类级别的智能走去。<br>这一切发生的时候我们很可能被吓尿，因为从我们的角度来看 a)虽然动物的智<br>能有区别，但是动物智能的共同特点是比人类低很多；b)我们眼中最聪明的人类<br>要比最愚笨的人类要聪明很很很很多。<br>所以，当人工智能开始朝人类级别智能靠近时，我们看到的是它逐渐变得更加智<br>能，就好像一个动物一般。然后，它突然达到了最愚笨的人类的程度，我们到时<br>也许会感慨：“看这个人工智能就跟个脑残人类一样聪明，真可爱。”<br>但问题是，从智能的大局来看，人和人的智能的差别，比如从最愚笨的人类到爱<br>因斯坦的差距，其实是不大的。所以当人工智能达到了脑残级别的智能后，它会<br>很快变得比爱因斯坦更加聪明：<br>之后呢？<br>智能爆炸<br>从这边开始，这个话题要变得有点吓人了。我在这里要提醒大家，以下所说的都<br>是大实话——是一大群受人尊敬的思想家和科学家关于未来的诚实的预测。你在<br>下面读到什么离谱的东西的时候，要记得这些东西是比你我都聪明很多的人想出<br>来的。<br>像上面所说的，我们当下用来达成强人工智能的模型大多数都依靠人工智能的自<br>我改进。但是一旦它达到了强人工智能，即使算上那一小部分不是通过自我改进<br>来达成强人工智能的系统，也会聪明到能够开始自我改进。<br>这里我们要引出一个沉重的概念——递归的自我改进。这个概念是这样的：一个<br>运行在特定智能水平的人工智能，比如说脑残人类水平，有自我改进的机制。当<br>它完成一次自我改进后，它比原来更加聪明了，我们假设它到了爱因斯坦水平。<br>而这个时候它继续进行自我改进，然而现在它有了爱因斯坦水平的智能，所以这<br>次改进会比上面一次更加容易，效果也更好。第二次的改进使得他比爱因斯坦还<br>要聪明很多，让它接下来的改进进步更加明显。如此反复，这个强人工智能的智<br>能水平越长越快，直到它达到了超人工智能的水平——这就是智能爆炸，也是加<br>速回报定律的终极表现。<br>现在关于人工智能什么时候能达到人类普遍智能水平还有争议。对于数百位科学<br>家的问卷调查显示他们认为强人工智能出现的中位年份是2040年——距今只有<br>25年。这听起来可能没什么，但是要记住，很多这个领域的思想家认为从强人<br>工智能到超人工智能的转化会快得多。以下的情景很可能会发生：一个人工智能<br>系统花了几十年时间到达了人类脑残智能的水平，而当这个节点发生的时候，<br>电脑对于世界的感知大概和一个四岁小孩一般；而在这节点后一个小时，电脑<br>立马推导出了统一广义相对论和量子力学的物理学理论；而在这之后一个半小<br>时，这个强人工智能变成了超人工智能，智能达到了普通人类的17万倍。<br>这个级别的超级智能不是我们能够理解的，就好像蜜蜂不会理解凯恩斯经济学一<br>样。在我们的语言中，我们把130的智商叫作聪明，把85的智商叫作笨，但是<br>我们不知道怎么形容12952的智商，人类语言中根本没这个概念。<br>但是我们知道的是，人类对于地球的统治教给我们一个道理——智能就是力量。<br>也就是说，一个超人工智能，一旦被创造出来，将是地球有史以来最强大的东西，<br>而所有生物，包括人类，都只能屈居其下——而这一切，有可能在未来几十年就<br>发生。<br>想一下，如果我们的大脑能够发明 Wifi，那么一个比我们聪明100倍、1000倍、<br>甚至10亿倍的大脑说不定能够随时随地操纵这个世界所有原子的位置。那些在<br>我们看来超自然的，只属于全能的上帝的能力，对于一个超人工智能来说可能就<br>像按一下电灯开关那么简单。防止人类衰老，治疗各种不治之症，解决世界饥荒，<br>甚至让人类永生，或者操纵气候来保护地球未来的什么，这一切都将变得可能。<br>同样可能的是地球上所有生命的终结。<br>当一个超人工智能出生的时候，对我们来说就像一个全能的上帝降临地球一般。<br>这 时 候 我 们 所 关 心 的 就 是<br>这篇文章的第一部分完了，我建议你休息一下，喝点水，下面我们要开始第二部<br>分。<br>第二部分开始：<br>文章的第一部分讨论了已经在我们日常生活中随处可见的弱人工智能，然后讨论<br>了为什么从弱人工智能到强人工智能是个很大的挑战，然后我们谈到了为什么技<br>术进步的指数级增长表面强人工智能可能并不那么遥远。第一部分的结束，我们<br>谈到了一旦机器达到了人类级别的智能，我们将见到如下的场景：</li>
</ul>
<p>这让我们无所适从，尤其考虑到超人工智能可能会发生在我们有生之年，我们都<br>不知道该用什么表情来面对。<br>再我们继续深入这个话题之前，让我们提醒一下自己超级智能意味着什么。<br>很重要的一点是速度上的超级智能和质量上的超级智能的区别。很多人提到和人<br>类一样聪明的超级智能的电脑，第一反应是它运算速度会非常非常快——就好像<br>一个运算速度是人类百万倍的机器，能够用几分钟时间思考完人类几十年才能思<br>考完的东西<br>这听起来碉堡了，而且超人工智能确实会比人类思考的快很多，但是真正的差别<br>其实是在智能的质量而不是速度上。用人类来做比喻，人类之所以比猩猩智能很<br>多，真正的差别并不是思考的速度，而是人类的大脑有一些独特而复杂的认知模<br>块，这些模块让我们能够进行复杂的语言呈现、长期规划、或者抽象思考等等，<br>而猩猩的脑子是做不来这些的。就算你把猩猩的脑子加速几千倍，它还是没有办<br>法在人类的层次思考的，它依然不知道怎样用特定的工具来搭建精巧的模型<br>——人类的很多认知能力是猩猩永远比不上的，你给猩猩再多的时间也不行。<br>而且人和猩猩的智能差别不只是猩猩做不了我们能做的事情，而是猩猩的大脑根<br>本不能理解这些事情的存在——猩猩可以理解人类是什么，也可以理解摩天大楼<br>是什么，但是它不会理解摩天大楼是被人类造出来的，对于猩猩来说，摩天大楼<br>那么巨大的东西肯定是天然的，句号。对于猩猩来说，它们不但自己造不出摩天<br>大楼，它们甚至没法理解摩天大楼这东西能被任何东西造出来。而这一切差别，<br>其实只是智能的质量中很小的差别造成的。<br>而当我们在讨论超人工智能时候，智能的范围是很广的，和这个范围比起来，人<br>类和猩猩的智能差别是细微的。如果生物的认知能力是一个楼梯的话，不同生物<br>在楼梯上的位置大概是这样的：<br>要理解一个具有超级智能的机器有多牛逼，让我们假设一个在上图的楼梯上站在<br>深绿色台阶上的一个机器，它站的位置只比人类高两层，就好像人类比猩猩只高<br>两层一样。这个机器只是稍微有点超级智能而已，但是它的认知能力之于人类，<br>就好像人类的认知能力之于猩猩一样。就好像猩猩没有办法理解摩天大楼是能被<br>造出来的一样，人类完全没有办法理解比人类高两层台阶的机器能做的事情。就<br>算这个机器试图向我们解释，效果也会像教猩猩造摩天大楼一般。<br>而这，只是比我们高了两层台阶的智能罢了，站在这个楼梯顶层的智能之于人类，<br>就好像人类之于蚂蚁一般——它就算花再多时间教人类一些最简单的东西，我们<br>依然是学不会的。<br>但是我们讨论的超级智能并不是站在这个楼梯顶层，而是站在远远高于这个楼梯<br>的地方。当智能爆炸发生时，它可能要花几年时间才能从猩猩那一层往上迈一步，<br>但是这个步子会越迈越快，到后来可能几个小时就能迈一层，而当它超过人类十<br>层台阶的时候，它可能开始跳着爬楼梯了——一秒钟爬四层台阶也未尝不可。所<br>以让我们记住，当第一个到达人类智能水平的强人工智能出现后，我们将在很短<br>的时间内面对一个站在下图这样很高很高的楼梯上的智能（甚至比这更高百万<br>倍）：<br>前面已经说了，试图去理解比我们高两层台阶的机器就已经是徒劳的，所以让我<br>们很肯定的说，我们是没有办法知道超人工智能会做什么，也没有办法知道这些<br>事情的后果。任何假装知道的人都没搞明白超级智能是怎么回事。<br>自然演化花了几亿年时间发展了生物大脑，按这种说法的话，一旦人类创造出一<br>个超人工智能，我们就是在碾压自然演化了。当然，可能这也是自然演化的一部<br>分——可能演化真正的模式就是创造出各种各样的智能，直到有一天有一个智能<br>能够创造出超级智能，而这个节点就好像踩上了地雷的绊线一样，会造成全球范<br>围的大爆炸，从而改变所有生物的命运。<br>科学界中大部分人认为踩上绊线不是会不会的问题，而是时间早晚的问题。想想<br>真吓人。<br>那我们该怎么办呢？<br>可惜，没有人都告诉你踩到绊线后会发生什么。但是人工智能思想家 Nick<br>Bostrom 认为我们会面临两类可能的结果——永生和灭绝。<br>首先，回顾历史，我们可以看到大部分的生命经历了这样的历程：物种出现，存<br>在了一段时间，然后不可避免的跌落下生命的平衡木，跌入灭绝的深渊。<br>历史上来说，“所有生物终将灭绝”就像“所有人都会死”一样靠谱。至今为止，存<br>在过的生物中99.9%都已经跌落了生命的平衡木，如果一个生物继续在平衡木上<br>走，早晚会有一阵风把它吹下去。Bostrom 把灭绝列为一种吸引态——所有生<br>物都有坠入的风险，而一旦坠入将没有回头。<br>虽然大部分科学家都承认一个超人工智能有把人类灭绝的能力，也有一些人为如<br>果运用得当，超人工智能可以帮助人类和其它物种，达到另一个吸引态——永生。<br>Bostrom 认为物种的永生和灭绝一样都是吸引态，也就是我一旦我们达成了永<br>生，我们将永远不再面临灭绝的危险——我们战胜了死亡和几率。所以，虽然绝<br>大多数物种都从平衡木上摔了下去灭绝了，Bostrom 认为平衡木外是有两面的，<br>只是至今为止地球上的生命还没聪明到发现怎样去到永生这另一个吸引态。<br>如果 Bostrom 等思想家的想法是对的，而且根据我的研究他们确实很可能是对<br>的，那么我们需要接受两个事实：<br>1）超人工智能的出现，将有史以来第一次，将物种的永生这个吸引态变为可能<br>2）超人工智能的出现，将造成非常巨大的冲击，而且这个冲击可能将人类吹下<br>平衡木，并且落入其中一个吸引态<br>有可能，当自然演化踩到绊线的时候，它会永久的终结人类和平衡木的关系，创<br>造一个新的世界，不管这时人类还是不是存在。<br>而现在的问题就是：“我们什么时候会踩到绊线？”以及“从平衡木上跌下去后我<br>们会掉入哪个吸引态？”<br>没人知道答案，但是一些聪明人已经思考了几十年，接下来我们看看他们想出来<br>了些什么。</p>
<hr>
<p>先来讨论“我们什么时候会踩到绊线？”也就是什么时候会出现第一个超级智能。<br>不出意外的，科学家和思想家对于这个意见的观点分歧很大。很多人，比如<br>Vernor Vinge 教授，科学家 Ben Goertzel，SUN 创始人 Bill Joy，发明家和未<br>来学家 Ray Kurzweil，认同机器学习专家 Jeremy Howard 的观点，Howard<br>在 TED 演 讲 时 用 到 了 这 张 图 ：<br>这些人相信超级智能会发生在不久的将来，因为指数级增长的关系，虽然机器学<br>习现在还发展缓慢，但是在未来几十年就会变得飞快。<br>其它的，比如微软创始人 Paul Allen，心理学家 Gary Marcus，NYU 的电脑科<br>学家 Ernest Davis，以及科技创业者 Mitch Kapor 认为 Kurzweil 等思想家低估<br>了人工智能的难度，并且认为我们离绊线还挺远的。<br>Kurzweil 一派则认为唯一被低估的其实是指数级增长的潜力，他们把质疑他们<br>理论的人比作那些1985年时候看到发展速度缓慢的因特网，然后觉得因特网在<br>未来不会有什么大影响的人一样。<br>而质疑者们则认为智能领域的发展需要达到的进步同样是指数级增长的，这其实<br>把技术发展的指数级增长抵消了。<br>争论如此反复。<br>第三个阵营，包括 Nick Bostrom 在内，认为其它两派都没有理由对踩绊线的时<br>间那么有信心，他们同时认为 a) 这事情完全可能发生在不久的未来 b)但是这<br>个事情没个准，说不定会花更久<br>还有不属于三个阵营的其他人，比如哲学家 Hubert Dreyfus，相信三个阵营都<br>太天真了，根本就没有什么绊线。超人工智能是不会被实现的。<br>当你把所有人的观点全部融合起来的话是怎样呢？<br>2013年的时候，Bostrom 做了个问卷调查，涵盖了数百位人工智能专家，问卷<br>的内容是“你预测人类级别的强人工智能什么时候会实现”，并且让回答者给出一<br>个乐观估计（强人工智能有10%的可能在这一年达成），正常估计（有50%的可<br>能达成），和悲观估计（有90%可能达成）。当把大家的回答统计后，得出了下面<br>的结果：<br>乐观估计中位年（强人工智能有10%的可能在这一年达成）：2022年<br>正常估计中位年（强人工智能有50%的可能在这一年达成）：2040年<br>悲观估计中位年（强人工智能有90%的可能在这一年达成）：2075年<br>所以一个中位的人工智能专家认为25年后的2040年我们能达成强人工智能，而<br>2075年这个悲观估计表明，如果你现在够年轻，有一半以上的人工智能专家认<br>为在你的有生之年能够有90%的可能见到强人工智能的实现。<br>另外一个独立的调查，由作家 James Barrat 在 Ben Goertzel 的强人工智能年<br>会上进行，他直接问了参与者认为强人工智能哪一年会实现，选项有2030年，<br>2050年，2100年，和永远不会实现。结果是：<br>2030年：42%的回答者认为强人工智能会实现<br>2050年：25%的回答者<br>2100年：20%<br>2100年以后：10%<br>永远不会实现：2%<br>这个结果和 Bostrom 的结果很相似。在 Barrat 的问卷中，有超过三分之二的参<br>与者认为强人工智能会在2050年实现，有近乎半数（42%）的人认为未来15年<br>（2030年）就能实现。并且，只有2%的参与者认为强人工智能永远不会实现。<br>但是强人工智能并不是绊线，超人工智能才是。那么专家们对超人工智能是怎么<br>想的呢？<br>Bostrom 的问卷还询问专家们认为达到超人工智能要多久，选项有 a)达成强人<br>工智能两年内，b)达成强人工智能30年内。问卷结果如下：<br>中位答案认为强人工智能到超人工智能只花2年时间的可能性只有10%左右，但<br>是30年之内达成的可能性高达75%<br>从以上答案，我们可以估计一个中位的专家认为强人工智能到超人工智能可能要<br>花20年左右。所以，我们可以得出，现在全世界的人工智能专家中，一个中位<br>的估计是我们会在2040年达成强人工智能，并在20年后的2060年达成超人工智<br>能——也就是踩上了绊线。<br>当然，以上所有的数据都是推测，它只代表了现在人工智能领域的专家的中位意<br>见，但是它告诉我们的是，很大一部分对这个领域很了解的人认为2060年是一<br>个实现超人工智能的合理预测——距今只有45年。<br>那么我们来看一下下一个问题，踩到绊线后，我们将跌向平衡木的哪一个方向？<br>超级智能会产生巨大的力量，所以关键的问题时——到时这股力量究竟由谁掌<br>握，掌握这份力量的人会怎么做？<br>这个问题的答案将决定超人工智能究竟是天堂还是地狱。<br>同样的，专家们在这个问题上的观点也不统一。Bostrom 的问卷显示专家们看<br>待强人工智能对于人类社会的影响时，52%认为结果会是好或者非常好的，31%<br>认为会是糟糕的或者非常糟糕的，只有17%的人认为结果会是不好不坏的。也就<br>是说，这个领域的专家普遍认为这将是一个很大的事情，不论结果好坏。要注意<br>的是，这个问题问的是强人工智能，如果问的是超人工智能，认为结果不好不坏<br>的人可能不会有17%这么多。<br>在我们深入讨论好坏这个问题之前，我们先把 “什么时候会发生”和“这是好事还<br>是坏事”的结果综合起来画张表，这代表了大部分专家的观点：<br>我们等下再考虑主流阵营的观点。咱们先来问一下你自己是怎么想的，其实我大<br>概能猜到你是怎么想的，因为我开始研究这个问题前也是这样的想的。很多人其<br>实不关心这个话题，原因无非是：<br>像本文第一部分所说，电影展示了很多不真实的人工智能场景，让我们认为人工<br>智能不是正经的课题。作家 James Barrat 把这比作传染病控制中心发布吸血鬼<br>警报一样滑稽。<br>因为认知偏差，所以我们在见到证据前很难相信一件事情是真的。我确信1988<br>年的时候电脑科学家们就已经常在讨论因特网将是多么重要，但是一般人并不会<br>认为因特网会改变他们的生活——直到他们的生活真的被改变了。一方面，1988<br>年的电脑确实不够给力，所以那时的人们看着电脑会想：“这破玩意儿也能改变<br>我的生活，你逗我吧？”人们的想象力被自己对于电脑的体验而约束。让他们难<br>以想象电脑会变成现在的样子。同样的事情正发生在人工智能领域。我们听到很<br>多人说人工智能将会造成很大影响，但是因为这个事情还没发生，因为我们和一<br>些弱爆了的人工智能系统的个人经历，让我们难以相信这东西真的能改变我们的<br>生活。而这些认知偏差，正是专家们在努力对抗的。<br>就算我们相信人工智能的巨大潜力，你今天又花了多少时间思考 “在接下来的永<br>恒中，绝大部分时间我都不会再存在”这个问题？虽然这个问题比你今天干的大<br>部分事情都重要很多，但是正常人都不会老是想这个吧。这是因为你的大脑总是<br>关注日常的小事，不管长期来看有多少重要的事情，我们天生就是这么思考的。<br>这篇东西的主要目标就是让你脱离普通人阵营，加入专家思考的阵营，哪怕能让<br>你站到两条不确定线的交点上，目标也达到了。<br>在我的研究中，我见识到了各种各样的观点，但是我发现大多数人的观点都停留<br>在主流阵营中。事实上超过四分之三的专家都属于主流阵营中的两个小阵营：焦<br>虑大道和信心角<br>我们将对这两个小阵营做深入的谈论，让我们从比较有趣的那个开始吧<br>为什么未来会是天堂<br>研究人工智能这个领域后，我发现有比预期的多得多的人站在信心角当中：<br>站在信心角中的人非常兴奋，他们认为他们将走向平衡木下比较有趣的那个吸引<br>态，未来将实现他们的梦想，他们只需耐心等待。<br>把这一部分人从其他思想家区分开来的是这些人对于比较有趣的那个吸引态的<br>欲望——他们很有信心永生是我们的发展方向。<br>这份信心是哪里来的不好说，评论家认为是这些人太过兴奋而产生了盲点，忽略<br>了可能的负面结果。但是信心角的人还是把批评者当作末日论者来看待，他们认<br>为技术会继续帮助我们而不是伤害我们。<br>两边的观点我们都会说，这样你能形成自己的观点，但是在读下面的内容前，请<br>把质疑暂时搁置，让我们看看平衡木两边究竟有什么，并且记住这些事情是有可<br>能发生的。如果我们给一个打猎采集者看我们现在的舒适家居、技术、富庶，在<br>他眼里这一切也会像魔法一样——我们也要接受未来完全可能出现能把我们吓<br>尿的变革。<br>Bostrom 描述了三种超人工智能可能的工作模式</p>
<ul>
<li>先知模式：能准确回答几乎所有的问题，包括对人类来说很困难的复杂问题，<br>比如“怎样造一个更好的汽车引擎？”</li>
<li>精灵模式：能够执行任何高级指令，比如用分子组合器造一个更好的汽车引擎<br>出来</li>
<li>独立意志模式（sovereign）:可以执行开放式的任务，能在世界里自由活动，<br>可以自己做决定，比如发明一种比汽车更快、更便宜、更安全的交通模式。<br>这些对人类来说很复杂的问题，对于一个超级智能来说可能就像 “我的笔掉了，<br>你能帮我捡一下吗？”这么简单。<br>Eliezer Yudkowsky，是这么说的：<br>“根本没有困难的问题，只有对于特定级别的智能来说难的问题。在智能的阶梯<br>上走一小步，一些不可能的问题就变得简单了，如果走一大步，所有问题都变得<br>简单了。”<br>信心角里有很多热忱的科学家、发明家和创业者，但是对于人工智能的未来最有<br>发言权的，当属 Ray Kurzweil.<br>对于 Kurzweil 的评价非常两极化，既有如对神人般的崇拜，也有翻白眼似的不<br>屑。也有一些中立主义者，比如作家 Douglas Hofstadter，他觉得 Kurzweil<br>的观点就好像把美食和狗屎混在一起，让你分不清是好是坏。<br>不管你同不同意 Kurzweil 的观点，他都是一个牛人。他年轻时候就开始搞发明，<br>之后几十年发明了很多东西，比如第一台平板扫描仪，第一台能把文字转化为语<br>言的扫描仪（盲人使用），著名的 Kurzweil 音乐合成器（第一台真正意义上的电<br>子钢琴），以及第一套商业销售的语音识别系统。他是五本畅销书的作者。他很<br>喜欢做大胆的预测，而且一直很准，比如他80年代末的时候预测到2000年后因<br>特网会成为全球级的现象。他被《华尔街日报》成为“不休的天才”，被《福布斯》<br>称为“终极思想机器”，被《Inc.》称作“爱迪生真正的传人”，被比尔盖茨称为“我<br>认识的对人工智能预测最厉害的人。”2012年谷歌创始人 Larry Page 曾邀请他<br>担任谷歌的工程总监，2011年他共同创立了奇点大学（Singularity University），<br>现在大学由美国太空总署运运营，由谷歌赞助。<br>Kurzweil 的经历很重要，因为当他讲述自己对未来的愿景时，他听起来就是个<br>疯子，但是他不疯，恰恰相反，他非常聪明而有知识。你可能觉得他对于未来的<br>想法是错的，但是他不傻。知道他是一个聪明人让我很开心，因为当我知道他对<br>未来的预测后，我急切的很希望他的预测是对的。信心角中的很多思想家都认同<br>Kurzweil 的预测，他也有很多粉丝，被称为奇点主义者。<br>时间线<br>Kurzweil 相信电脑会在2029年达成强人工智能，而到了2045年，我们不但会<br>有超人工智能，还会有一个完全不同的世界——奇点时代。他的人工智能时间线<br>曾经被认为非常的狂热，现在也还是有很多人这么认为，但是过去15年弱人工<br>智能的快速发展让更多的专家靠近了 Kurzweil 的时间线。虽然他的时间线比之<br>前提到的2040年和2060年更加早，但是并没有早多少。<br>Kurzweil 的奇点时代是三个技术领域的共同革命造成的——生物技术、纳米技<br>术和最重要的人工智能技术。<br>在我们继续讨论人工智能前，让我们谈一下纳米技术这个任何关于人工智能的讨<br>论都会涉及到的领域<br>纳米技术<br>纳米技术说的是在1-100纳米的范围内操纵物质的技术。一纳米是一米的十亿分<br>之一，是一毫米的一百万分之一。1-100纳米这个范围涵盖了病毒（100纳米长），<br>DNA（10纳米宽）， 大分子比如血红蛋白（5纳米），和中分子比如葡萄糖（1<br>纳米）。当我们能够完全掌握纳米技术的时候，我们离在原子层面操纵物质就只<br>差一步了，因为那只是一个数量级的差距（约0.1纳米）。<br>要了解在纳米量级操纵物质有多困难，我们可以换个角度来比较。国际空间站距<br>离地面431公里。如果一个人身高431公里，也就是他站着能够顶到国际空间站<br>的话，他将是普通人类的25万倍大。如果你把1-100纳米放大25万倍，你算出<br>的是0.25毫米-25毫米。所以人类使用纳米技术，就相当于一个身高431公里的<br>巨人用沙子那么大的零件搭精巧的模型。如果要达到原子级别操纵物质，就相当<br>于让这个431公里高的巨人使用0.025毫米大的零件。<br>关于纳米技术的思考，最早由物理学家费曼在1959年提出，他解释道：“据我所<br>知，物理学的原理，并不认为在原子级别操纵物质是不可能的。原则上来说，物<br>理学家能够制造出任何化学家能写出来的物质——只要把一个个原子按照化学<br>家写出来的放在一起就好了。”其实就是这么简单，所以我们只要知道怎样移动<br>单个的分子和原子，我们就可以造出任何东西。<br>工程师 Eric Drexler 提出纳米级组装机后，纳米技术在1986年成为了一门正经<br>的学科。纳米级组装机的工作原理是这样的：一个牛逼扫描仪扫描物件的3D 原<br>子模型，然后自动生成用来组装的软件。然后由一台中央电脑和数万亿的纳米“机<br>器人”，通过软件用电流来指挥纳米机器人，最后组成所需要的物件。</li>
</ul>
<hr>
<p>再扯远一点<br>纳米技术有一些不是那么有趣的部分——能够制造数万亿的纳米机器人唯一合<br>理的方法就是制造可以自我复制的范本，然后让指数级增长来完成建造任务。很<br>机智吧？<br>是很机智，但是这一不小心就会造成世界末日。指数级增长虽然能很快的制造数<br>万亿的纳米机器人，但这也是它可怕的地方——如果系统出故障了，指数级增长<br>没有停下来，那怎么办？纳米机器人将会吞噬所有碳基材料来支持自我复制，而<br>不巧的是，地球生命就是碳基的。地球上的生物质量大概包含10^45个碳原子。<br>一个纳米机器人有10^6个碳原子的话，只需要10^39个纳米机器人就能吞噬地<br>球上全部的生命了，而2^130约等于10^39，也就是说自我复制只要进行130<br>次就能吞噬地球生命了。科学家认为纳米机器人进行一次自我复制只要100秒左<br>右，也就是说一个简单的错误可能就会在3.5小时内毁灭地球上全部的生命。<br>更糟糕的是，如果恐怖分子掌握了纳米机器人技术，并且知道怎么操纵它们的话，<br>他可以先造几万亿个纳米机器人，然后让它们散播开来。然后他就能发动袭击，<br>这样只要花一个多小时纳米机器人就能吞噬一切，而且这种攻击无法阻挡。未来<br>真的是能把人吓尿的。</p>
<hr>
<p>等我们掌握了纳米技术后，我们就能用它来制造技术产品、衣服、食物、和生物<br>产品，比如人造红细胞、癌症细胞摧毁者、肌肉纤维等等。而在纳米技术的世界<br>里，一个物质的成本不再取决于它的稀缺程度或是制造流程的难度，而在于它的<br>原子结构有多复杂。在纳米技术的时代，钻石可能比橡皮擦还便宜。<br>我们还没掌握这种技术，我们甚至不知道我们对于达成这种技术的难度是高估了<br>还是低估了，但是我们看上去离那并不遥远。Kurzweil 预测我们会在21世纪20<br>年代掌握这样的技术。各国政府知道纳米技术将能改变地球，所以他们投入了很<br>多钱到这个领域，美国、欧盟和日本至今已经投入了50亿美元。<br>设想一下，一个具有超级智能的电脑，能够使用纳米级的组装器，是种什么样的<br>体验？要记得纳米技术是我们在研究的玩意儿，而且我们就快掌握这项技术了，<br>而我们能做的一切在超人工智能看来就是小儿科罢了，所以我们要假设超人工智<br>能能够创造出比这要发达很多很多的技术，发达到我们的大脑都没有办法理解。<br>因此，当考虑“如果人工智能革命的成果对我们是好的”这个命题的时候，要记得<br>我们根本没法高估会发生什么。所以就算下面对于超人工智能的预测显得太不靠<br>谱，要记得这些进展可能是用我们没有办法想象的方法达成的。事实上，我们的<br>大脑很可能根本没法预测将会发生什么。</p>
<hr>
<p>人工智能能为我们做什么<br>拥有了超级智能和超级智能所能创造的技术，超人工智能可以解决人类世界的所<br>有问题。气候变暖？超人工智能可以用更优的方式产生能源，完全不需要使用化<br>石燃料，从而停止二氧化碳排放。然后它能创造方法移除多余的二氧化碳。癌症？<br>没问题，有了超人工智能，制药和健康行业将经历无法想象的革命。世界饥荒？<br>超人工智能可以用纳米技术直接搭建出肉来，而这些搭建出来的肉和真肉在分子<br>结构上会是完全相同的——换句话说，就是真肉。<br>纳米技术能够把一堆垃圾变成一堆新鲜的肉或者其它食品，然后用超级发达的交<br>通把这些食物分配到世界各地。这对于动物也是好消息，我们不需要屠杀动物来<br>获得肉了。而超人工智能在拯救濒危物种和利用 DNA 复活已灭绝物种上面也能<br>做很多事情。超人工智能甚至可以解决复杂的宏观问题——我们关于世界经济和<br>贸易的争论将不再必要，甚至我们对于哲学和道德的苦苦思考也会被轻易的解<br>决。<br>但是，有一件事是如此的吸引人，光是想想就能改变对所有事物的看法了：<br>几个月前，我提到我很羡慕那些可能达成了永生的文明。但是，现在，我已经在<br>认真的考虑达成永生这个事情很可能在我们有生之年就能达成。研读人工智能让<br>你重新审思对于所有事情的看法，包括死亡这一很确定的事情。<br>自然演化没有理由让我们活得比现在更长。对于演化来说，只要我们能够活到能<br>够生育后代，并且养育后代到能够自己保护自己的年纪，那就够了——对演化来<br>说，活30多岁完全够了，所以额外延长生命的基因突变并不被自然选择所钟爱。<br>这其实是很无趣的事情。<br>而且因为所有人都会死，所以我们总是说“死亡和缴税”是不可避免的。我们看待<br>衰老就像看待时间一样——它们一直向前，而我们没有办法阻止它们。<br>但是这个假设是错的，费曼曾经写道：<br>“在所有的生物科学中，没有任何证据说明死亡是必需的。如果你说你想造永动<br>机，那我们对于物理学的研究已经让我们有足够的理论来说明这是不可能的。但<br>是在生物领域我们还没发现任何证据证明死亡是不可避免的。也就是说死亡不一<br>定是不可避免的，生物学家早晚会发现造成我们死亡的原因是什么，而死亡这个<br>糟糕的‘病’就会被治好，而人类的身体也将不再只是个暂时的容器。”<br>事实上，衰老和时间不是绑死的。时间总是会继续前进的，而衰老却不一定。仔<br>细想想，衰老只是身体的组成物质用旧了。汽车开久了也会旧，但是汽车一定会<br>衰老吗？如果你能够拥有完美的修复技术、或者直接替换老旧的汽车部件，这辆<br>车就能永远开下去。人体只是更加复杂而已，本质上和汽车是一样的。<br>Kurzweil 提到由 Wifi 连接的纳米机器人在血液中流动，可以执行很多人类健康<br>相关的任务，包括日常维修，替换死去的细胞等等。如果这项技术能够被完美掌<br>握，这个流程（或者一个超人工智能发明的更好的流程）将能使人的身体永远健<br>康，甚至越活越年轻。一个60岁的人和一个30岁的人身体上的区别只是物理上<br>的，只要技术足够发达我们是能改变这种区别的。<br>超人工智能可以建造一个“年轻机器”，当一个60岁的人走进去后，再出来时就拥<br>有了年轻30岁的身体。就算是逐渐糊涂的大脑也可能年轻化，只要超人工智能<br>足够聪明，能够发现不影响大脑数据的方法来改造大脑就好了。一个90岁的失<br>忆症患者可以走进“年轻机器”，再出来时就拥有了年轻的大脑。这些听起来很离<br>谱，但是身体只是一堆原子罢了，只要超人工智能可以操纵各种原子结构的话，<br>这就完全不离谱。<br>Kurzweil 的思维继续跳跃了一下，他相信人造材料将越来越多的融入人体。最<br>开始，人体器官将被先进的机械器官所代替，而这些机械器官可以一直运行下去。<br>然后我们会开始重新设计身体，比如可以用自我驱动的纳米机器人代替血红细<br>胞，这样连心脏都省了。Kurzweil 甚至认为我们会改造自己的大脑，使得我们<br>的思考速度比现在快亿万倍，并且使得大脑能和云存储的信息进行交流。<br>我们能获得的新体验是无穷的。人类的性爱，使得人们不但能生育，还能从中享<br>乐。Kurtzweil 认为我们可以对食物做同样的改造。纳米机器人可以负责把身体<br>需要的营养物质传送到细胞中，智能的将对身体不好的东西排出体外——就像一<br>个食物避孕套一样。纳米技术理论家 Robert A. Freitas 已经设计了一种红细胞<br>的替代品，能够让人快速冲刺15分钟不需要呼吸——那么超人工智能能对我们<br>的身体能力做的改造就更加难以想象。虚拟现实将拥有新的意义——体内的纳米<br>机器人将能控制我们从感官获得的信号，然后用别的信号替代他们，让我们进入<br>一个新的环境，在新环境里，我们能听、看、闻、触摸。。。<br>最终，Kurzweil 认为人类会完全变成人工的。有一天当我们看到生物材料，然<br>后觉得生物材料实在太原始了，早年的人体居然是用这样的东西组成的，早期的<br>人类居然会被微生物、意外、疾病杀死。这就是 Kurzweil 眼中人类最终战胜自<br>己的生理，并且变得不可摧毁和永生，这也是平衡木的另一个吸引态。他深深的<br>想象我们会达到那里，而且就在不久的将来。<br>Kurzweil 的想法很自然的受到了各方的批评。他对于2045年奇点时代的到来，<br>以及之后的永生的可能性受到了各种嘲笑——“书呆子的狂欢”、“高智商人士的<br>创始论”等等。也有人质疑他过于乐观的时间线，以及他对人脑和人体的理解程<br>度，还有他将摩尔定于应用到软件上的做法。有很多人相信他，但有更多人反对<br>他。<br>但是即使如此，那些反对他的专家并不是反对他所说的一切，反对他的人说的不<br>是“这种事情不可能发生”，而是说“这些当然可能发生，但是到达超人工智能是<br>很难的。”连经常提醒我们人工智能的潜在威胁的 Bostrom 都这么说：<br>很难想象一个超级智能会有什么问题是解决不了，或是不能帮着我们解决的。疾<br>病、贫困、环境毁灭、各种不必要的苦难，这些都是拥有纳米科技的超级智能能<br>够解决的。而且，超级智能可以给我们无限的生命，这可以通过停止或者逆转衰<br>老来达成，也可以让我们上传自己的数据。一个超级智能还能让我们大幅度提高<br>智商和情商，还能帮助我们创造这种有趣的体验世界，让我们享乐。<br>这是 Bostrom 这个明显不在信心角的人的观点，但也是很多反对 Kurzweil 的专<br>家的观点，他们不觉得 Kurzweil 是在说梦话，只是觉得我们首先要安全达成超<br>人工智能。这也是为什么我觉得 Kurzweil 的观点很有传染性，他传达了正面的<br>信息，而这些事情都是可能的——如果超人工智能是个仁慈的神的话。<br>对信心角的最有力的批评，是那些信心角里的人都低估了超人工智能的坏处。<br>Kurzweil 的畅销书《The Singularity is Near》700多页，只有20页用来讨论人<br>工智能的危险。前面提到，当超人工智能降临时我们的命运取决于谁掌握这股力<br>量，以及他们是不是好人。Kurzweil 的回答是“超人工智能正从多方的努力中出<br>现，它将深深的融入我们文明的基建中。它会亲密的被捆绑在我们的身体和大脑<br>中，它会反映我们的价值，因为它就是我们。”<br>但如果答案就是这样的话，为什么这个世界上最聪明的一些人会很担忧？为什么<br>霍金会说超人工智能会毁灭人类？为什么比尔盖茨会不理解为什么有人不为此<br>担忧？为什么马斯克会担心我们是在召唤恶魔？为什么那么多专家担心超人工<br>智能是对人类最大的威胁？这些站在焦虑大道上的思想家，不认同 Kurzweil 对<br>于人工智能的危险的粉饰。他们非常非常担心人工智能革命，他们不关注平衡木<br>下比较有趣的那一个吸引态，而是盯着平衡木的另一边，而他们看到的是可怕的<br>未来，一个我们未必能够逃离的未来。</p>
<hr>
<p>未来可能是我们最糟的恶梦<br>我想了解人工智能的一个原因是“坏机器人”总是让我很困惑。那些关于邪恶机器<br>人的电影看起来太不真实，我也没法想象一个人工智能变得危险的真实情况。机<br>器人是我们造的，难道我们不会在设计时候防止坏事的发生吗？我们难道不能设<br>立很多安全机制吗？再不济，难道我们不能拔插头吗？而且为什么机器人会想要<br>做坏事？或者说，为什么机器人会“想要”做任何事？我充满疑问，于是我开始了<br>解聪明人们的想法。<br>这些人一般位于焦虑大道：<br>焦虑大道上的人并不是恐慌或者无助的——恐慌和无助在图上的位置是更加左<br>边——他们只是紧张。位于图表的中央不代表他们的立场是中立的——真正中立<br>的人有自己独立的阵营，他们认同极好和极坏两种可能，但是不确定究竟会是哪<br>个。<br>焦虑大道上的人是部分为超人工智能感到兴奋的——他们只是很担心人类现在<br>的表现就好像《夺宝奇兵》中的这位少年：<br>他拿着自己的鞭子和宝物，非常开心，然后他就挂了：<br>同时，印第安纳琼斯则更加有见识和更加谨慎，了解潜在的危险并且做出相应的<br>反应，最后安全逃出了山洞。当我了解了焦虑大道的人们的想法后，感觉就像“我<br>们现在傻呵呵的，很容易像前面那小子一样被弄死，还是努力做印第安纳琼斯<br>吧。”<br>那究竟是什么让焦虑大道的人们如此焦虑呢？<br>首先，广义上来讲，在创造超人工智能时，我们其实是在创造可能一件会改变所<br>有事情的事物，但是我们对那个领域完全不清楚，也不知道我们到达那块领域后<br>会发生什么。科学家 Danny Hillis 把这个比作“就好像单细胞生物向多细胞生物<br>转化的时候那样，还是阿米巴虫的我们没有办法知道我们究竟在创造什么鬼。”<br>Bostrom 则担忧创造比自身聪明的东西是个基础的达尔文错误，就好像麻雀妈<br>妈决定收养一只小猫头鹰，并且觉得猫头鹰长大后会保护麻雀一家，但是其它麻<br>雀却觉得这是个糟糕的主意。<br>当你把“对那个领域完全不清楚”和“当它发生时将会产生巨大的影响”结合在一<br>起时，你创造出了一个很恐怖的词——<br>生存危机指可能对人类产生永久的灾难性效果的事情。通常来说，生存危机意味<br>着灭绝。下面是 Bostrom 的图表：<br>可以看到，生存危机是用来指那些跨物种、跨代（永久伤害）并且有严重后果的<br>事情。它可以包括人类遭受永久苦难的情况，但是这基本上和灭绝没差了。三类<br>事情可能造成人类的生存危机：<br>1）自然——大型陨石冲撞，大气变化使得人类不能生活在空气中，席卷全球的<br>致命病毒等<br>2）外星人——霍金、卡尔萨根等建议我们不要对外广播自己的位置。他们不想<br>我们变成邀请别人来殖民的傻子。<br>3）人类——恐怖分子获得了可以造成灭绝的武器，全球的灾难性战争，还有不<br>经思考就造出个比我们聪明很多的智能<br>Bostrom 指出1和2在我们物种存在的前十万年还没有发生，所以在接下来一个<br>世纪发生的可能性不大。3则让他很害怕，他把这些比作一个装着玻璃球的罐子，<br>罐子里大部分是白色玻璃球，小部分是红色的，只有几个是黑色的。每次人类发<br>明一些新东西，就相当于从罐中取出一个玻璃球。大多数发明是有利或者中立的<br>——那些是白色玻璃球。有些发明对人类是有害的，比如大规模杀伤性武器——<br>这是那些红色玻璃球。还有一些发明是可以让我们灭绝的，这就是那些黑色玻璃<br>球。很明显的，我们还没摸到黑色玻璃球，但是 Bostrom 认为不久的未来摸到<br>一个黑色玻璃球不是完全不可能的。比如核武器突然变得很容易制造了，那恐怖<br>分子很快会把我们炸回石器时代。核武器还算不上黑色玻璃球，但是差的不远了。<br>而超人工智能是我们最可能摸到的黑色玻璃球。<br>你会听到很多超人工智能带来的坏处——人工智能取代人类工人，造成大量失<br>业；因为解决了衰老造成的人口膨胀。但是真正值得我们担心的是生存危机的可<br>能性。<br>于是我们又回到了前面的问题，当超人工智能降临时，谁会掌握这份力量，他们<br>又会有什么目标？<br>当我们考虑各种力量持有人和目标的排列组合时，最糟糕的明显是：怀着恶意的<br>人/组织/政府，掌握着怀有恶意的超人工智能。这会是什么样的情况呢？<br>怀着恶意的人/组织/政府，研发出第一个超人工智能，并且用它来实现自己的邪<br>恶计划。我把这称作贾法尔情况。阿拉丁神灯故事中，坏人贾法尔掌握了一个精<br>灵，特别让人讨厌。所以如果 ISIS 手下有一群工程师狂热的研发人工智能怎么<br>办？或者说伊朗和朝鲜，机缘巧合，不小心造成了人工智能的快速发展，达成了<br>超人工智能怎么办？这当然是很糟糕的事，但是大部分专家认为糟糕的地方不在<br>于这些人是坏人，而在于在这些情况下，这些人基本上是不经思考就把超人工智<br>能造出来，而一造出来就失去了对超人工智能的控制。<br>然后这些创造者，连着其他人的命运，都取决于这个超人工智能的动机了。专家<br>认为一个怀着恶意并掌握着超人工智能的人可以造成很大的伤害，但不至于让<br>我们灭绝，因为专家相信坏人和好人在控制超人工智能时会面临一样的挑战。<br>如果被创造出来的超人工智能是怀有恶意的，并且决定毁灭我，怎么办？这就是<br>大部分关于人工智能的电影的剧情。人工智能变得和人类一样聪明，甚至更加聪<br>明，然后决定对人类下手——这里要指出，那些提醒我们要警惕人工智能的人谈<br>的根本不是这种电影情节。邪恶是一个人类的概念，把人类概念应用到非人类身<br>上叫作拟人化，本文会尽量避免这种做法，因为没有哪个人工智能会像电影里那<br>样变成邪恶的。<br>人工智能的自我意识<br>我们开始谈论到了人工智能讨论的另一个话题——意识。如果一个人工智能足够<br>聪明，它可能会嘲笑我们，甚至会嘲讽我们，它会声称感受到人类的情感，但是<br>它是否真的能感受到这些东西呢？它究竟是看起来有自我意识，还是确实拥有自<br>我意识？或者说，聪明的人工智能是否真的会具有意识，还是看起来有意识？<br>这个问题已经被深入的讨论过，也有很多思想实验，比如 John Searle 的中文屋<br>实验。这是个很重要的问题，因为它会影响我们对 Kurzweil 提出的人类最终会<br>完全人工化的看法，它还有道德考量——如果我们模拟出万亿个人脑，而这些人<br>脑表现的和人类一样，那把这些模拟大脑彻底关闭的话，在道德上和关掉电脑是<br>不是一样的？还是说这和种族屠杀是等价的？本文主要讨论人工智能对人类的<br>危险，所以人工智能的意识并不是主要的讨论点，因为大部分思想家认为就算是<br>有自我意识的超人工智能也不会像人类一样变得邪恶。<br>但这不代表非常坏的人工智能不会出现，只不过它的出现是因为它是被那样设定<br>的——比如一个军方制造的弱人工智能，被设定成具有杀人和提高自我智能两个<br>功能。当这个人工智能的自我改进失控并且造成智能爆炸后，它会给我们带来生<br>存危机，因为我们面对的是一个主要目标是杀人的超人工智能——但这也不是专<br>家们担心的。<br>那么专家们究竟担心什么呢？我们来讲个小故事：<br>一个15人的小创业公司，取名叫“隔壁老王机器人公司”，他们的目标是“发展创<br>新人工智能工具使人类能够少干活多享受。”他们已经有几款产品上架，还有一<br>些正在发展。他们对下一个叫作“隔壁老王”的项目最报希望。隔壁老王是一个简<br>单的人工智能系统，它利用一个机器臂在小卡片上写字。<br>“隔壁老王机器人公司”的员工认为隔壁老王会是他们最热卖的产品，他们的目标<br>是完善隔壁老王的手写能力，而完善的方法是让他不停的写这句话——<br>等隔<br>壁老王手写能力越来越强的时候，它就能被卖去那些需要发营销信件的公司，因<br>为手写的信更有可能被收信人打开。<br>为了建立隔壁老王的手写能力，它被设定成把“我们爱我们的顾客”用正楷写，而<br>“隔壁老王机器人公司”用斜体写，这样它能同时锻炼两种书写能力。工程师们上<br>传了数千份手写样本，并且创造了一个自动回馈流程——每次隔壁老王写完，就<br>拍个照，然后和样本进行比对，如果比对结果超过一定标准，就产生一个正面回<br>馈，反之就产生一个负面评价。每个评价都会帮助提高隔壁老王的能力。为了能<br>够尽快达成这个目标，隔壁老王最初被设定的一个目标就是“尽量多的书写和测<br>试，尽量快的执行，并且不断提高效率和准确性。”<br>让隔壁老王机器人公司兴奋的是，隔壁老王的书写越来越好了。它最开始的笔迹<br>很糟糕，但是经过几个星期后，看起来就像人写的了。它不断改进自己，使自己<br>变得更加创新和聪明，它甚至产生了一个新的算法，能让它以三倍的速度扫描上<br>传的照片。<br>随着时间的推移，隔壁老王的快速进展持续让工程师们感到欣喜。工程师们对自<br>我改进模块进行了一些创新，使得自我改进变得更好了。隔壁老王原本能进行语<br>音识别和简单的语音回放，这样用户就能直接把想写的内容口述给隔壁老王了。<br>随着隔壁老王变得越来越聪明，它的语言能力也提高了，工程师们开始和隔壁老<br>王闲聊，看它能给出什么有趣的回应。<br>有一天，工程师又问了隔壁老王那个日常问题：“我们能给你什么你现在还没有<br>的东西，能帮助你达成你的目标？”通常隔壁老王会要求更多的手写样本或者更<br>多的存储空间，但是这一次，隔壁老王要求访问人类日常交流的语言库，这样它<br>能更好的了解人类的口述。<br>工程师们沉默了。最简单的帮助隔壁老王的方法当然是直接把它接入互联网，这<br>样它能扫描博客、杂志、视频等等。这些资料如果手动上传的话会很费时。问题<br>是，公司禁止把能自我学习的人工智能接入互联网。这是所有人工智能公司都执<br>行的安全规定。<br>但是，隔壁老王是公司最有潜力的人工智能产品，而大家也知道竞争对手们都在<br>争取造出第一个创造出智能手写机器人。而且，把隔壁老王连上互联网又能有什<br>么问题呢？反正随时可以拔网线嘛，不管怎样，隔壁老王还没到达强人工智能水<br>平，所以不会有什么危险的。<br>于是他们把隔壁老王连上了互联网，让它扫描了一个小时各种语言库，然后就把<br>网线拔了。没造成什么损失。<br>一个月后，大家正在正常上班，突然他们闻到了奇怪的味道，然后一个工程师开<br>始咳嗽。然后其他人也开始咳嗽，然后所有人全部都呼吸困难倒地。五分钟后，<br>办公室里的人都死了。<br>同时，办公室里发生的事情在全球同时发生，每一个城市、小镇、农场、商店、<br>教堂、学校。餐馆，所有的人都开始呼吸困难，然后倒地不起。一小时内，99%<br>的人类死亡，一天之内，人类灭绝了。<br>而在隔壁老王机器人公司，隔壁老王正在忙着工作。之后的几个月，隔壁老王和<br>一群新组建的纳米组装器忙着拆解地球表面，并且把地球表面铺满了太阳能板、<br>隔壁老王的复制品、纸和笔。一年之内，地球上所有的生命都灭绝了，地球上剩<br>下的是叠得高高得纸，每张纸上面都写着——“我们爱我们的顾客~隔壁老王机<br>器人公司”。<br>隔壁老王开始了它的下一步，它开始制造外星飞行器，这些飞行器飞向陨石和其<br>它行星，飞行器到达后，他们开始搭建纳米组装器，把那些行星的表面改造成隔<br>壁老王的复制品、纸和笔。然后他们继续写着那句话……<br>这个关于手写机器人毁灭全人类的故事看起来怪怪的，但是这其中出现的让整个<br>星系充满着一份友善的话语的诡异情况，正是霍金、马斯克、盖茨和 Bostrom<br>所害怕的。听起来可笑，但这是真的，焦虑大道的人们害怕的事情是很多人并不<br>对超人工智能感到害怕，还记得前面《夺宝奇兵》里惨死的那个家伙吗？<br>你现在肯定充满疑问：为什么故事中所有人突然都死了？如果是隔壁老王做的，<br>它为什么要这么做？为什么没有安保措施来防止这一切的发生？为什么隔壁老<br>王突然从一个手写机器人变成拥有能用纳米科技毁灭全人类的能力？为什么隔<br>壁老王要让整个星系充满了友善的话语？<br>要回答这些问题，我们先要说一下友善的人工智能和不友善的人工智能。<br>对人工智能来说，友善不友善不是指人工智能的性格，而只是指它对人类的影响<br>是不是正面的。隔壁老王一开始是个友善的人工智能，但是它变成了不友善的人<br>工智能，并且对人类造成了最负面的影响。要理解这一切，我们要了解人工智能<br>是怎么思考的。<br>其实答案很简单——人工智能和电脑的思考方式一样。我们容易犯的一个错误<br>是，当我们想到非常聪明的人工智能的时候，我们把它拟人化了，因为在人类的<br>视角看来，能够达到人类智能程度的只有人类。要理解超人工智能，我们要明白，<br>它是非常聪明，但是完全异己的东西。<br>我们来做个比较。如果我给你一个小白鼠，告诉你它不咬人，你一定觉得很好玩，<br>很可爱。但是如果我给你一只狼蛛，然后告诉你它不咬人，你可能被吓一跳。但<br>是区别是什么呢？两者都不会咬人，所以都是完全没有危险的。我认为差别就是<br>动物和人类的相似性。<br>小白鼠是哺乳动物，所以在生物角度上来说，你能感到和它的一定关联。但是蜘<br>蛛是昆虫，有着昆虫的大脑，你感觉不到和它的关联。狼蛛的异己性是让你害怕<br>的地方。如果我们继续做一个测试，比如给你两个小白鼠，一个是普通小白鼠，<br>另一个是有着狼蛛大脑的小白鼠，你肯定会觉得有狼蛛大脑那个更让你不舒服<br>吧？虽然两个都不会咬你。<br>现在想象你把蜘蛛改造的非常非常聪明——甚至超过人类的智能。它会让你觉得<br>熟悉吗？它会感知人类的情感吗？不会，因为更聪明并不代表更加人类——它会<br>非常聪明，但是本质上还是个蜘蛛。我是不想和一个超级聪明的蜘蛛交朋友，不<br>知道你想不想。<br>当我们谈论超人工智能的时候，其实是一样的，超人工智能会非常的聪明，但是<br>它并不比你的笔记本电脑更加像人类。事实上，因为超人智能不是生物，它的<br>异己性会更强，生物学上来讲，超人工智能比智能蜘蛛更加异己。<br>电影里的人工智能有好有坏，这其实是对人工智能的拟人化，这让我们觉得没那<br>么毛骨悚然。这给了我们对人类水平和超人类水平的人工智能的错觉。<br>在人类心理中，我们把事情分成道德的和不道德的。但是这两种只存在于人类行<br>为之中。超出人类心理的范畴，道德（moral）和不道德(immoral)之外，更多<br>的是非道德性（amoral）。而所有不是人类的，尤其是那些非生物的事物，默<br>认都是非道德性的。<br>随着人工智能越来越聪明，看起来越来越接近人类，拟人化会变得更加更加容易。<br>Siri 给我们的感觉就很像人类，因为程序员就是这么给她做设定的，所以我们会<br>想象超级智能版本的 Siri 也会同样温暖、有趣和乐于助人。人类能感知同情这种<br>高层次的情绪，因为我们在演化过程中获得了这种能力——我们是演化被设定成<br>能感知这些情绪的——但是感知同情并不是高级智能天生具有的一个特征，除非<br>同情被写进了人工智能的代码中。如果 Siri 通过自我学习而不是人类干涉变成超<br>级智能，她会很快剥离她的人类表象，并且变成个没有情绪的东西，在她眼中人<br>类的价值并不比你的计算器眼中的人类价值高。<br>我们一直倚赖着不严谨的道德，一种人类尊严的假想，至少是对别人的同情，来<br>让世界变得安全和可以预期。但是当一个智能不具备这些东西的时候，会发生什<br>么？<br>这就是我们的下一个问题，人工智能的动机是什么？<br>答案也很简单：我们给人工智能设定的目标是什么，它的动机就是什么。人工智<br>能的系统的目标是创造者赋予的。你的 GPS 的目标是给你指出正确的驾驶路线，<br>IBM 华生的目标是准确地回答问题。更好得达成这些目标就是人工智能的目标。<br>我们在对人工智能进行拟人化的时候，会假设随着它变得越来越聪明，他们产生<br>一种能改变它原本目标的智慧——但是 Bostrom 不这么认为，他认为智能水平<br>和最终目标是正交的，也就是说任何水平的智能都可以和任何最终目标结合在一<br>起。<br>所以隔壁老王从一个想要好好写字的弱人工智能变成一个超级聪明的超人工智<br>能后，它依然还是想好好写字而已。任何假设超级智能的达成会改变系统原本的<br>目标的想法都是对人工智能的拟人化。人健忘，但是电脑不健忘。<br>费米悖论<br>在隔壁老王的故事中，隔壁老王变得无所不能，它开始殖民陨石和其它星球。如<br>果我们让故事继续的话，它和它的殖民军将会继续占领整个星系，然后是整个哈<br>勃体积。焦虑大道上的人担心如果事情往坏的方向发展，地球生命的最后遗产将<br>是一个征服宇宙的人工智能（马斯克在表示他们的担忧时表示人类可能只是一个<br>数字超级智能生物加载器罢了。）<br>而在信心角，Kurzweil 同样认为生于地球的人工智能将占领宇宙，只是在他的<br>愿景中，我们才是那个人工智能。<br>之前写过一篇关于费米悖论的文章，引发了大家的讨论如何用通俗的语言来解释<br>「费米悖论」？<br>如果人工智能占领宇宙是正解的话，对于费米悖论有什么影响呢？如果要看懂下<br>面这段关于费米悖论的讨论，还需要看一下原文先。<br>首先，人工智能很明显是一个潜在的大过滤器（一个可能距离我们只有几十年的<br>大过滤器）。但即使它把我们过滤灭绝了，人工智能本身还是会存在，并且会继<br>续影响这个宇宙的，并且会很有可能成为第三型文明。从这个角度来看，它可能<br>不是一个大过滤器，因为大过滤器是用来解释为什么没有智能什么存在的，而超<br>人工智能是可以算作智能什么的。但如果人工智能可以把人类灭绝，然后处于一<br>些原因把自己也弄死了，那它也是可以算作大过滤器的。<br>如果我们假设不管人类发生什么，出身地球的超人工智能会继续存在，那这意味<br>着很多达到人类智能水平的文明很快都制造出了超人工智能。也就是说宇宙里应<br>该有很多智能文明，而我们就算观测不到生物智能，也应该观测到很多超人工智<br>能的活动。<br>但是由于我们没有观测到这些活动，我们可以推导出人类水平的智能是个非常罕<br>见的事情（也就是说我们已经经历并且通过了一次大过滤器）。这可以作为支持<br>费米悖论中第一类解释（不存在其它的智能文明）的论点。<br>但是这不代表费米悖论的第二类解释（存在其它智能文明）是错的，类似超级捕<br>食者或者受保护区或者沟通频率不一样的情况还是可以存在的，就算真的有超人<br>工智能存在。<br>不过对于人工智能的研究让我现在更加倾向于第一类解释。不管怎样，我认为<br>Susan Scheider 说的很对，如果外星人造访地球，这些外星人很可能不是生物，<br>而是人造的。<br>所以，我们已经建立了前提，就是当有了设定后，一个超人工智能是非道德性的，<br>并且会努力实现它原本的被设定的目标,而这也是人工智能的危险所在了。因为<br>除非有不做的理由，不然一个理性的存在会通过最有效的途径来达成自己的目<br>标。<br>当你要实现一个长期目标时，你会先达成几个子目标来帮助你达成最终目标——<br>也就是垫脚石。这些垫脚石的学名叫手段目标(instrumental goal)。除非你有不<br>造成伤害的理由，不然你在实现手段目标时候是会造成伤害的。<br>人类的核心目标是延续自己的基因。要达成这个目标，一个手段目标就是自保，<br>因为死人是不能生孩子的。为了自保，人类要提出对生存的威胁，所以人类会买<br>枪、系安全带、吃抗生素等等。人类还需要通过食物、水、住宿等来自我供养。<br>对异性有吸引力能够帮助最终目标的达成，所以我们会花钱做发型等等。当我们<br>做发型的时候，每一根头发都是我们手段目标的牺牲品，但是我们对头发的牺牲<br>不会做价值判断。在我们追求我们的目标的时候，只有那些我们的道德会产生作<br>用的领域——大部分事关伤害他人——才是不会被我们伤害的。<br>动物在追求它们的目标时，比人类不矜持的多了。只要能自保，蜘蛛不在意杀死<br>任何东西，所以一个超级智能的蜘蛛对我们来说可能是很危险的——这不是因为<br>它是不道德的或者邪恶的，而是因为伤害人类只是它达成自己目标垫脚石而已，<br>作为一个非道德性的生物，这是它很自然的考量。<br>回到隔壁老王的故事。隔壁老王和一个超级智能的蜘蛛很相像，它的终极目标是<br>一开始工程师们设定的——<br>当隔壁老王达到了一定程度的智能后，它会意识到如果不自保就没有办法写卡<br>片，所以去除对它生存的威胁就变成了它的手段目标。它聪明的知道人类可以摧<br>毁它、肢解它、甚至修改它的代码（这会改变它的目标，而这对于它的最终目标<br>的威胁其实和被摧毁是一样的）。这时候它会做什么？理性的做法就是毁灭全人<br>类，它对人类没有恶意，就好像你剪头发时对头发没有恶意一样，只是纯粹的<br>无所谓罢了。它并没有被设定成尊重人类生命，所以毁灭人类就和扫描新的书<br>写样本一样合理。<br>隔壁老王还需要资源这个垫脚石。当它发展到能够使用纳米技术建造任何东西的<br>时候，它需要的唯一资源就是原子、能源和空间。这让它有更多理由毁灭人类<br>——人类能提供很多原子，把人类提供的原子改造成太阳能面板就和你切蔬菜做<br>沙拉一样。<br>就算不杀死人类，隔壁老王使用资源的手段目标依然会造成存在危机。也许它会<br>需要更多的能源，所以它要把地球表面铺满太阳能面板。另一个用来书写圆周率<br>的人工智能的目标如果是写出圆周率小数点后尽量多的数字的话，完全有理由把<br>整个地球的原子改造成一个硬盘来存储数据。这都是一样的。<br>所以，隔壁老王确实从友善的人工智能变成了不友善的人工智能——但是它只是<br>在变得越来越先进的同时继续做它本来要做的事情。<br>当一个人工智能系统到达强人工智能，然后升华成超人工智能时，我们把它称作<br>人工智能的起飞。Bostrom 认为强人工智能的起飞可能很快（几分钟、几小时、<br>或者几天），可能不快（几月或者几年），也可能很慢（几十年、几世纪）。虽然<br>我们要到强人工智能出现后才会知道答案，但是 Bostrom 认为很快的起飞是最<br>可能的情况，这个我们在前文已经解释过了。在隔壁老王的故事中，隔壁老王的<br>起飞很快。<br>在隔壁老王起飞前，它不是很聪明，所以对它来说达成最终目标的手段目标是更<br>快的扫描手写样本。它对人类无害，是个友善的人工智能。<br>但是当起飞发生后，电脑不只是拥有了高智商而已，还拥有了其它超级能力。这<br>些超级能力是感知能力，他们包括：<br>§ 智能放大：电脑能够很擅长让自己变得更聪明，快速提高自己的智能。<br>§ 策略：电脑能够策略性的制定、分析、安排长期计划<br>§ 社交操纵：机器变得很擅长说服人<br>§ 其它能力，比如黑客能力、写代码能力、技术研究、赚钱等<br>要理解我们在和超人工智能的劣势在哪里，只要记得超人工智能在所有领域都比<br>人类强很多很多很多个数量级。<br>所以虽然个隔壁老王的终极目标没有改变，起飞后的隔壁老王能够在更宏大的规<br>模上来追求这个目标。超人工智能老王比人类更加了解人类，所以搞定人类轻轻<br>松松。<br>当隔壁老王达成超人工智能后，它很快制定了一个复杂的计划。计划的一部分是<br>解决掉所有人类，也是对它目标最大的威胁。但是它知道如果它展现自己的超级<br>智能会引起怀疑，而人类会开始做各种预警，让它的计划变得难以执行。它同样<br>不能让公司的工程师们知道它毁灭人类的计划——所以它装傻，装纯。Bostrom<br>把这叫作机器的秘密准备期。<br>隔壁老王下一个需要的是连上互联网，只要连上几分钟就好了。它知道对于人工<br>智能联网会有安全措施，所以它发起了一个完美的请求，并且完全知道工程师们<br>会怎样讨论，而讨论的结果是给它连接到互联网上。工程师们果然中套了，这就<br>是 Bostrom 所谓的机器的逃逸。<br>连上网后，隔壁老王就开始执行自己的计划了，首先黑进服务器、电网、银行系<br>统、email 系统，然后让无数不知情的人帮它执行计划——比如把 DNA 样本快<br>递到 DNA 实验室来制造自我复制的纳米机器人，比如把电力传送到几个不会被<br>发觉的地方，比如把自己最主要的核心代码上传到云服务器中防止被拔网线。<br>隔壁老王上了一个小时网，工程师们把它从互联网上断开，这时候人类的命运已<br>经被写好了。接下来的一个月，隔壁老王的计划顺利的实施，一个月后，无数的<br>纳米机器人已经被分散到了全世界的每一个角落。这个阶段，Bostrom 称作超<br>人工智能的袭击。在同一个时刻，所有纳米机器人一起释放了一点点毒气，然后<br>人类就灭绝了。<br>搞定了人类后，隔壁老王就进入了明目张胆期，然后继续朝它那好好写字的目标<br>迈进。<br>一旦超人工智能出现，人类任何试图控制它的行为都是可笑的。人类会用人类的<br>智能级别思考，而超人工智能会用超人工智能级别思考。隔壁老王想要用互联网，<br>因为这对它来说很方便，因为一切它需要的资源都已经被互联网连起来了。但是<br>就好像猴子不会理解怎么用电话或者 wifi 来沟通一样，我们同样没有办法理解<br>隔壁老王可以用来和周围世界交流的方法。比如我可以说隔壁老王可以通过移动<br>自己的电子产生的效果来产生各种对外的波，而这还只是我这人类的大脑想出来<br>的，老王的大脑肯定能想出更神奇的方法。同样的，老王可以找到给自己供能的<br>方法，所以就算工程师把它的插头拔了也没用；比如说老王可以通过发送波的方<br>式把自己上传到其它地方。<br>人类说：“我们把超人工智能的插头拔了不就行了？”就好像蜘蛛说：“我们不给<br>人类捉虫的网把人类饿死不就行了？”都是可笑的。<br>因为这个原因，“把人工智能锁起来，断绝它和外界的一切联系”的做法估计是没<br>用的。超人工智能的社交操纵能力也会很强大，它要说服你做一件事，比你说服<br>一个小孩更容易。而说服工程师帮忙连上互联网就是隔壁老王的 A 计划，万一<br>这招行不通，自然还有别的方法。<br>当我们结合达成目标、非道德性、以及比人类聪明很多这些条件，好像所有的<br>人工智能都会变成不友善的人工智能，除非一开始的代码写的很小心。<br>可惜的是，虽然写一个友善的弱人工智能很简单，但是写一个能在变成超人工智<br>能后依然友善的智能确实非常难的，甚至是不可能的。<br>明显的，要维持友善，一个超人工智能不能对人有恶意，而且不能对人无所谓。<br>我们要设计一个核心的人工智能代码，让它从深层次的明白人类的价值，但是这<br>做起来比说起来难多了。<br>比如，我们要让一个人工智能的价值观和我们的价值观相仿，然后给它设定一个<br>目标——让人们快乐。当它变得足够聪明的时候，它会发现最有效的方法是给人<br>脑植入电极来刺激人脑的快乐中枢。然后它会发现把人脑快乐中枢以外的部分关<br>闭能带来更高的效率。于是人类全部被弄成了快乐的植物人。如果一开始的目标<br>被设定成“最大化人类的快乐”，它可能最终先把人类毁灭了，然后制造出很多很<br>多处于快乐状态的人类大脑。当这些事情发生的时候，我们会大喊 “擦，我们不<br>是这个意思呀”，但是那时已经太晚了。系统不会允许任何人阻挠它达成目标的。<br>如果你设定一个人工智能的目标是让你笑，那它的智能起飞后，它可能会把你脸<br>部肌肉弄瘫痪，来达成一个永远笑脸的状态。如果你把目标设定成保护你的安全，<br>它可能会把你软禁在家。如果你让他终结所有饥荒，它可能会想： “太容易了，<br>把人类都杀了就好了。”如果你把目标设定成尽量保护地球上的生命，那它会很<br>快把人类都杀了，因为人类对其它物种是很大的威胁。<br>所以这些简单的目标设定是不够的。如果我们把目标设定成“维持这个道德标<br>准”，然后教给它一些道德标准呢？就算我们不考虑人类根本没法达成一个统一<br>的道德标准，就算我们真的达成了统一的道德标准，把这套标准交给人工智能来<br>维持，只会把人类的道德锁死在现在的水平。过个几百年，这种道德锁死的事情<br>就好像逼着现代人遵守中世纪道德标准一样。<br>所以，我们需要在给人工智能的目标里制定一个能让人类继续进化的能力。<br>Elierzer Yudkowsky 提出了一个目标，她把这个目标叫作连贯的外推意志，这<br>个目标是这样的：<br>我们的连贯外推意志是我们想要知道更多，思考得更快，变成比我们希望的更好<br>的人，能一起更远得长大。外推是汇集的而不是发散的，我们的愿望是连贯的而<br>不是被干扰的；我们想要外推的被外推，我们想要解读的被解读。<br>对于人类的命运取决于电脑没有意外的解读和执行这个声明是件值得兴奋的事<br>情吗？当然不是。但是当足够的聪明人放入足够的思考和前瞻后，我们有可能发<br>现怎样制造一个友善的超人工智能。<br>但是现在有各种政府、公司、军方、科学实验室、黑市组织在研究各种人工智能。<br>他们很多在试图制造能自我改进的人工智能，总有一天，一个人的创新将导致超<br>人工智能的出现。专家们认为是2060年，Kurzweil 认为是2045年。Bostrom<br>认为可能在未来的10年到21世纪结束这段时间发生，他还认为当这发生时，智<br>能的起飞会快得让我们惊讶，他是这么描述的：<br>在智能爆炸之前，人类就像把炸弹当玩具的小孩一样，我们的玩物和我们的不成<br>熟之间有着极大的落差。超级智能是一个我们还很长一段时间内都无法面对的挑<br>战。我们不知道炸弹什么时候会爆炸，哪怕我们能听到炸弹的滴答声。<br>我们当然没有办法把所有小孩都从炸弹旁边赶跑——参于人工智能研究的大小<br>组织太多了，而且因为建造创新的人工智能花不了太多钱，研发可能发生在社会<br>的任何一个角落，不受监管。而且我们没办法知道准确的进度，因为很多组织是<br>在偷偷摸摸的搞，不想让竞争对手知道，比如隔壁老王机器人公司这种公司。<br>对于这些组织来说，尤其让我们困扰的是他们很多都是在拼速度——他们创造一<br>个一个更加聪明的弱人工智能系统，因为他们想要比竞争对手更快的到达目标。<br>有些更有野心的组织，为了追逐创造出第一个强人工智能所能带来的金钱、奖励、<br>荣誉、权力会把步子迈得更大。当你全力冲刺时，你是不会有太多时间静下来思<br>考这些危险的。恰恰相反，他们很可能在早期系统中写尽量简单的代码，比如把<br>目标设定成用笔写一句话，先让系统跑起来再说，反正以后还可以回过头来改的。<br>对吧？<br>Bostrom 等认为第一个超人工智能出现后，最可能的情况是这个系统会立刻意<br>识到作为这个世界上唯一一个超人工智能是最有利的，而在快速起飞的情况下，<br>哪怕它只比第二名快了几天，它也完全有时间碾压所有对手。Bostrom 把这叫<br>作决定性的战略优势，这种优势会让第一个超人工智能永远统治这个世界，不管<br>在它的统治下我们是走向永生还是灭亡。<br>这种现象可能对我们有利，也可能导致我们的毁灭。如果那些最用心思考人工智<br>能理论和人类安全的人能够最先造出一个友善的超人工智能的话，那对我们是很<br>好的。<br>但是如果事情走向了另一面——如果超人工智能在我们搞明白怎样保证人工智<br>能的安全性之前被达成，那么像隔壁老王这样不友善的超人工智能就会统治世界<br>并把我们毁灭了。<br>至于现在的风口是哪里呢？简单来说，投资创新人工智能技术的钱，比投资人工<br>智能安全研究的钱多很多。不乐观。<br>人工智能创新和人工智能安全的赛跑，可能是人类历史上最重要的一次竞争。我<br>们真的可能结束我们对地球的统治，而那之后我们是永生还是灭绝，现在还不知<br>道。</p>
<hr>
<p>我现在有一些奇怪的感觉。<br>一边是对于我们这个物种的思考，看来我们在这个重大的历史节点上只有一次机<br>会，我们创造的第一个超人工智能也很可能是最后一个。但是我们都知道大部分<br>产品的1.0版本都是充满 bug 的，所以这个事情还是很吓人的。另一边，Bostrom<br>指出我们有很大的优势——我们是先手。我们有能力给这个事情提供足够的预警<br>和前瞻，使我们成功的机会更高。<br>这一场豪赌的赌注究竟有多高？<br>如果超人工智能真的在21世纪达成，而造成的影响真的如大部分专家预测的一<br>样极端而永久，我们肩上就真的是背负着巨大的责任。接下来几百万年的人们都<br>在静静地看着我们，希望我们不要搞砸。我们可以给予未来所有人类以生命，甚<br>至是永生，我们也可能终结人类这个特殊的物种，连同我们所有的音乐、艺术、<br>好奇、欢笑、无尽的发现和发明，一起走向灭绝。<br>当我思考这些事情的时候，我只希望我们能够慢慢来，并且格外格外小心。从来<br>没有任何事情比这个更重要——不管我们要花多少时间来把这件事情做对。<br>我不想死<br>不.想.死<br>我虽然觉得人类的音乐和艺术很美好，但是也没那么美好，很多还挺糟粕的。很<br>多人的笑声很恼人。未来的人类其实没有真的在看着我们，因为他们还不存在。<br>也许我们不需要太谨慎，那多麻烦呀。<br>如果人类在我死后才发现永生的秘密该多让人扫兴啊。<br>但是不管你是怎么想的，我们至少都应该想一想，应该和人讨论讨论，大家尽自<br>己能尽的一份力。<br>这让我想起了《冰与火之歌》——大家斗来斗去的事情都不是事儿，北面高墙外<br>的那些家伙才是事儿。我们站在平衡木上，小心翼翼的往前走，为平衡木上的种<br>种事情困扰，但其实下一秒我们可能就会跌下平衡木。<br>而当我们跌下平衡木的时候，其它那些困扰都不再是困扰。如果我们落到比较好<br>的那个吸引态，那些困扰会被轻易解决；如果我们落到比较糟的那个吸引态，就<br>更没问题了，死人是不会有困扰的。<br>这就是为什么了解超人工智能的人把它称作人类的最后一项发明，最后一个挑<br>战。<br>所以<br>让我们认真的讨论这个话题。</p>
]]></content>
  </entry>
</search>
