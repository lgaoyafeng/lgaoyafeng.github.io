<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="千里之行,始于足下"><meta name="keywords" content=""><meta name="author" content="丰之霸"><meta name="copyright" content="丰之霸"><title>Hexo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">丰之霸</div><div class="author-info__description text-center">千里之行,始于足下</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">30</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hexo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Hexo</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%BB%84%E5%90%88/">电话号码组合</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h1 id="电话号码组合"><a href="#电话号码组合" class="headerlink" title="电话号码组合"></a>电话号码组合</h1><ul>
<li><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>将所有的数字对应的字母拆成单个的字母,存在一个map中,key对应数字,value对应相应的byte类型字母组合</li>
<li>遍历输入的字符串,并用该字符去减’0’,既找到改数字对应的数,然后去map中取对应的value,存在数组arr中</li>
<li>事先建立一个res数组(string类型),并将第一个元素赋值为空字符串</li>
<li>遍历res数组,</li>
<li>遍历arr数组,将每一个值与res的第一字符串进行拼接,遍历结束后,将res数组中的第一个元素删除,直至循环结束<ul>
<li>概括就是 删除头,末尾追加</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> digits == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	digitsmap := <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"2"</span>: &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;,</span><br><span class="line">		<span class="string">"3"</span>: &#123;<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>&#125;,</span><br><span class="line">		<span class="string">"4"</span>: &#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;,</span><br><span class="line">		<span class="string">"5"</span>: &#123;<span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>&#125;,</span><br><span class="line">		<span class="string">"6"</span>: &#123;<span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"o"</span>&#125;,</span><br><span class="line">		<span class="string">"7"</span>: &#123;<span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>&#125;,</span><br><span class="line">		<span class="string">"8"</span>: &#123;<span class="string">"t"</span>, <span class="string">"u"</span>, <span class="string">"v"</span>&#125;,</span><br><span class="line">		<span class="string">"9"</span>: &#123;<span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//append只是进行了追加操作,得到了新的新结果,若想使用,需接受改结果</span></span><br><span class="line">	res = <span class="built_in">append</span>(res, <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(digits); i++ &#123;</span><br><span class="line">		reagen := <span class="built_in">len</span>(res)</span><br><span class="line">		digit := digits[i : i+<span class="number">1</span>]</span><br><span class="line">        str := digitsmap[digit]</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; reagen; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> _, letter := <span class="keyword">range</span> str&#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res, res[<span class="number">0</span>]+letter)</span><br><span class="line">			&#125;</span><br><span class="line">			res = res[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E7%8C%9C%E6%95%B0%E5%AD%97/">猜数字</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h1 id="猜数字问题XAXB-文曲星-go语言实现"><a href="#猜数字问题XAXB-文曲星-go语言实现" class="headerlink" title="猜数字问题XAXB,文曲星,go语言实现"></a>猜数字问题XAXB,文曲星,go语言实现</h1><p>同事给我甩过来一个题,如下<br>猜数字游戏通常由两个人玩，一方出数字，一方猜。出数字的人要想好一个没有重复数<br>字的 4 个数，不能让猜的人知道。猜的人就可以开始猜。每猜一个数字，出数者就要根据这<br>个数字给出几 A 几 B，其中 A 前面的数字表示位置正确的数的个数，而 B 前的数字表示数字<br>正确而位置不对的数的个数。如正确答案为 5234，而猜的人猜 5346，则是 1A2B，其中有<br>一个 5 的位置对了，记为 1A，而 3 和 4 这两个数字对了，而位置没对，因此记为 2B，合起<br>来就是 1A2B。接着猜的人再根据出题者的几 A 几 B 继续猜，直到猜中（即 4A0B）为止。<br>猜的人有 8 次机会。</p>
<p>例如：<br>乙出一个数字，甲猜。<br>  甲       乙<br>1234 1A0B<br>5678 2A1B<br>5674 1A1B<br>5638 1A1B<br>2678 2A2B<br>6278 4A0B(猜中)<br>现需设计一个程序，以甲的身份(注意是甲的身份)猜对方的数字。<br>请设计方案并且列出主要方法名。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我用的是暴力解法:<br>1.将四位数字中所有的不重复数字找出,并存到切片中.代码如下<br>//获取所有不重复的四位数字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有的不重复四位数字,存在切片中(由于使用的是数字所以1000一下的显示为三位,但后续也会将其当四位数字处理)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbs</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == i &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> m := <span class="number">0</span>; m &lt; <span class="number">10</span>; m++ &#123;</span><br><span class="line">				<span class="keyword">if</span> m == j || m == i &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">10</span>; n++ &#123;</span><br><span class="line">					<span class="keyword">if</span> n == m || n == j || n == i &#123;</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					a := i*<span class="number">1000</span> + j*<span class="number">100</span> + m*<span class="number">10</span> + n</span><br><span class="line">					arr = <span class="built_in">append</span>(arr, a)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.取切片中的第一个数(0123)去跟目标值匹配,得到一个结果,类似0A1B,记下该结果</p>
<p>3.重点来了,循环将第一个数跟所有的数匹配,得到结果这里我直接省事返回的是 “01”这种,<br>然后将这个结果和第二步的结果去比对,不一样的统统删除(这里因为切片的删除比较麻烦,我是将其赋值为0),代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">​<span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">//这是将两数进行比对的方法</span></span><br><span class="line"><span class="string">func match(target int, numInp int) string &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	numMap := make(map[int]int)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	for i := 0; i &lt; 4; i++ &#123;</span></span><br><span class="line"><span class="string">	//将四位数分别放到map中,对应key 为1 2 3 4 </span></span><br><span class="line"><span class="string">		a := target</span></span><br><span class="line"><span class="string">		if a &lt; 1000 &#123;</span></span><br><span class="line"><span class="string">			numMap[1] = 0</span></span><br><span class="line"><span class="string">			numMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			numMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			numMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			numMap[1] = a / 1000</span></span><br><span class="line"><span class="string">			numMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			numMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			numMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	inpMap := make(map[int]int)</span></span><br><span class="line"><span class="string">	for i := 0; i &lt; 4; i++ &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		a := numInp</span></span><br><span class="line"><span class="string">		if a &lt; 1000 &#123;</span></span><br><span class="line"><span class="string">			inpMap[1] = 0</span></span><br><span class="line"><span class="string">			inpMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			inpMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			inpMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			inpMap[1] = a / 1000</span></span><br><span class="line"><span class="string">			inpMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			inpMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			inpMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	var counta int</span></span><br><span class="line"><span class="string">	//将两个数对应的map中的对应的位比对,相等</span></span><br><span class="line"><span class="string">	for i := 1; i &lt; 5; i++ &#123;</span></span><br><span class="line"><span class="string">		if numMap[i] == inpMap[i] &#123;</span></span><br><span class="line"><span class="string">			counta++</span></span><br><span class="line"><span class="string">			delete(numMap, i)</span></span><br><span class="line"><span class="string">			delete(inpMap, i)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//fmt.Println(numMap)</span></span><br><span class="line"><span class="string">	//fmt.Println(inpMap)</span></span><br><span class="line"><span class="string">	var countb int</span></span><br><span class="line"><span class="string">	for i := 1; i &lt; 5; i++ &#123;</span></span><br><span class="line"><span class="string">		_, ok := inpMap[i]</span></span><br><span class="line"><span class="string">		if !ok &#123;</span></span><br><span class="line"><span class="string">			continue</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		for j := 1; j &lt; 5; j++ &#123;</span></span><br><span class="line"><span class="string">			_, ok := numMap[j]</span></span><br><span class="line"><span class="string">			if !ok &#123;</span></span><br><span class="line"><span class="string">				continue</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			if inpMap[i] == numMap[j] &#123;</span></span><br><span class="line"><span class="string">				countb++</span></span><br><span class="line"><span class="string">				delete(inpMap, i)</span></span><br><span class="line"><span class="string">				delete(numMap, j)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//fmt.Printf("%v A %v B", counta, countb)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return strconv.Itoa(counta)+strconv.Itoa(countb)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//判断结果的方法</span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">	arr := numbs()</span></span><br><span class="line"><span class="string">	num := arr[0]</span></span><br><span class="line"><span class="string">	fmt.Println(num)</span></span><br><span class="line"><span class="string">	var count int</span></span><br><span class="line"><span class="string">	for &#123;</span></span><br><span class="line"><span class="string">		fmt.Println("请输入猜的结果1A1B既输入11")</span></span><br><span class="line"><span class="string">		var result string</span></span><br><span class="line"><span class="string">		fmt.Scanln(&amp;result)</span></span><br><span class="line"><span class="string">		for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">			if arr[i] == 0 &#123;</span></span><br><span class="line"><span class="string">				continue</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			str := match(num, arr[i])</span></span><br><span class="line"><span class="string">			fmt.Println(str)</span></span><br><span class="line"><span class="string">			if result != str &#123;</span></span><br><span class="line"><span class="string">				arr[i] = 0</span></span><br><span class="line"><span class="string">				count++</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		fmt.Printf("count: %v \n",count)</span></span><br><span class="line"><span class="string">		for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">			if arr[i] != 0 &#123;</span></span><br><span class="line"><span class="string">				fmt.Printf("下一个数字 %v \n", arr[i])</span></span><br><span class="line"><span class="string">				num = arr[i]</span></span><br><span class="line"><span class="string">				break</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if count == 5039 &#123;</span></span><br><span class="line"><span class="string">			for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">				if arr[i] != 0 &#123;</span></span><br><span class="line"><span class="string">					fmt.Printf("正确答案: %v", arr[i])</span></span><br><span class="line"><span class="string">					return</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">​</span></span><br></pre></td></tr></table></figure>
<p>```</p>
<p>执行一轮后, 继续给出切片中剩余不为零的第一个元素,将获取的值继续给到程序中进行比对,直到切片中只有一个不为0元素,即为正确数字</p>
<p>4.此算法最多是8步,平均值因为做的实验较少,未知,还有其他更好的算法,希望大佬指出</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E6%B1%82%E4%BA%8C%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/">求二数的最大公约数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h1 id="二数的最大公约数"><a href="#二数的最大公约数" class="headerlink" title="二数的最大公约数"></a>二数的最大公约数</h1><h3 id="1-辗转相除法"><a href="#1-辗转相除法" class="headerlink" title="1. 辗转相除法"></a>1. 辗转相除法</h3><p>​        又名欧几里得算法（Euclidean algorithm），该算法的目的 是求出两个正整数的最大公约数。它是已知最古老的算法， 其产生时间可追溯至公 元前300年前。</p>
<p>​        这条算法基于一个定理：两个正整数a和b（a&gt;b），它们的最大公约数等于a除 以b的余数c和b之间的最大公约数。 例如10和25，25除以10商2余5，那么10和25的最大公约数，等同于10和5的最 大公约数。</p>
<p>java代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGreatestCommonDivisorV2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">        <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">        <span class="keyword">if</span> (big % small == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> small;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getGreatestCommonDivisorV2(small, big % small);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>go代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-更相减损术"><a href="#2-更相减损术" class="headerlink" title="2. 更相减损术"></a>2. 更相减损术</h3><p>​        两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差 值c和较小数b的最大公约数。例如10和25，25减10的差是15，那么10和25的最大 公约数，等同于10和15的最大公约数。</p>
<p>java代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGreatestCommonDivisorV3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">     <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">     <span class="keyword">if</span> (big % small == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> small;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> getGreatestCommonDivisorV3(big-small, small);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-最优解-综合位运算"><a href="#3-最优解-综合位运算" class="headerlink" title="3.最优解(综合位运算)"></a>3.最优解(综合位运算)</h3><ul>
<li><p>当a和b均为偶数时，gcd(a,b) = 2×gcd(a/2, b/2) = 2×gcd(a&gt;&gt;1,b&gt;&gt;1)。</p>
</li>
<li><p>当a为偶数，b为奇数时，gcd(a,b) = gcd(a/2,b) = gcd(a&gt;&gt;1,b)。</p>
</li>
<li><p>当a为奇数，b为偶数时，gcd(a,b) = gcd(a,b/2) = gcd(a,b&gt;&gt;1)。 </p>
</li>
<li><p>当a和b均为奇数时，先利用更相减损术运算一次，gcd(a,b) = gcd(b,a-b)，此 时a-b必然是偶数，然后又可以继续进行移位运算。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//a b 同时为偶数数</span></span><br><span class="line">        <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//相当于2(a/2,b/2)</span></span><br><span class="line">            <span class="keyword">return</span> gcd(a&gt;&gt;<span class="number">1</span>,b&gt;&gt;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//a为偶数,b为奇数</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((a &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(a&gt;&gt;<span class="number">1</span>,b);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(a,b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//同为奇数进行一次用更相减损术</span></span><br><span class="line">            <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">            <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">            <span class="keyword">return</span> gcd(big-small,small);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="判断一个数是不是2的整数次幂"><a href="#判断一个数是不是2的整数次幂" class="headerlink" title="判断一个数是不是2的整数次幂"></a>判断一个数是不是2的整数次幂</h1><p> (num&amp;num-1) == 0 为整数次幂  num&amp;num-1的作用是将该数的最后一位1改为0</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Quick2Sort</span><span class="params">(values []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(values) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mid, i := values[<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">	head, tail := <span class="number">0</span>, <span class="built_in">len</span>(values)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> head &lt; tail &#123;</span><br><span class="line">		fmt.Println(values)</span><br><span class="line">		<span class="keyword">if</span> values[i] &gt; mid &#123;</span><br><span class="line">			values[i], values[tail] = values[tail], values[i]</span><br><span class="line">			tail--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			values[i], values[head] = values[head], values[i]</span><br><span class="line">			head++</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	values[head] = mid</span><br><span class="line">	Quick2Sort(values[:head])</span><br><span class="line">	Quick2Sort(values[head+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        第一步,取排序数组的第一个元素values[0],然后从第二个元素遍历数组,将values[0]与该元素比较,如果大于values[0],就将其放到数组末尾(依次往前),否则放到前边(依次往后),直到两个指针相遇,然后将中间值与第一个数进行调换,然后以改值为中心将其分割为两个数组,继续递归调用该方法.</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="comment">//外层步长控制</span></span><br><span class="line">    <span class="keyword">for</span> step := <span class="built_in">len</span>(nums) / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//开始插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := step; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="comment">//满足条件则插入</span></span><br><span class="line">            <span class="keyword">for</span> j := i - step; j &gt;= <span class="number">0</span> &amp;&amp; nums[j+step] &lt; nums[j]; j -= step &#123;</span><br><span class="line">                nums[j], nums[j+step] = nums[j+step], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E6%9D%82%E9%A1%B9%E7%BB%8F%E9%AA%8C/">杂项经验</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><ul>
<li><p>在git中clone项目有两种方式：HTTPS和SSH，它们的区别如下：</p>
</li>
<li><p>HTTPS：不管是谁，拿到url随便clone，但是在push的时候需要验证用户名和密码；</p>
</li>
<li><p>SSH：clone的项目你必须是拥有者或者管理员，而且需要在clone前添加SSH Key。SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则直接是不需要输入密码的。</p>
</li>
<li><p>在git中使用SSH Key的步骤：</p>
</li>
<li><p>检查电脑是否存在SSH Key：$ cd ~/.ssh$ ls</p>
</li>
<li><p>如果存在id_rsa.pub 或 id_dsa.pub 文件，说明文件以及存在，跳过创建SSH Key步骤。</p>
</li>
<li><p>创建SSH Key</p>
</li>
<li><p>将公共的SSH 放到远程仓库上</p>
<h1 id="时间入参出参的格式化注解"><a href="#时间入参出参的格式化注解" class="headerlink" title="时间入参出参的格式化注解"></a>时间入参出参的格式化注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#以下格式为国际标准格式,可根据具体需要更改</span><br><span class="line"><span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>,timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line"><span class="meta">@DateTimeFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="BigDecimal-的运算"><a href="#BigDecimal-的运算" class="headerlink" title="BigDecimal 的运算"></a>BigDecimal 的运算</h1><h3 id="使用静态的valueOf方法可以将普通的数值转换为大数值："><a href="#使用静态的valueOf方法可以将普通的数值转换为大数值：" class="headerlink" title="使用静态的valueOf方法可以将普通的数值转换为大数值："></a>使用静态的valueOf方法可以将普通的数值转换为大数值：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger b = BigInteger.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="遗憾的是，不能使用人们熟悉的算术运算符（如：-和-）处理大数值。而需要使用-大数值类中的add和multiply方法。"><a href="#遗憾的是，不能使用人们熟悉的算术运算符（如：-和-）处理大数值。而需要使用-大数值类中的add和multiply方法。" class="headerlink" title="遗憾的是，不能使用人们熟悉的算术运算符（如：+和*）处理大数值。而需要使用 大数值类中的add和multiply方法。"></a>遗憾的是，不能使用人们熟悉的算术运算符（如：+和*）处理大数值。而需要使用 大数值类中的add和multiply方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">10</span>);</span><br><span class="line">BigInteger b = BigInteger.valueOf(<span class="number">10</span>);</span><br><span class="line">BigInteger c = b.add(a); <span class="comment">//c=a+b</span></span><br><span class="line">BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>)));<span class="comment">//d = c*(b+2)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigInteger <span class="title">abs</span><span class="params">()</span> 返回大整数的绝对值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span> 返回两个大整数的和</span></span><br><span class="line"><span class="function">BigInteger <span class="title">and</span><span class="params">(BigInteger val)</span> 返回两个大整数的按位与的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">andNot</span><span class="params">(BigInteger val)</span> 返回两个大整数与非的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span> 返回两个大整数的商</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> 返回大整数的<span class="keyword">double</span>类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> 返回大整数的<span class="keyword">float</span>类型的值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">gcd</span><span class="params">(BigInteger val)</span> 返回大整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> 返回大整数的整型值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> 返回大整数的<span class="keyword">long</span>型值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">max</span><span class="params">(BigInteger val)</span> 返回两个大整数的最大者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">min</span><span class="params">(BigInteger val)</span> 返回两个大整数的最小者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger val)</span> 用当前大整数对val求模</span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span> 返回两个大整数的积</span></span><br><span class="line"><span class="function">BigInteger <span class="title">negate</span><span class="params">()</span> 返回当前大整数的相反数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">not</span><span class="params">()</span> 返回当前大整数的非</span></span><br><span class="line"><span class="function">BigInteger <span class="title">or</span><span class="params">(BigInteger val)</span> 返回两个大整数的按位或</span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span> 返回当前大整数的exponent次方</span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span> 返回当前大整数除以val的余数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">leftShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数左移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">rightShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数右移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>返回两个大整数相减的结果</span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">toByteArray</span><span class="params">(BigInteger val)</span>将大整数转换成二进制反码保存在<span class="keyword">byte</span>数组中</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> 将当前大整数转换成十进制的字符串形式</span></span><br><span class="line"><span class="function">BigInteger <span class="title">xor</span><span class="params">(BigInteger val)</span> 返回两个大整数的异或</span></span><br></pre></td></tr></table></figure>

<h4 id="提示：要想快速地打印一个二维数组的数据元素列表，可以调用："><a href="#提示：要想快速地打印一个二维数组的数据元素列表，可以调用：" class="headerlink" title="提示：要想快速地打印一个二维数组的数据元素列表，可以调用："></a>提示：要想快速地打印一个二维数组的数据元素列表，可以调用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.deepToSrring(arr));</span><br></pre></td></tr></table></figure>

<h2 id="前端传参问题"><a href="#前端传参问题" class="headerlink" title="前端传参问题:"></a>前端传参问题:</h2><ul>
<li><p>当传参为集合或数组时使用的是<code>json</code>传参时(仅有一个参数)只需用以下格式[1,2,3]</p>
</li>
<li><p>当参数只有一个时,参数名可以省略</p>
</li>
<li><p>当使用paras传参时,应使用 test?ids=1,2,3的格式</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">岛屿数量</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>​        LeetCode(200)给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题是一个可以使用深度优先搜索(DFS),也可以使用广度优先搜索(BFS)的题,</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS:"></a>DFS:</h5><p> 顺序的从前往后遍历,当发现有元素为’1’时,将与该元素的相连的值为’1’的元素赋值为0,然后再递归的调用自身方法对该元素四周的元素进行搜索,如果有’1’也将其复制为’0’直到找到所有与原始’1’联系的1,继续遍历,再碰到1让计数++.</p>
<p>java代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                   sum++;</span><br><span class="line">                   dfs(grid, i, j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//递归将'1'旁边的'1'赋值为方法,</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>||i&gt;=na||j&gt;=nb|| grid[i][j]==<span class="string">'0'</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       grid[i][j]=<span class="string">'0'</span>;</span><br><span class="line">       dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">       dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">       dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">       dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>go代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> grid == <span class="literal">nil</span> || <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	na := <span class="built_in">len</span>(grid)</span><br><span class="line">	nb := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; na; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; nb; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> &#123;</span><br><span class="line">				sum++</span><br><span class="line">				dfs(grid, i, j)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(grid [][]<span class="keyword">byte</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	na := <span class="built_in">len</span>(grid)</span><br><span class="line">	nb := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= na || j &gt;= nb || grid[i][j] == <span class="string">'0'</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	grid[i][j] = <span class="string">'0'</span></span><br><span class="line">	dfs(grid, i+<span class="number">1</span>, j)</span><br><span class="line">	dfs(grid, i<span class="number">-1</span>, j)</span><br><span class="line">	dfs(grid, i, j+<span class="number">1</span>)</span><br><span class="line">	dfs(grid, i, j<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS:"></a>BFS:</h5><p> 其实就是把使用的递归的方法搜索改为使用栈进行搜索,但是通过对比执行效率效率下降不少,推荐还是使用递归,代码简洁,效率高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                   sum++;</span><br><span class="line">                   grid[i][j]=<span class="number">0</span>;</span><br><span class="line">                   Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                   queue.add(nb * i + j);</span><br><span class="line">                   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                       Integer poll = queue.remove();</span><br><span class="line">                       <span class="keyword">int</span> row = poll / nb;</span><br><span class="line">                       <span class="keyword">int</span> col = poll % nb;</span><br><span class="line">                       <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nb &amp;&amp; grid[row][col + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row][col + <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col + <span class="number">1</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row][col - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col - <span class="number">1</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (row + <span class="number">1</span> &lt; na &amp;&amp; grid[row + <span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row + <span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col + nb);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row - <span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row - <span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col - nb);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E5%8F%82%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/">参数值格式问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h1 id="Spring-Boot-jackson（Date类型入参、格式化，以及如何处理null）"><a href="#Spring-Boot-jackson（Date类型入参、格式化，以及如何处理null）" class="headerlink" title="Spring Boot jackson（Date类型入参、格式化，以及如何处理null）"></a>Spring Boot jackson（Date类型入参、格式化，以及如何处理null）</h1><blockquote>
<p>首先，我们要知道 springboot 默认使用 jackson 解析 json（当然这里也是可以配置使用其他 json 解析框架）。<br> 在不配置其他 json 解析的情况下，我们可以通过 spring boot 提供的注解和配置 来让 jackson 帮助我们提高开发效率</p>
</blockquote>
<h4 id="一、-使用-ResponseBody-RequestBody，-Date-类型对象入参，返回json格式化"><a href="#一、-使用-ResponseBody-RequestBody，-Date-类型对象入参，返回json格式化" class="headerlink" title="一、 使用 @ResponseBody @RequestBody， Date 类型对象入参，返回json格式化"></a>一、 使用 @ResponseBody @RequestBody， Date 类型对象入参，返回json格式化</h4><p><strong>解决方法如下:</strong></p>
<h5 id="1-application-properties中加入如下代码"><a href="#1-application-properties中加入如下代码" class="headerlink" title="1. application.properties中加入如下代码"></a>1. application.properties中加入如下代码</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.jackson.date-format=yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="string">spring.jackson.time-zone=GMT+8</span></span><br></pre></td></tr></table></figure>

<h5 id="2-如果个别实体需要使用其他格式的-pattern，在实体上加入注解即可"><a href="#2-如果个别实体需要使用其他格式的-pattern，在实体上加入注解即可" class="headerlink" title="2. 如果个别实体需要使用其他格式的 pattern，在实体上加入注解即可"></a>2. 如果个别实体需要使用其他格式的 pattern，在实体上加入注解即可</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.annotation.DateTimeFormat;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MrType</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonFormat</span>(timezone = <span class="string">"GMT+8"</span>,pattern = <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createdDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于spring boot 时间类型支持我做了以下测试：</p>
<ol>
<li>application.properties 配置注释，不添加注解：spring 无法接收时间参数（400），json 输出 <code>&quot;2018-03-29T09:45:31.513+0000&quot;</code></li>
<li>application.properties 配置开启，不添加注解：仅支持 <code>yyyy-MM-dd HH:mm:ss</code> 的格式参数和 json 输出</li>
<li>application.properties 配置开启，实体添加 <code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code>，实体可接受 <code>yyyy-MM-dd HH:mm:ss</code> 和 <code>yyyy-MM-dd</code> 格式的参数，json输出格式为 yyyy-MM-dd，由此可见@JsonFormat是限制Date 类型 json 输出的，但是为什么对接受的类型也造成了影响？有待考证</li>
<li>application.properties 配置开启，实体添加 <code>@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</code>，结果与第二条测试一样？貌似<code>@DateTimeFormat</code> 注解并没有生效？有待考证</li>
<li>application.properties 配置开启，实体添加 <code>@JsonFormat</code> 和 <code>@DateTimeFormat</code> 结果与第三条一样</li>
</ol>
<p>结论：实际项目中 application.properties设置通用时间格式，个别属性需要特殊处理时，添加<code>@JsonFormat</code><br> （<code>@JsonFormat</code> 自己好像就把这件事搞定了）</p>
<h4 id="二、-使用-ResponseBody-时-忽略-json-中值为null的属性"><a href="#二、-使用-ResponseBody-时-忽略-json-中值为null的属性" class="headerlink" title="二、 使用 @ResponseBody 时 忽略 json 中值为null的属性"></a>二、 使用 @ResponseBody 时 忽略 json 中值为null的属性</h4><h5 id="1-application-properties中加入如下代码-1"><a href="#1-application-properties中加入如下代码-1" class="headerlink" title="1. application.properties中加入如下代码"></a>1. application.properties中加入如下代码</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.jackson.default-property-inclusion=non-null</span></span><br></pre></td></tr></table></figure>

<p>或者在类上声明<br> @JsonInclude(JsonInclude.Include.NON_NULL)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_NULL)<span class="comment">//该注解配合jackson，序列化时忽略 null属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxResult</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h2 id="一文学会动态规划解题技巧"><a href="#一文学会动态规划解题技巧" class="headerlink" title="一文学会动态规划解题技巧"></a>一文学会动态规划解题技巧</h2><p>原创 码海 <a href="javascript:void(0);">码海</a> <em>2月16日</em></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态规划（dynamic programming，简称 dp)是工程中非常重要的解决问题的思想，从我们在工程中地图软件上应用的最短路径问题，再在生活中的在淘宝上如何凑单以便利用满减券来最大程度地达到我们合理薅羊毛的目的 ，很多时候都能看到它的身影。不过动态规划对初学者来说确实比较难，dp状态，状态转移方程让人摸不着头脑，网上很多人也反馈不太好学，其实就像我们之前学<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener">递归</a>那样，任何算法的学习都是有它的规律和套路的，只要掌握好它的规律及解题的套路，再加上大量的习题练习，相信掌握它不是什么难事，本文将会用比较浅显易懂地讲解来帮助大家掌握动态规划这一在工程中非常重要的思想，相信看完后，动态规划的解题套路一定能手到擒来（文章有点长，建议先收藏再看，看完后一定会对动态规划的认知上升到一个台阶！）</p>
<p>本文将会从以下角度来讲解动态规划：</p>
<ul>
<li>什么是动态规划</li>
<li>动态规划从入门到进阶</li>
<li>再谈动态规划</li>
</ul>
<h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>以下是我综合了动态规划的特点给出的动态规划的定义： 动态规划是一种<strong>多阶段决策</strong>最优解模型，一般用来求最值问题，多数情况下它可以采用<strong>自下而上</strong>的递推方式来得出每个子问题的最优解（即最优子结构），进而自然而然地得出依赖子问题的原问题的最优解。</p>
<p>划重点：</p>
<ol>
<li><strong>多阶段决策</strong>，意味着问题可以分解成子问题，子子问题，。。。，也就是说问题可以拆分成多个子问题进行求解</li>
<li><strong>最优子结构</strong>，在自下而上的递推过程中，我们求得的每个子问题一定是<strong>全局最优解</strong>，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。</li>
<li><strong>自下而上</strong>，怎样才能自下而上的求出每个子问题的最优解呢，可以肯定子问题之间是有一定联系的，即迭代递推公式，也叫「状态转移方程」，要定义好这个状态转移方程， 我们就需要定义好每个子问题的状态（DP 状态），那为啥要自下而上地求解呢，因为如果采用像递归这样自顶向下的求解方式，子问题之间可能存在大量的重叠，大量地重叠子问题意味着大量地重复计算，这样时间复杂度很可能呈指数级上升（在下文中我们会看到多个这样重复的计算导致的指数级的时间复杂度），所以自下而上的求解方式可以消除重叠子问题。</li>
</ol>
<p>简单总结一下，最优子结构，状态转移方程，重叠子问题就是动态规划的三要素，这其中定义子问题的状态与写出状态转移方程是解决动态规划最为关键的步骤，状态转移方程如果定义好了，解决动态规划就基本不是问题了。</p>
<p>既然我们知道动态规划的基本概念及特征，那么怎么判断题目是否可以用动态规划求解呢，其实也很简单，当问题的定义是求最值问题，且问题可以采用递归的方式，并且递归的过程中有大量重复子问题的时候，基本可以断定问题可以用动态规划求解，于是我们得出了求解动态规划基本思路如下（解题四步曲）</p>
<ol>
<li>判断是否可用递归来解，可以的话进入步骤 2</li>
<li>分析在递归的过程中是否存在大量的重复子问题</li>
<li>采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</li>
<li>改用自底向上的方式来递推，即动态规划</li>
</ol>
<p><em>画外音：递归怎么求解，强烈建议看下</em><a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener"><em>这篇文章</em></a><em>，好评如潮,总结了常见的递归解题套路</em></p>
<p>可能不少人看了以上的动态规划的一些介绍还是对一些定义如 DP 状态，状态转移方程，自底而上不了解，没关系 ，接下来我们会做几道习题来强化一下大家对这些概念及动态规划解题四步曲的理解，每道题我们都会分别用递归，递归+备忘录，动态规划来求解一遍，这样也进一步帮助大家来巩固我们之前学的递归知识</p>
<h2 id="动态规划从入门到进阶"><a href="#动态规划从入门到进阶" class="headerlink" title="动态规划从入门到进阶"></a>动态规划从入门到进阶</h2><h3 id="入门题：斐波那契数列"><a href="#入门题：斐波那契数列" class="headerlink" title="入门题：斐波那契数列"></a>入门题：斐波那契数列</h3><p>接下来我们来看看怎么用动态规划解题四步曲来解斐波那契数列</p>
<p><em>画外音：斐波那契数列并不是严格意义上的动态规划，因为它不涉及到求最值，用这个例子旨在说明重叠子问题与状态转移方程</em></p>
<p>1、判断是否可用递归来解 显然是可以的，递归代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static int fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、分析在递归的过程中是否存在大量的重复子问题</p>
<p>怎么分析是否有重复子问题，画出递归树</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oCuTibzC3FxUSav02sSSqvfDW394sXP61vRUMc9WZBPsA2v0ponl450A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>可以看到光是求 f(6)，就有两次重复的计算， f(4) 求解了两次，f(3) 求解了两次，时间复杂度是指数级别，递归时间复杂度怎么看，解决每个子问题需要的时间乘以子问题总数，每个子问题需要的时间即 f(n) = f(n-1) + f(n-2) 只做了一次加法运算，子问题的个数有多少呢，每个问题一分为二,是个二叉树，可以看到第一层 1 个，第二层 2 个，第三层 4 个，即 1 + 2 + 2^2 + …. 2^n，所以总的来说时间复杂度是)O(2^n),是指数级别</p>
<p><em>画外音：求解问题 f(6),转成求 f(5),f(4),从原问题出发，分解成求子问题，子问题再分解成子子问题，。。。，直到再也不能分解，这种从 原问题展开子问题进行求解的方式叫自顶向下</em></p>
<p>3、采用备忘录的方式来存子问题的解以避免大量的重复计算 既然以上中间子问题中存在着大量的重复计算，那么我们可以把这些中间结果给缓存住（可以用哈希表缓存），如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D; 2) return 2;</span><br><span class="line">    if (map.get(n) !&#x3D; null)  &#123;</span><br><span class="line">        return map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    int result &#x3D; fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">    map.put(n, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么缓存之后再看我们的递归树</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oHdzSDDribdT9TA3Diaq5IE9HROefumO2ibxhlYIBkVHvx4Sn5sUn7HAgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>可以看到通过缓存中间的数据，做了大量地剪枝的工作，同样的f(4),f(3),f(2)，都只算一遍了,省去了大量的重复计算，问题的规模从二叉树变成了单链表（即 n），时间复杂度变成了 O(n)，不过由于哈希表缓存了所有的子问题的结果，空间复杂度是 O(n)。</p>
<p>4、改用自底向上的方式来递推，即动态规划 我们注意到如下规律</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f(1) &#x3D; 1</span><br><span class="line">f(2) &#x3D; 2</span><br><span class="line">f(3) &#x3D; f(1) + f(2) &#x3D; 3</span><br><span class="line">f(4) &#x3D; f(3) + f(2) &#x3D; 5</span><br><span class="line">....</span><br><span class="line">f(n) &#x3D; f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure>

<p>所以只要依次自底向上求出 f(3),f(4),…,自然而然地就求出了 f(n)<img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oaH39dm92qeAbF4GfQvkGun4yZ1usYxW972sok2UVYXEpbNkNuPnVGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>画外音：从最终地不能再分解的子问题根据递推方程（f(n) = f(n-1) + f(n-2)）逐渐求它上层的问题，上上层问题，最终求得一开始的问题，这种求解问题的方式就叫自底向上。</em></p>
<p>f(n) 就是定义的每个子问题的状态（DP 状态），f(n) = f(n-1) + f(n-2) 就是状态转移方程，即 f(n) 由 f(n-1), f(n-2) 这两个状态转移而来,由于每个子问题只与它前面的两个状态，所以我们只要定义三个变量，自底向上不断循环迭代即可，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    int pre &#x3D; 1;</span><br><span class="line">    int next &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 3; i &lt; n + 1; i ++) &#123;</span><br><span class="line">        result &#x3D; pre + next;</span><br><span class="line">        pre &#x3D; next;</span><br><span class="line">        next &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样时间复杂度虽然还是O(n)，但空间复杂度只由于只定义了三个变量（result,pre,next）所以是常量 O(1)。</p>
<p>通过简单地斐波那契的/-8</p>
<p>例子，相信大家对自底向上，DP 状态， DP 转移方程应该有了比较深入地认识，细心的同学一定发现了最优子结构怎么没有，因为前面我们也说了，斐波那契数列并不是严格意义上的动态规划，只是先用这个简单地例子来帮助大家了解一下一些基本的概念。在之后的习题中我们将会见识到真正的动态规划</p>
<h3 id="小试牛刀：三角形的最小路径和"><a href="#小试牛刀：三角形的最小路径和" class="headerlink" title="小试牛刀：三角形的最小路径和"></a>小试牛刀：三角形的最小路径和</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oia3b9dEKWpwHujQEAJXBjkZmZeQuNeic9u4jUNAJaE8aTqECH4RoUyqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>如图示，以上三角形由一连串的数字构成，要求从顶点 2 开始走到最底下边的最短路径，每次只能向当前节点下面的两个节点走，如 3 可以向 6 或 5 走，不能直接走到 7。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oBjg161QyicjXPMIOolrZwhDASGgIiastU8g1GJMJOzTmqKicn4PxJmCAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示:从 2 走到最底下最短路径为  2+3+5+1 = 11,即为我们所求的</em></p>
<p>首先我们需要用一个二维数组来表示这个三个角形的节点，用二维数组显然可以做到， 第一行的 2 用 a[0][0] 表示，第二行元素 3, 4 用 a[1][0],a[1][1],依此类推。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oHot63ywXbx2gBsFXZh25oEXqib2sqDEk9rGkYjguc6pqQpJm9c02vVA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>定义好数据结构之后，接下来我们来看看如何套用我们的动态规划解题套路来解题</p>
<p>1、 判断是否可用递归来解</p>
<p>如果用递归，就要穷举所有的路径和，最后再求所有路径和的最小值，我们来看看用递归怎么做。</p>
<p>对于每个节点都可以走它的左或右节点，假设我们定义 traverse(i, j) 为节点 a[i][j] 下一步要走的节点，则可以得出递归公式的伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">traverse(i, j) &#x3D; &#123;</span><br><span class="line">    traverse(i+1, j);    向节点i,j 下面的左节点走一步</span><br><span class="line">    traverse(i+1, j+1);    向节点i,j 下面的右节点走一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候终止呢，显然是遍历到三角形最后一条边的节点时终止，发现了吗，对每个节点来说，在往下（无论是往左还是往右）遍历的过程中，问题规模不断地在缩小，也有临界条件（到达最后一条边的节点时终止），分解的子问题也有相同的解决问题的思路（对于每个节点的遍历都是往左或往右），符合递归的条件！于是我们得到递归代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">            &#123;2, 0, 0, 0&#125;,</span><br><span class="line">            &#123;3, 4, 0, 0&#125;,</span><br><span class="line">            &#123;6, 5, 7, 0&#125;,</span><br><span class="line">            &#123;4, 1, 8, 3&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public static int traverse(int i, int j) &#123;</span><br><span class="line">    int totalRow &#x3D; 4; &#x2F;&#x2F; 总行数</span><br><span class="line">    if (i &gt;&#x3D;  totalRow - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往左下节点走时</span><br><span class="line">    int leftSum &#x3D; traverse(i+1, j) + triangle[i+1][j];</span><br><span class="line">    &#x2F;&#x2F; 往右下节点走时</span><br><span class="line">    int rightSum &#x3D; traverse(i+1, j+1) + triangle[i+1][j+1];</span><br><span class="line">    &#x2F;&#x2F; 记录每个节点往左和往右遍历的路径和的最小值</span><br><span class="line">    return Math.min(leftSum, rightSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">    int sum &#x3D; traverse(0, 0) + triangle[0][0];</span><br><span class="line">    System.out.println(&quot;sum &#x3D; &quot; + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是多少呢，从以下伪代码可以看出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">traverse(i, j) &#x3D; &#123;</span><br><span class="line">    traverse(i+1, j);    向节点i,j 下面的左节点走一步</span><br><span class="line">    traverse(i+1, j+1);    向节点i,j 下面的右节点走一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个节点，要么向左或向右，每个问题都分解成了两个子问题，和斐波那契数列一样，如果画出递归树也是个二叉树，所以时间复杂度是 O(2^n),也是指数级别。</p>
<p>2、分析在递归的过程中是否存在大量的重复子问题</p>
<p>为啥时间复杂度是指数级别呢，我们简单分析一下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oy5ZYAPFibbVJ7tdaCIlVF412kVHXb7RK74vtwQ3nLtHr5ib9SX4zibFNw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>对于节点 3 和 4 来说，如果节点 3 往右遍历， 节点 4 往左遍历，都到了节点 5，节点 5 往下遍历的话就会遍历两次，所以此时就会出现重复子问题</p>
<p>3、采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</p>
<p>既然出现了，那我们就用备忘录把中间节点缓存下来</p>
<p>于是我们的代码改为如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">            &#123;2, 0, 0, 0&#125;,</span><br><span class="line">            &#123;3, 4, 0, 0&#125;,</span><br><span class="line">            &#123;6, 5, 7, 0&#125;,</span><br><span class="line">            &#123;4, 1, 8, 3&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 记录中间状态的 map</span><br><span class="line">private static HashMap&lt;String, Integer&gt; map &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">public static int traverse(int i, int j) &#123;</span><br><span class="line">    String key &#x3D; i + &quot;&quot; + j;</span><br><span class="line">    if (map.get(key) !&#x3D; null) &#123;</span><br><span class="line">        return map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int totalRow &#x3D; 4; &#x2F;&#x2F; 总行数</span><br><span class="line">    if (i &gt;&#x3D;  totalRow - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往左下节点走时</span><br><span class="line">    int leftSum &#x3D; traverse(i+1, j) + triangle[i+1][j];</span><br><span class="line">    &#x2F;&#x2F; 往右下节点走时</span><br><span class="line">    int rightSum &#x3D; traverse(i+1, j+1) + triangle[i+1][j+1];</span><br><span class="line">    &#x2F;&#x2F; 记录每个节点往左和往右遍历的路径和的最小值</span><br><span class="line">    int result &#x3D; Math.min(leftSum, rightSum);</span><br><span class="line">    map.put(key, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么一来，就达到了剪枝的目的，避免了重复子问题，时间复杂度一下子下降到 O(n), 空间复杂度呢，由于我们用哈希表存储了所有的节点的状态，所以空间复杂度是 O(n)。</p>
<p>4、改用自底向上的方式来递推，即动态规划</p>
<p>重点来了，如何采用自底向上的动态规划来解决问题呢? 我们这么来看，要求节点 2 到底部边的最短路径，只要先求得节点 3 和 节点 4 到底部的最短路径值，然后取这两者之中的最小值再加 2 不就是从 2 到底部的最短路径了吗，同理，要求节点 3 或 节点 4 到底部的最小值，只要求它们的左右节点到底部的最短路径再取两者的最小值再加节点本身的值（3 或 4）即可。</p>
<p>我们知道对于三角形的最后一层节点，它们到底部的最短路径就是其本身，于是问题转化为了已知最后一层节点的最小值怎么求倒数第二层到最开始的节点到底部的最小值了。先看倒数第二层到底部的最短路径怎么求</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oRo3tk4otRSrvFzKMibib3UoubqYQ6jOjQWuiaKgictXicckfnDWv06yYERQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>同理，第二层对于节点 3 ，它到最底层的最短路径转化为了 3 到 7， 6 节点的最短路径的最小值，即 9, 对于节点 4，它到最底层的最短路径转化为了 4 到 6， 10 的最短路径两者的最小值，即 10。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1ofLTlo7P4ju4Ft7d0e6DgiatWwx5uGibTm0zU55ia7XT9sfSueIEutl94Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>接下来要求 2 到底部的路径就很简单了，只要求 2 到节点 9 与 10 的最短路径即可，显然为 11。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1o4Vxc3Gd3z1SAndqD5wg8vhtc7O3DqlpAZ472S4ibVw7add06RXqRr0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>于是最终的 11 即为我们所求的值，接下来我们来看看怎么定义 DP 的状态与状态转移方程。 我们要求每个节点到底部的最短路径，于是 DP 状态 DP[i,j] 定义为 i,j 的节点到底部的最小值，DP状态转移方程定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DP[i,j] &#x3D; min(DP[i+1, j], D[i+1, j+1]) + triangle[i,j]</span><br></pre></td></tr></table></figure>

<p>这个状态转移方程代表要求节点到最底部节点的最短路径只需要求左右两个节点到最底部的最短路径两者的最小值再加此节点本身！仔细想想我们上面的推导过程是不是都是按这个状态转移方程推导的，实在不明白建议多看几遍上面的推导过程，相信不难明白。</p>
<p>DP 状态 DP[i,j] 有两个变量，需要分别从下而上，从左到右循环求出所有的 i,j, 有了状态转移方程求出代码就比较简单了，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">        &#123;2, 0, 0, 0&#125;,</span><br><span class="line">        &#123;3, 4, 0, 0&#125;,</span><br><span class="line">        &#123;6, 5, 7, 0&#125;,</span><br><span class="line">        &#123;4, 1, 8, 3&#125;</span><br><span class="line">&#125;;</span><br><span class="line">public static int traverse() &#123;</span><br><span class="line">    int ROW &#x3D; 4;</span><br><span class="line">    int[] mini &#x3D; triangle[ROW - 1];</span><br><span class="line">    &#x2F;&#x2F; 从倒数第二行求起，因为最后一行的值本身是固定的</span><br><span class="line">    for (int i &#x3D; ROW - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; triangle[j].length; j++) &#123;</span><br><span class="line">            mini[j] &#x3D; triangle[i][j] + Math.min(mini[j], mini[j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mini[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">    int minPathSum &#x3D; traverse();</span><br><span class="line">    System.out.println(&quot;sum &#x3D; &quot; + minPathSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有一些人对 mini 数组的定义有疑问，这里其实用了一个比较取巧的方式，首先我们定义 mini 的初始值为最后一行的节点，因为最后一行的每个节点的 DP[i,j] 是固定值，只要从倒数第二行求起即可，其次我们知道每个节点到底部的最短路径只与它下一层的 D[I+1,j], D[i+1, j] 有关，所以只要把每一层节点的 DP[i,j] 求出来保存到一个数组里即可，就是为啥我们只需要定义一下 mini 一维数组的原因</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oIU6kxhnnSsZuksqzQialuNjMavbu2eShp8E5rWpC63kqKC8jXySRQzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示：要求节点 2 到底部的最短路径，它只关心节点 9， 10，之前层数的节点无需再关心！因为 9，10 已经是最优子结构了，所以只保存每层节点（即一维数组）的最值即可！</em></p>
<p>当自下而上遍历完成了，mini[0] 的值即为 DP[0,0],即为节点 2 到 底部的最短路径。mini 的定义可能有点绕，大家可以多思考几遍，当然，你也可以定义一个二维数组来保存所有的 DP[i,j]，只不过多耗些空间罢了。</p>
<p>这里我们再来谈谈<strong>最优子结构</strong>，在以上的推导中我们知道每一层节点到底部的最短路径依赖于它下层的左右节点的最短路径，求得的下层两个节点的最短路径对于依赖于它们的节点来说就是<strong>最优子结构</strong>，最优子结构对于子问题来说属于全局最优解，这样我们不必去求节点到最底层的所有路径了，只需要依赖于它的最优子结构即可推导出我们所要求的最优解，所以最优子结构有两层含义，一是它是子问题的全局最优解，依赖于它的上层问题只要根据已求得的最优子结构推导求解即可得全局最优解，二是它有缓存的含义，这样就避免了多个依赖于它的问题的重复求解（消除重叠子问题）。</p>
<p>总结：仔细回想一下我们的解题思路，我们先看了本题是否可用递归来解，在递归的过程中发现了有重叠子问题，于是我们又用备忘录来消除递归中的重叠子问题，既然我们发现了此问题可以用递归+备忘录来求解，自然而然地想到它可以用自底向上的动态规划来求解。是的，求解动态规划就按这个套路来即可，最重要的是要找出它的状态转移方程，这需要在自下而上的推导中仔细观察。</p>
<h3 id="进阶：凑零钱"><a href="#进阶：凑零钱" class="headerlink" title="进阶：凑零钱"></a>进阶：凑零钱</h3><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 输入: coins = [1, 2, 5], amount = 11，输出: 3  解释: 11 = 5 + 5 + 1 输入: coins = [2], amount = 3，输出: -1</p>
</blockquote>
<p>来套用一下我们的动态规划解题四步曲</p>
<p><strong>一、判断是否可用递归来解</strong></p>
<p>对于 amount 来说，如果我们选择了 coins 中的任何一枚硬币，则问题的规模(amount)是不是缩小了,再对缩小的 amount 也选择 coins 中的任何一枚硬币,直到再也不能选择（amount &lt;= 0, amount = 0 代表有符合条件的解，小于0代表没有符合条件的解），从描述中我们可以看出问题可以分解成子问题，子问题与原问题具有相同的解决问题的思路，同时也有临界条件，符合递归的条件，由此可证可以用递归求解，接下来我们来看看，如何套用<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener">递归四步曲</a>来解题</p>
<p>1、定义这个函数，明确这个函数的功能,函数的功能显然是给定一个 amount，用定义好的 coins 来凑，于是我们定义函数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static int f(int amount, int[] coins) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、寻找问题与子问题的关系，即递推公式 这题的递推关系比较难推导，我们一起看下，假设 f(amount, coins) 为零钱 amount 的所需要的最少硬币数，当选中了coins 中的第一枚硬币之后（即为 coins[0]），则需再对剩余的 amount - coins[0] 金额求最少硬币数，即调用 f(amount - coins[0], coins)  ,由此可知当选了第一枚硬币后的递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(amount, coins) &#x3D; f(amount-coins[0]) + 1 (这里的 1 代表选择了第一枚硬币)</span><br></pre></td></tr></table></figure>

<p>如果选择了第二，第三枚呢，递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(amount, coins) &#x3D; f(amount-coins[1]) + 1 (这里的 1 代表选择了第二枚硬币)</span><br><span class="line">f(amount, coins) &#x3D; f(amount-coins[2]) + 1 (这里的 1 代表选择了第三枚硬币)</span><br></pre></td></tr></table></figure>

<p>我们的目标是求得所有以上 f(amount, coins) 解的的最小值，于是可以得到我们的总的递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(amount, coins) &#x3D; min&#123; f(amount - coins[i]) + 1) &#125;, 其中 i 的取值为 0 到 coins 的大小，coins[i] 表示选择了此硬币, 1 表示选择了coins[i]  这一枚硬币</span><br></pre></td></tr></table></figure>

<p>3、将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中</p>
<p>得出了递推公式用代码实现就简单了，来简单看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private static int exchange(int amount, int[] coins) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明零钱刚好凑完</span><br><span class="line">        if (amount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有满足的条件</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            int subMin &#x3D; exchange(amount - coins[i], coins);</span><br><span class="line">            if (subMin &#x3D;&#x3D; -1) continue;</span><br><span class="line">            result &#x3D; Math.min(subMin + 1, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有符合问题的解</span><br><span class="line">        if (result &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">        int amount &#x3D; 11;</span><br><span class="line">        int[] coins &#x3D; &#123;1,2,5&#125;;</span><br><span class="line">        int result &#x3D; exchange(amount, coins);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、计算时间复杂度 这道题的时间复杂度很难看出来，一般看不出来的时候我们可以画递归树来分析，针对 amount = 11 的递归树 如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1osIhg65Y6jKelL9nVjgSibPlC4icvGFkqNHiaBvB5YTK1cIkfB9ASiauJGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>前文我们说到斐波那契的递归树是一颗二叉树，时间复杂度是指数级别，而凑零钱的递归树是一颗三叉树 ，显然时间复杂度也是指数级别!</p>
<p><strong>二、分析在递归的过程中是否存在大量的重叠子问题（动态规划第二步）</strong></p>
<p>由上一节的递归树可知，存在重叠子问题，上一节中的 9， 8，都重复算了,所以存在重叠子问题！</p>
<p><strong>三、采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</strong></p>
<p>既然我们知道存在重叠子问题，那么就可以用备忘录来存储中间结果达到剪枝的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 保存中间结果</span><br><span class="line">    private static HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 带备忘录的递归求解</span><br><span class="line">    private static int exchangeRecursive(int amount, int[] coins) &#123;</span><br><span class="line">        if (map.get(amount) !&#x3D; null) &#123;</span><br><span class="line">            return map.get(amount);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 说明零钱已经凑完</span><br><span class="line">        if (amount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有满足的条件</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            int subMin &#x3D; exchangeRecursive(amount - coins[i], coins);</span><br><span class="line">            if (subMin &#x3D;&#x3D; -1) continue;</span><br><span class="line">            result &#x3D; Math.min(subMin + 1, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有符合问题的解</span><br><span class="line">        if (result &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(amount, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">        int amount &#x3D; 11;</span><br><span class="line">        int[] coins &#x3D; &#123;1,2,5&#125;;</span><br><span class="line">        int result &#x3D; exchangeRecursive(amount, coins);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四、改用自底向上的方式来递推，即动态规划</strong></p>
<p>前面我们推导出了如下递归公式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(amount, coins) &#x3D; min&#123; f(amount - coins[i]) + 1) &#125;, 其中 i 的取值为 0 到 coins 的大小，coins[i] 表示选择了此硬币, 1 表示选择了coins[i]  这一枚硬币</span><br></pre></td></tr></table></figure>

<p>从以上的递推公式中我们可以获取 DP 的解题思路，我们定义 DP(i) 为凑够零钱 i 需要的最小值，状态转移方程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DP[i] &#x3D;  min&#123; DP[ i - coins[j] ] + 1 &#125; &#x3D; min&#123; DP[ i - coins[j] ]&#125; + 1,  其中 j 的取值为 0 到 coins 的大小，i 代表取了 coins[j] 这一枚硬币。</span><br></pre></td></tr></table></figure>

<p>于是我们只要自底向上根据以上状态转移方程依次求解 DP[1], DP[2],DP[3].,….DP[11]，最终的 DP[11]，即为我们所求的解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态规划求解</span><br><span class="line">private static int exchangeDP(int amount, int[] coins) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[amount + 1];</span><br><span class="line">    &#x2F;&#x2F; 初始化每个值为 amount+1，这样当最终求得的 dp[amount] 为 amount+1 时，说明问题无解</span><br><span class="line">    for (int i &#x3D; 0; i &lt; amount + 1; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; amount + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 0 硬币本来就没有，所以设置成 0</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; amount + 1; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; coins.length; j++) &#123;</span><br><span class="line">            if (i &gt;&#x3D; coins[j]) &#123;</span><br><span class="line">                dp[i] &#x3D; Math.min(dp[i- coins[j]], dp[i]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dp[amount] &#x3D;&#x3D; amount + 1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>画外音：以上只是求出了凑成零钱的的最小数量，但如果想求由哪些面值的硬币构成的，该如何修改呢？</p>
<p>凑零钱这道题还可以用另外一道经典的青蛙跳台阶的思路来考虑，从最底部最少跳多少步可以跳到第 11 阶，一次可以跳 1，2，5步 。由此可知最后一步一定是跳 1 或 2 或 5 步，于是如果用 f(n) 代表跳台阶 n 的最小跳数，则问题转化为了求 f(n-1)，f(n-2) ，f(n-5)的最小值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oXsUknhWR5OkBffKQSRGk5iaufSiaX9dKGmO3L4lJagM5Q9DDqRBZAGkw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示：最后一跳一定是跳 1 或 2 或 5 步，只要求  f(n-1)，f(n-2) ，f(n-5)的最小值即可</em></p>
<p>写出递推表达式， 即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; min&#123; f(n-1)，f(n-2)，f(n-5)&#125; + 1 （1代表最后一跳）</span><br></pre></td></tr></table></figure>

<p>我们的 DP 状态转移方程对比一下，可以发现两者其实是等价的，只不过这种跳台阶的方式可能更容易理解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过几个简单的例子强化了大家动态规划的三要素：最优子结构，状态转移方程，重叠子问题的理解，相信大家对动态规划的理解应该深刻了许多，怎么看出是否可以用动态规划来解呢，先看题目是否可以用递归来推导，在用递归推导的过程如果发现有大量地重叠子问题，则有两种方式可以优化，一种是递归 + 备忘录，另一种就是采用动态规划了，动态规划一般是自下而上的， 通过状态转移方程自下而上的得出每个子问题的最优解（即最优子结构），最优子结构其实也是穷举了所有的情况得出的最优解，得出每个子问题的最优解后，也就是每个最优解其实是这个子问题的<strong>全局最优解</strong>，这样依赖于它的上层问题根据状态转移方程自然而然地得出了全局最优解。动态规划自下而上的求解方式还有一个好处就是避免了重叠子问题，因为依赖于子问题的上层问题可能有很多，如果采用自顶而下的方式来求解，就有可能造成大量的重叠子问题，时间复杂度会急剧上升。</p>
<p>参考： </p>
<p>动态规划详解： <a href="https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA</a></p>
<p>欢迎添加笔者微信交流哦</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU9gC99hDeLNlboZOHUEz1owLLD2OpEOZQsplZj1TeyqhCV0RUyUqel2Oy9BfpiawibzicvpXYTPDQRw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz_jpg/fHqxZcj5WRMPpKaZgAib5OUAwzia6vibZNIZOM7yFovPia1k4UVr8kqMovp7Sibebx33dAuBJh30fRsIP4ic5e1YJZ7A/0?wx_fmt=jpeg" alt="img"></p>
<p>码海</p>
<p>赞赏诚可贵，在看价更高</p>
<p><img src="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21&key=ba5643939c77c9dac1e103914fea899ec35916484235410891e12cb48be85774010bdc218ef860e4b1db4b2d30aa6b5c7de3285d2fcc316d95bce803ba617e3a1bb63830930894b74d67faa103b9d806&ascene=1&uin=MTg2Mjc2ODc1&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=ATA0YU%2BMGaQrlTj01b9mF9Q%3D&pass_ticket=8PQrfl2i9UflzIeNreLR7Nu73lDnVlTLk%2FD%2FBdm7udY%3D&winzoom=1" alt="赞赏二维码">)<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21&key=ba5643939c77c9dac1e103914fea899ec35916484235410891e12cb48be85774010bdc218ef860e4b1db4b2d30aa6b5c7de3285d2fcc316d95bce803ba617e3a1bb63830930894b74d67faa103b9d806&ascene=1&uin=MTg2Mjc2ODc1&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=ATA0YU%2BMGaQrlTj01b9mF9Q%3D&pass_ticket=8PQrfl2i9UflzIeNreLR7Nu73lDnVlTLk%2FD%2FBdm7udY%3D&winzoom=1##" target="_blank" rel="noopener">喜欢作者</a></p>
<p><a href="javascript:;">13</a> 人喜欢</p>
<p><img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM5agVKfunUFTs9Tuv1fvKjle8wmJHuv0k020a903D2okQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/ialqibzk8KFoKOAd5HnAKnLvicCZCCq8fzLmmKiafwbvEGM/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM7yfRs1VFoTbId5DKRWibeOZ9sRwib2PzUDEgUglcu1vYpg/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/rKBCaRcVshMH0ic1RQ4V8uzP1Z0szDLDGxcRA3z8kbXeXbvseRWY8tw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/LIND77SSex8ZqicVrRMfK6ryNhWN9DY5lHvHFnSf4micmhbnEjTYReBQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6aItiau00AS7TQnsYprP9cO5RFHEr99ZE2hgD2faTsucQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/PiajxSqBRaEKE0yMqibUYlXRI21tb7MicV5XOzTJ9wA17KHiaRmODlZ50w/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM5vBgys23lGvvCzYTF12Md6FMTM9MhKA2eLvdiaksJOYbg/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/PiajxSqBRaEKKPZg1mcmxWvwAnsIsXqImEYwUmFHibKbRgvAEzLYYU7g/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6QpLxsdKvdk3iaIGkTrSJzxnmAheibiadzQtcyGeAsIPOCw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/0nn3FBrD9a0kGOjmw514CXCBic5B4RjPmQ2qjgq4q4kbiaKPFdanvV4Q/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6cuM8XXlnebhmicSEHjZKCZwTEIC0gtQ0yicjYrdKkGsYw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/ChCs6YSVOGX48AOdnS0YcicoM0QePT80iaRa7gicaKjnGH2RnhjbszvqA/132" alt="img"></p>
<p>文章已于2020-02-17修改</p>
<p>阅读 2251</p>
<p> 在看51</p>
<p><img src="http://wx.qlogo.cn/mmopen/ajNVdqHZLLBOFc3SlxHl8SiaktwhbV86M3npkpic3p0UOBic8jG6ofkTYYkAkt8r03JH2ErTDpYoAfLe2XReXd2MQ/132" alt="img"></p>
<p>写下你的留言</p>
<p><strong>精选留言</strong></p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ09VoiciamsXIuCxp5OPLQMicnzxsxWaKMZscEfI3uWe0Hhej2KGckMgOXXBfVicev1ibvMMaCcv1fNlibJGlKvftB75cia/96" alt="img">)<strong>子非鱼(朋友)</strong>置顶</p>
<p> 9</p>
</li>
</ul>
<p>  订正 1.最后一段代码两层for循环里的dp[i] = Math.min(dp[i- coins[j]], dp[i]) + 1 改为  dp[i] = Math.min(dp[i- coins[j]]+1, dp[i])  2. 三角形问题的dp方法的第二层for循环的判断语句 triangle[j].length里的 j 应该改成 i</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ09VoiciamsXIuCxp5OPLQMicnzxsxWaKMZscEfI3uWe0Hhej2KGckMgOXXBfVicev1ibvMMaCcv1fNlibJGlKvftB75cia/96" alt="img">)<strong>子非鱼(朋友)</strong></p>
<p> 9</p>
</li>
</ul>
<p>  原创真心不容易，大家记得顺手点点在看，你们轻轻点一下，我能开心一整天！！！</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ict5LWgjrbsy2KfIib6ibXfxVIbu2DCSQaOoB1IoV9e6aqTwXlWvuHJJFgNIiboGR7W7L1kW46M4rJ7ky5AxaCaVDr/96" alt="img"><strong>张原</strong></p>
<p> 3</p>
</li>
</ul>
<p>  写得很深入，有理有节，一气呵成，从浅到深，看得出来花了不少功夫。</p>
<p>  作者</p>
<p>   3</p>
<p>  写了一周</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/Ku8HXXjjiaeCkcvpdGkRgEQZia6o6z9ibQcJ5f6WhQmycbQmO2icn2xxXKibsBb41ewqcZuiakiaFHGkApd3fMVnfNvmiaEgzmXTWMRo/96" alt="img"><strong>Mark.Zhang</strong></p>
<p> 2</p>
</li>
</ul>
<p>  请问大神内容是如何排版的，很好看！</p>
<p>  作者</p>
<p>  关于排版，翻一下历史记录，有一篇自我介绍的文章里有介绍哦</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkWVXxmibPGFQqkzneicQIhgLbDthmTvzWhiaStzQqianFWRIwhhQUftDNbIeE30BI7afh9ibXBDzsiacqI4BUicD3AQfTk/96" alt="img"><strong>晨晨nu_morninglovelight光</strong></p>
<p> 1</p>
</li>
</ul>
<p>  最近正在研究运输问题，这篇文章正好提供了思路。感谢大神的原创！</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDcktoRhvFoE5uV7ygPu7hFJmK4oYpBzcfI89iaZPq9tkqjCSictciaDeDnI6BtH0Jl1hSZa9ib1TiahwYkkciansic7EVTf/96" alt="img"><strong>LeoRambo.木子李</strong></li>
</ul>
<p>  没有Python版的代码解析吗？</p>
<p>  作者</p>
<p>   1</p>
<p>  目前没有，之后的算法会加上Python 版本,这篇文章的动态规划到时也会补上，不过文章不能改了，建议关注下 <a href="https://github.com/allentofight/algorithm" target="_blank" rel="noopener">https://github.com/allentofight/algorithm</a> 这个地址，到时会加上</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/dH8QVxmk2IXSGuH5ibZ4C7NCvhvodzRibicicB23Hb5ro8AwvjCL3kwc6oe2iaoPibbmoruVvHFF0dictAA5zD25DjXcA/96" alt="img"><strong>晴久🍩</strong></p>
<p> 1</p>
</li>
</ul>
<p>  真香！</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDcnXfmmSeOkR041UHaTbgm0cQGYeVaj2hcfLq4AMXLhYrltUo1FaYZpiciaQWDKpicxMctB0qmoIG417RyM9uJZDXx3/96" alt="img"><strong>轩辕之风</strong></p>
<p> 1</p>
</li>
</ul>
<p>  摩拜算法大侠</p>
<p>  作者</p>
<p>  共同进步</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkUYbgJricIeraiaia5WoHjZqBWgo8aclB0QFKOhpBqTICdZwEWSFZ7viaTabeRHKlWMbOBvpOWic8r1qib2uBGOkffOcic/96" alt="img"><strong>zenblo</strong></p>
<p> 1</p>
</li>
</ul>
<p>  写的真好，排版看的很舒服！收藏了</p>
<p>  作者</p>
<p>  多谢支持！</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkVtkaV2XenwQ0a2ibEe5vVCBuMdFVBH9CpMiauC8icxRIbVvGMd74RIweqfMC5VyjLHtOnfhaWbDU8HticcUCD7ricgz/96" alt="img"><strong>胡兴胜</strong></li>
</ul>
<p>  [[2, 0, 0, 0], [5, 4, 0, 0], [6, 5, 7, 0], [12, 3, 3, 3]] sum2: 12                                            加一行打印原数组，原数组最后一行变了</p>
<p>  作者</p>
<p>  大概明白你的意思，你应该是说原来mini指向的是最后一行，在不断修改中把最后一行给改了，但改了又有啥关系呢，不影响问题的求解吧，除非题目说不能修改原数组</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkVtkaV2XenwQ0a2ibEe5vVCBuMdFVBH9CpMiauC8icxRIbVvGMd74RIweqfMC5VyjLHtOnfhaWbDU8HticcUCD7ricgz/96" alt="img"><strong>胡兴胜</strong></li>
</ul>
<p>   非常精彩，请问一个问题：三角形最小路径和采用dp方式时，为什么原triangle数组发生了改变？[[92, 0, 0, 0], [94, 52, 0, 0], [24, 1, 74, 0], [60, 55, 56, 4]] –&gt;[[92, 0, 0, 0], [94, 52, 0, 0], [24, 1, 74, 0], [200, 4, 4, 4]],即最后一行的值换成了min[]数组了</p>
<p>  作者</p>
<p>  triangle没变，只是min数组一直在变，你是否看错了</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/Q3auHgzwzM4vf6HiaRRT1ibl1G0fesnUib3w2bcA8DWlTPuic4YHm2AtfVqxmK4XujyibjPuptqnpgib6ic8JHHA8PvSQ/96" alt="img"><strong>Tansir</strong></li>
</ul>
<p>  写得真好</p>
<p>  作者</p>
<p>  多谢支持</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ibz2Ollk38ubPwudDYBDw2lkxBsyVicS0kyhA2Gz2E1vAh35Bt50ayula9YxAKq8rllSFJ9D2rQuktq4crFXkzeb/96" alt="img"><strong>Zheng.</strong></li>
</ul>
<p>  作者辛苦了 看得我很过瘾 收获很多🌝</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/Ku8HXXjjiaeCkcvpdGkRgEVUXKW723zCEf2or9CYCAv1tDrqiaz1kyZZBhNSvlBJ411TjfsGTeOwoZ0ZZwiaiamGkcVAM4dIFibgE/96" alt="img"><strong>H[- -] ᒼ</strong></li>
</ul>
<p>  请问哪里有完整的source code呢</p>
<p>  作者</p>
<p>  你好， <a href="https://github.com/allentofight/algorithm" target="_blank" rel="noopener">https://github.com/allentofight/algorithm</a> 所有相关的代码都在这个地址上，这篇文章的代码这两天会更新哈，敬请关注哦</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkUiasONmCDSk5lDIsauSiaNlzGwrbr1XRATMOVGZqbayAXibAT0tt6dLam50IjHLW7NzDibI5SFTFRJHgsLpCvCMiaPw/96" alt="img"><strong>又要过年了🌚疯狂暗示</strong></li>
</ul>
<p>  666</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDclEbwE43hBwzsiaGAEtVPwySrpGtYsWeyXkKrWQknAKlmDy11oMyP2diaxElzIdtrOcbdIhicNKvM7mfastDTYiangr/96" alt="img"><strong>失火的夏天</strong></li>
</ul>
<p>  前天刚刚才玩了这个零钱</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkWMeB4Our7tXp3lROpe1tncuFjmnAnAqyXCFK7Zwtokgav6LM85NickchC4RJzIcwGWhO3p3BbmfzZYknyCzjur4/96" alt="img"><strong>why</strong></li>
</ul>
<p>  牛皮！沙发。</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ib93U81FtF1YPkYKuas2xWKiaYibxHcmu3fTrhgvn3OxgZibHm5ShoP6r4yRzNN2ATcQbH7icZDcaRx30NLxEvVeMrg/96" alt="img"><strong>大白</strong></li>
</ul>
<p>  强势收藏!</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E5%86%B3%E5%85%AB%E7%9A%87%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98/">位运算解决八皇后的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h1 id="位运算回溯法解决八皇后-N皇后-问题"><a href="#位运算回溯法解决八皇后-N皇后-问题" class="headerlink" title="位运算回溯法解决八皇后(N皇后)问题"></a>位运算回溯法解决八皇后(N皇后)问题</h1><h2 id="1-以下为背景"><a href="#1-以下为背景" class="headerlink" title="1. 以下为背景"></a>1. 以下为背景</h2><p>​        八皇后问题，一个古老而著名的问题，是<a href="https://baike.baidu.com/item/回溯算法/9258495" target="_blank" rel="noopener">回溯算法</a>的典型案例。该问题由国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的<a href="https://baike.baidu.com/item/国际象棋/80888" target="_blank" rel="noopener">国际象棋</a>上摆放八个<a href="https://baike.baidu.com/item/皇后/15860305" target="_blank" rel="noopener">皇后</a>，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<a href="https://baike.baidu.com/item/高斯/24098" target="_blank" rel="noopener">高斯</a>认为有 76 种方案。1854 年在柏林的象棋杂志上不同的作者发表了 40 种不同的解，后来有人用<a href="https://baike.baidu.com/item/图论/1433806" target="_blank" rel="noopener">图论</a>的方法解出 92 种结果。<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>发明后，有多种计算机语言可以编程解决此问题。</p>
<h2 id="2-传统的穷举法解决"><a href="#2-传统的穷举法解决" class="headerlink" title="2. 传统的穷举法解决"></a>2. 传统的穷举法解决</h2><p>​        八皇后问题如果用<a href="https://baike.baidu.com/item/穷举法/1431412" target="_blank" rel="noopener">穷举法</a>需要尝试 88 =16,777,216 种情况。每一列放一个<a href="https://baike.baidu.com/pic/八皇后问题/11053477/26857349/86d6277f9e2f070828387b62726caf99a9014c085432?fr=lemma&ct=cover" target="_blank" rel="noopener"><img src="https://bkimg.cdn.bcebos.com/pic/86d6277f9e2f070828387b62726caf99a9014c085432?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1" alt="八皇后问题">)八皇后问题(3张)</a> 皇后，可以放在第 1 行，第 2 行，……，直到第 8 行。穷举的时候从所有皇后都放在第 1 行的方案开始，检验皇后之间是否会相互攻击。如果会，把列 H 的皇后挪一格，验证下一个方案。移到底了就 “进位” 到列 G 的皇后挪一格，列 H 的皇后重新试过全部的 8 行。如图 1 所示，这种方法无疑是非常低效率的，因为它并不是哪里有冲突就调整哪里，而是盲目地按既定顺序枚举所有的可能方案。</p>
<p>​        此方法明显效率很低, 即使是现在计算机效率很高的情况下</p>
<h2 id="3-位运算解决"><a href="#3-位运算解决" class="headerlink" title="3. 位运算解决"></a>3. 位运算解决</h2><p>​        此方法是运用了二进制的特性,用一个n位的二进制来代表,可以在一行上进行查找,00000000为初始,当为11111111的时候查找结束,下一层摆放位置根据上一层的摆放位置来产生,每次都从最右侧找一个可以摆放的位置,摆放后将该位置从可摆放的位置中剔除,然后剔除该位置的左右对角线位置, 递归调用本方法进行下一层位置的摆放,</p>
<p>假如摆放完的位置不是11111111,而可摆放的位置又没有了,就会进行回溯,从新摆放上一层的位置, 当所有的位置都摆放完之后,sum(统计摆放完成的次数)+1,当完成所有的摆法之后,程序结束,</p>
<p>​        java代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaHuangHou</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>, upperlimit = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 纵列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ld 左斜线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rd 右斜线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> ld, <span class="keyword">int</span> rd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当row=11111111的时候，就是全部找完了。</span></span><br><span class="line">        <span class="keyword">if</span> (row != upperlimit) &#123;</span><br><span class="line">            <span class="comment">//找到该列的所以可以放的位置</span></span><br><span class="line">            <span class="keyword">int</span> pos = upperlimit &amp; ~(row | ld | rd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pos != <span class="number">0</span>)<span class="comment">//没有可摆放的位置,回溯</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//取出第一个可以放的位置，也就是最右边的1</span></span><br><span class="line">                <span class="keyword">int</span> p = pos &amp; -pos;</span><br><span class="line">                <span class="comment">//去除刚取出来的位置</span></span><br><span class="line">                pos -= p;</span><br><span class="line">                <span class="comment">//继续寻找,个个参数平移一位</span></span><br><span class="line">                compute(row + p, (ld + p) &lt;&lt; <span class="number">1</span>, (rd + p) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  sum++;<span class="comment">//种数自加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入皇后数字</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">14</span>;</span><br><span class="line">        <span class="comment">//设置开始时间</span></span><br><span class="line">        start = Calendar.getInstance();</span><br><span class="line">        <span class="comment">//保证数字在1到32之间，避免系统溢出</span></span><br><span class="line">        <span class="keyword">if</span> ((n &lt; <span class="number">1</span>) || (n &gt; <span class="number">32</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">" 只能计算1-32之间\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(n + <span class="string">" 皇后\n"</span>);</span><br><span class="line">        <span class="comment">//结束标志 uperlimti=255 转换为二进制就是11111111</span></span><br><span class="line">        upperlimit = (upperlimit &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从0，0，0开始</span></span><br><span class="line">        compute(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"共有"</span></span><br><span class="line">                + sum</span><br><span class="line">                + <span class="string">"种排列, 计算时间"</span></span><br><span class="line">                + (Calendar.getInstance().getTimeInMillis() - start</span><br><span class="line">                .getTimeInMillis()) / <span class="number">1000</span> + <span class="string">"秒 \n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">15</span> 皇后</span><br><span class="line"></span><br><span class="line">共有<span class="number">2279184</span>种排列, 计算时间<span class="number">2610</span>毫秒</span><br></pre></td></tr></table></figure>



<h2 id="4-go语言实现方法"><a href="#4-go语言实现方法" class="headerlink" title="4. go语言实现方法"></a>4. go语言实现方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   八皇后问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> upperlimit <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(row <span class="keyword">int</span>, ld <span class="keyword">int</span>, rd <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> row != upperlimit &#123;</span><br><span class="line">		pos := upperlimit &amp;^ (row | ld | rd)</span><br><span class="line">		<span class="keyword">for</span> pos != <span class="number">0</span> &#123; <span class="comment">//当没有可放置的位置,回溯</span></span><br><span class="line">			<span class="comment">//取出第一个可以放的位置,也就是最右边的1</span></span><br><span class="line">			p := pos &amp; - pos</span><br><span class="line">			pos -= p <span class="comment">//将取出的改位置删除</span></span><br><span class="line">			test(row+p, (ld+p)&lt;&lt;<span class="number">1</span>, (rd+p)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sum++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="comment">//指定皇后的数字以及棋盘的尺寸</span></span><br><span class="line">	n := <span class="number">8</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"请输入1到32中间的数"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	upperlimit = upperlimit&lt;&lt;n - <span class="number">1</span></span><br><span class="line">	test(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%v皇后,共有 %v 摆放方法 耗时 %v 毫秒"</span>,n,sum,time.Since(start)/<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">15</span>皇后,共有 <span class="number">2279184</span> 摆放方法 耗时 <span class="number">1.922809</span>ms 毫秒</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>总结,go和java的运行效率差距还是明显的</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/15/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/">云服务器的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-15</time><div class="content"><h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库 :"></a>数据库 :</h2><p>​        阿里云的数据库使用分为内网地址和外网地址,内网地址即阿里云业务内部访问的地址,外网就是之外的网络访问的地址,需要注意的是,外网的访问需要将访问者的<code>ip</code>地址添加进白名单中,而且这个<code>ip</code>不是局域网的<code>ip</code>而是针对外网的<code>ip</code>,通过百度搜索<code>ip</code>即可在首页看到.</p>
<p>​        阿里云的服务器使用也是遵循数据库的使用规则,区别就是需要在安全组里面定义外部可以访问的端口,添加的时候注意格式为(8080/8080),前缀就是该服务器的外网地址.</p>
<p>​        阿里云的<code>OSS</code>对象储存服务需要注意的是在添加<code>jar</code>包之后,新建工具类,可以将别人已经写好的工具类拿过来,需要注意的是将里面的四个参数更改为自己的<code>OSS</code>的参数,然后可能会出现一个jar包版本错误的问题,只需将这个jar包的版本改对即可</p>
<h3 id="部署系统和运行环境"><a href="#部署系统和运行环境" class="headerlink" title="部署系统和运行环境:"></a>部署系统和运行环境:</h3><p>将<code>linux</code>版本的JDK下载安装到云服务器中的文件夹中,可以借助工具,直接粘贴过去.然后配置系统的环境变量.</p>
<h4 id="配置linux的java环境变量"><a href="#配置linux的java环境变量" class="headerlink" title="配置linux的java环境变量 :"></a>配置<code>linux</code>的java环境变量 :</h4><p>本质是在/etc/profile文件的末尾加上环境变量的内容 :</p>
<p>JAVA_HOME=/home/jdk1.8.0_211<br>JRE_HOME=$JAVA_HOME/jre<br>CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib<br>PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</p>
<p>可以使用vim命令 :vim etc/profile来更改,或者直接打开该文件来更改</p>
<p>安装成功后可能会出现以下现象,因为权限不够,执行以下代码即可,/ 斜杠后面为jdk路径 :<br>chmod -R 755 /home/jdk1.8.0_211</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 丰之霸</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>