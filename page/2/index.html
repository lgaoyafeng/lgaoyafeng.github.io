<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="千里之行,始于足下" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-快速排序" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"
    >快速排序</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2020-05-15T01:43:38.174Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Quick2Sort</span><span class="params">(values []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(values) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mid, i := values[<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">	head, tail := <span class="number">0</span>, <span class="built_in">len</span>(values)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> head &lt; tail &#123;</span><br><span class="line">		fmt.Println(values)</span><br><span class="line">		<span class="keyword">if</span> values[i] &gt; mid &#123;</span><br><span class="line">			values[i], values[tail] = values[tail], values[i]</span><br><span class="line">			tail--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			values[i], values[head] = values[head], values[i]</span><br><span class="line">			head++</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	values[head] = mid</span><br><span class="line">	Quick2Sort(values[:head])</span><br><span class="line">	Quick2Sort(values[head+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        第一步,取排序数组的第一个元素values[0],然后从第二个元素遍历数组,将values[0]与该元素比较,如果大于values[0],就将其放到数组末尾(依次往前),否则放到前边(依次往后),直到两个指针相遇,然后将中间值与第一个数进行调换,然后以改值为中心将其分割为两个数组,继续递归调用该方法.</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="comment">//外层步长控制</span></span><br><span class="line">    <span class="keyword">for</span> step := <span class="built_in">len</span>(nums) / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//开始插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := step; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="comment">//满足条件则插入</span></span><br><span class="line">            <span class="keyword">for</span> j := i - step; j &gt;= <span class="number">0</span> &amp;&amp; nums[j+step] &lt; nums[j]; j -= step &#123;</span><br><span class="line">                nums[j], nums[j+step] = nums[j+step], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-岛屿数量" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"
    >岛屿数量</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/" class="article-date">
  <time datetime="2020-05-15T01:43:38.173Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>​        LeetCode(200)给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题是一个可以使用深度优先搜索(DFS),也可以使用广度优先搜索(BFS)的题,</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS:"></a>DFS:</h5><p> 顺序的从前往后遍历,当发现有元素为’1’时,将与该元素的相连的值为’1’的元素赋值为0,然后再递归的调用自身方法对该元素四周的元素进行搜索,如果有’1’也将其复制为’0’直到找到所有与原始’1’联系的1,继续遍历,再碰到1让计数++.</p>
<p>java代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                   sum++;</span><br><span class="line">                   dfs(grid, i, j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//递归将'1'旁边的'1'赋值为方法,</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>||i&gt;=na||j&gt;=nb|| grid[i][j]==<span class="string">'0'</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       grid[i][j]=<span class="string">'0'</span>;</span><br><span class="line">       dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">       dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">       dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">       dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>go代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> grid == <span class="literal">nil</span> || <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	na := <span class="built_in">len</span>(grid)</span><br><span class="line">	nb := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; na; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; nb; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> &#123;</span><br><span class="line">				sum++</span><br><span class="line">				dfs(grid, i, j)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(grid [][]<span class="keyword">byte</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	na := <span class="built_in">len</span>(grid)</span><br><span class="line">	nb := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= na || j &gt;= nb || grid[i][j] == <span class="string">'0'</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	grid[i][j] = <span class="string">'0'</span></span><br><span class="line">	dfs(grid, i+<span class="number">1</span>, j)</span><br><span class="line">	dfs(grid, i<span class="number">-1</span>, j)</span><br><span class="line">	dfs(grid, i, j+<span class="number">1</span>)</span><br><span class="line">	dfs(grid, i, j<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS:"></a>BFS:</h5><p> 其实就是把使用的递归的方法搜索改为使用栈进行搜索,但是通过对比执行效率效率下降不少,推荐还是使用递归,代码简洁,效率高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> na = grid.length;</span><br><span class="line">       <span class="keyword">int</span> nb = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; na; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nb; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                   sum++;</span><br><span class="line">                   grid[i][j]=<span class="number">0</span>;</span><br><span class="line">                   Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                   queue.add(nb * i + j);</span><br><span class="line">                   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                       Integer poll = queue.remove();</span><br><span class="line">                       <span class="keyword">int</span> row = poll / nb;</span><br><span class="line">                       <span class="keyword">int</span> col = poll % nb;</span><br><span class="line">                       <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nb &amp;&amp; grid[row][col + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row][col + <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col + <span class="number">1</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row][col - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col - <span class="number">1</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (row + <span class="number">1</span> &lt; na &amp;&amp; grid[row + <span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row + <span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col + nb);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row - <span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                           grid[row - <span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                           queue.add(row * nb + col - nb);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-参数值格式问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E5%8F%82%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"
    >参数值格式问题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E5%8F%82%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-05-15T01:43:38.172Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="Spring-Boot-jackson（Date类型入参、格式化，以及如何处理null）"><a href="#Spring-Boot-jackson（Date类型入参、格式化，以及如何处理null）" class="headerlink" title="Spring Boot jackson（Date类型入参、格式化，以及如何处理null）"></a>Spring Boot jackson（Date类型入参、格式化，以及如何处理null）</h1><blockquote>
<p>首先，我们要知道 springboot 默认使用 jackson 解析 json（当然这里也是可以配置使用其他 json 解析框架）。<br> 在不配置其他 json 解析的情况下，我们可以通过 spring boot 提供的注解和配置 来让 jackson 帮助我们提高开发效率</p>
</blockquote>
<h4 id="一、-使用-ResponseBody-RequestBody，-Date-类型对象入参，返回json格式化"><a href="#一、-使用-ResponseBody-RequestBody，-Date-类型对象入参，返回json格式化" class="headerlink" title="一、 使用 @ResponseBody @RequestBody， Date 类型对象入参，返回json格式化"></a>一、 使用 @ResponseBody @RequestBody， Date 类型对象入参，返回json格式化</h4><p><strong>解决方法如下:</strong></p>
<h5 id="1-application-properties中加入如下代码"><a href="#1-application-properties中加入如下代码" class="headerlink" title="1. application.properties中加入如下代码"></a>1. application.properties中加入如下代码</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.jackson.date-format=yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="string">spring.jackson.time-zone=GMT+8</span></span><br></pre></td></tr></table></figure>

<h5 id="2-如果个别实体需要使用其他格式的-pattern，在实体上加入注解即可"><a href="#2-如果个别实体需要使用其他格式的-pattern，在实体上加入注解即可" class="headerlink" title="2. 如果个别实体需要使用其他格式的 pattern，在实体上加入注解即可"></a>2. 如果个别实体需要使用其他格式的 pattern，在实体上加入注解即可</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.annotation.DateTimeFormat;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MrType</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonFormat</span>(timezone = <span class="string">"GMT+8"</span>,pattern = <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createdDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于spring boot 时间类型支持我做了以下测试：</p>
<ol>
<li>application.properties 配置注释，不添加注解：spring 无法接收时间参数（400），json 输出 <code>&quot;2018-03-29T09:45:31.513+0000&quot;</code></li>
<li>application.properties 配置开启，不添加注解：仅支持 <code>yyyy-MM-dd HH:mm:ss</code> 的格式参数和 json 输出</li>
<li>application.properties 配置开启，实体添加 <code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code>，实体可接受 <code>yyyy-MM-dd HH:mm:ss</code> 和 <code>yyyy-MM-dd</code> 格式的参数，json输出格式为 yyyy-MM-dd，由此可见@JsonFormat是限制Date 类型 json 输出的，但是为什么对接受的类型也造成了影响？有待考证</li>
<li>application.properties 配置开启，实体添加 <code>@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</code>，结果与第二条测试一样？貌似<code>@DateTimeFormat</code> 注解并没有生效？有待考证</li>
<li>application.properties 配置开启，实体添加 <code>@JsonFormat</code> 和 <code>@DateTimeFormat</code> 结果与第三条一样</li>
</ol>
<p>结论：实际项目中 application.properties设置通用时间格式，个别属性需要特殊处理时，添加<code>@JsonFormat</code><br> （<code>@JsonFormat</code> 自己好像就把这件事搞定了）</p>
<h4 id="二、-使用-ResponseBody-时-忽略-json-中值为null的属性"><a href="#二、-使用-ResponseBody-时-忽略-json-中值为null的属性" class="headerlink" title="二、 使用 @ResponseBody 时 忽略 json 中值为null的属性"></a>二、 使用 @ResponseBody 时 忽略 json 中值为null的属性</h4><h5 id="1-application-properties中加入如下代码-1"><a href="#1-application-properties中加入如下代码-1" class="headerlink" title="1. application.properties中加入如下代码"></a>1. application.properties中加入如下代码</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.jackson.default-property-inclusion=non-null</span></span><br></pre></td></tr></table></figure>

<p>或者在类上声明<br> @JsonInclude(JsonInclude.Include.NON_NULL)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_NULL)<span class="comment">//该注解配合jackson，序列化时忽略 null属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxResult</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-动态规划" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"
    >动态规划</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time datetime="2020-05-15T01:43:38.171Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="一文学会动态规划解题技巧"><a href="#一文学会动态规划解题技巧" class="headerlink" title="一文学会动态规划解题技巧"></a>一文学会动态规划解题技巧</h2><p>原创 码海 <a href="javascript:void(0);">码海</a> <em>2月16日</em></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态规划（dynamic programming，简称 dp)是工程中非常重要的解决问题的思想，从我们在工程中地图软件上应用的最短路径问题，再在生活中的在淘宝上如何凑单以便利用满减券来最大程度地达到我们合理薅羊毛的目的 ，很多时候都能看到它的身影。不过动态规划对初学者来说确实比较难，dp状态，状态转移方程让人摸不着头脑，网上很多人也反馈不太好学，其实就像我们之前学<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener">递归</a>那样，任何算法的学习都是有它的规律和套路的，只要掌握好它的规律及解题的套路，再加上大量的习题练习，相信掌握它不是什么难事，本文将会用比较浅显易懂地讲解来帮助大家掌握动态规划这一在工程中非常重要的思想，相信看完后，动态规划的解题套路一定能手到擒来（文章有点长，建议先收藏再看，看完后一定会对动态规划的认知上升到一个台阶！）</p>
<p>本文将会从以下角度来讲解动态规划：</p>
<ul>
<li>什么是动态规划</li>
<li>动态规划从入门到进阶</li>
<li>再谈动态规划</li>
</ul>
<h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>以下是我综合了动态规划的特点给出的动态规划的定义： 动态规划是一种<strong>多阶段决策</strong>最优解模型，一般用来求最值问题，多数情况下它可以采用<strong>自下而上</strong>的递推方式来得出每个子问题的最优解（即最优子结构），进而自然而然地得出依赖子问题的原问题的最优解。</p>
<p>划重点：</p>
<ol>
<li><strong>多阶段决策</strong>，意味着问题可以分解成子问题，子子问题，。。。，也就是说问题可以拆分成多个子问题进行求解</li>
<li><strong>最优子结构</strong>，在自下而上的递推过程中，我们求得的每个子问题一定是<strong>全局最优解</strong>，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。</li>
<li><strong>自下而上</strong>，怎样才能自下而上的求出每个子问题的最优解呢，可以肯定子问题之间是有一定联系的，即迭代递推公式，也叫「状态转移方程」，要定义好这个状态转移方程， 我们就需要定义好每个子问题的状态（DP 状态），那为啥要自下而上地求解呢，因为如果采用像递归这样自顶向下的求解方式，子问题之间可能存在大量的重叠，大量地重叠子问题意味着大量地重复计算，这样时间复杂度很可能呈指数级上升（在下文中我们会看到多个这样重复的计算导致的指数级的时间复杂度），所以自下而上的求解方式可以消除重叠子问题。</li>
</ol>
<p>简单总结一下，最优子结构，状态转移方程，重叠子问题就是动态规划的三要素，这其中定义子问题的状态与写出状态转移方程是解决动态规划最为关键的步骤，状态转移方程如果定义好了，解决动态规划就基本不是问题了。</p>
<p>既然我们知道动态规划的基本概念及特征，那么怎么判断题目是否可以用动态规划求解呢，其实也很简单，当问题的定义是求最值问题，且问题可以采用递归的方式，并且递归的过程中有大量重复子问题的时候，基本可以断定问题可以用动态规划求解，于是我们得出了求解动态规划基本思路如下（解题四步曲）</p>
<ol>
<li>判断是否可用递归来解，可以的话进入步骤 2</li>
<li>分析在递归的过程中是否存在大量的重复子问题</li>
<li>采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</li>
<li>改用自底向上的方式来递推，即动态规划</li>
</ol>
<p><em>画外音：递归怎么求解，强烈建议看下</em><a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener"><em>这篇文章</em></a><em>，好评如潮,总结了常见的递归解题套路</em></p>
<p>可能不少人看了以上的动态规划的一些介绍还是对一些定义如 DP 状态，状态转移方程，自底而上不了解，没关系 ，接下来我们会做几道习题来强化一下大家对这些概念及动态规划解题四步曲的理解，每道题我们都会分别用递归，递归+备忘录，动态规划来求解一遍，这样也进一步帮助大家来巩固我们之前学的递归知识</p>
<h2 id="动态规划从入门到进阶"><a href="#动态规划从入门到进阶" class="headerlink" title="动态规划从入门到进阶"></a>动态规划从入门到进阶</h2><h3 id="入门题：斐波那契数列"><a href="#入门题：斐波那契数列" class="headerlink" title="入门题：斐波那契数列"></a>入门题：斐波那契数列</h3><p>接下来我们来看看怎么用动态规划解题四步曲来解斐波那契数列</p>
<p><em>画外音：斐波那契数列并不是严格意义上的动态规划，因为它不涉及到求最值，用这个例子旨在说明重叠子问题与状态转移方程</em></p>
<p>1、判断是否可用递归来解 显然是可以的，递归代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static int fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、分析在递归的过程中是否存在大量的重复子问题</p>
<p>怎么分析是否有重复子问题，画出递归树</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oCuTibzC3FxUSav02sSSqvfDW394sXP61vRUMc9WZBPsA2v0ponl450A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>可以看到光是求 f(6)，就有两次重复的计算， f(4) 求解了两次，f(3) 求解了两次，时间复杂度是指数级别，递归时间复杂度怎么看，解决每个子问题需要的时间乘以子问题总数，每个子问题需要的时间即 f(n) = f(n-1) + f(n-2) 只做了一次加法运算，子问题的个数有多少呢，每个问题一分为二,是个二叉树，可以看到第一层 1 个，第二层 2 个，第三层 4 个，即 1 + 2 + 2^2 + …. 2^n，所以总的来说时间复杂度是)O(2^n),是指数级别</p>
<p><em>画外音：求解问题 f(6),转成求 f(5),f(4),从原问题出发，分解成求子问题，子问题再分解成子子问题，。。。，直到再也不能分解，这种从 原问题展开子问题进行求解的方式叫自顶向下</em></p>
<p>3、采用备忘录的方式来存子问题的解以避免大量的重复计算 既然以上中间子问题中存在着大量的重复计算，那么我们可以把这些中间结果给缓存住（可以用哈希表缓存），如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D; 2) return 2;</span><br><span class="line">    if (map.get(n) !&#x3D; null)  &#123;</span><br><span class="line">        return map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    int result &#x3D; fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">    map.put(n, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么缓存之后再看我们的递归树</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oHdzSDDribdT9TA3Diaq5IE9HROefumO2ibxhlYIBkVHvx4Sn5sUn7HAgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>可以看到通过缓存中间的数据，做了大量地剪枝的工作，同样的f(4),f(3),f(2)，都只算一遍了,省去了大量的重复计算，问题的规模从二叉树变成了单链表（即 n），时间复杂度变成了 O(n)，不过由于哈希表缓存了所有的子问题的结果，空间复杂度是 O(n)。</p>
<p>4、改用自底向上的方式来递推，即动态规划 我们注意到如下规律</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f(1) &#x3D; 1</span><br><span class="line">f(2) &#x3D; 2</span><br><span class="line">f(3) &#x3D; f(1) + f(2) &#x3D; 3</span><br><span class="line">f(4) &#x3D; f(3) + f(2) &#x3D; 5</span><br><span class="line">....</span><br><span class="line">f(n) &#x3D; f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure>

<p>所以只要依次自底向上求出 f(3),f(4),…,自然而然地就求出了 f(n)<img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oaH39dm92qeAbF4GfQvkGun4yZ1usYxW972sok2UVYXEpbNkNuPnVGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>画外音：从最终地不能再分解的子问题根据递推方程（f(n) = f(n-1) + f(n-2)）逐渐求它上层的问题，上上层问题，最终求得一开始的问题，这种求解问题的方式就叫自底向上。</em></p>
<p>f(n) 就是定义的每个子问题的状态（DP 状态），f(n) = f(n-1) + f(n-2) 就是状态转移方程，即 f(n) 由 f(n-1), f(n-2) 这两个状态转移而来,由于每个子问题只与它前面的两个状态，所以我们只要定义三个变量，自底向上不断循环迭代即可，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    int pre &#x3D; 1;</span><br><span class="line">    int next &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 3; i &lt; n + 1; i ++) &#123;</span><br><span class="line">        result &#x3D; pre + next;</span><br><span class="line">        pre &#x3D; next;</span><br><span class="line">        next &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样时间复杂度虽然还是O(n)，但空间复杂度只由于只定义了三个变量（result,pre,next）所以是常量 O(1)。</p>
<p>通过简单地斐波那契的/-8</p>
<p>例子，相信大家对自底向上，DP 状态， DP 转移方程应该有了比较深入地认识，细心的同学一定发现了最优子结构怎么没有，因为前面我们也说了，斐波那契数列并不是严格意义上的动态规划，只是先用这个简单地例子来帮助大家了解一下一些基本的概念。在之后的习题中我们将会见识到真正的动态规划</p>
<h3 id="小试牛刀：三角形的最小路径和"><a href="#小试牛刀：三角形的最小路径和" class="headerlink" title="小试牛刀：三角形的最小路径和"></a>小试牛刀：三角形的最小路径和</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oia3b9dEKWpwHujQEAJXBjkZmZeQuNeic9u4jUNAJaE8aTqECH4RoUyqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>如图示，以上三角形由一连串的数字构成，要求从顶点 2 开始走到最底下边的最短路径，每次只能向当前节点下面的两个节点走，如 3 可以向 6 或 5 走，不能直接走到 7。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oBjg161QyicjXPMIOolrZwhDASGgIiastU8g1GJMJOzTmqKicn4PxJmCAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示:从 2 走到最底下最短路径为  2+3+5+1 = 11,即为我们所求的</em></p>
<p>首先我们需要用一个二维数组来表示这个三个角形的节点，用二维数组显然可以做到， 第一行的 2 用 a[0][0] 表示，第二行元素 3, 4 用 a[1][0],a[1][1],依此类推。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oHot63ywXbx2gBsFXZh25oEXqib2sqDEk9rGkYjguc6pqQpJm9c02vVA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>定义好数据结构之后，接下来我们来看看如何套用我们的动态规划解题套路来解题</p>
<p>1、 判断是否可用递归来解</p>
<p>如果用递归，就要穷举所有的路径和，最后再求所有路径和的最小值，我们来看看用递归怎么做。</p>
<p>对于每个节点都可以走它的左或右节点，假设我们定义 traverse(i, j) 为节点 a[i][j] 下一步要走的节点，则可以得出递归公式的伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">traverse(i, j) &#x3D; &#123;</span><br><span class="line">    traverse(i+1, j);    向节点i,j 下面的左节点走一步</span><br><span class="line">    traverse(i+1, j+1);    向节点i,j 下面的右节点走一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候终止呢，显然是遍历到三角形最后一条边的节点时终止，发现了吗，对每个节点来说，在往下（无论是往左还是往右）遍历的过程中，问题规模不断地在缩小，也有临界条件（到达最后一条边的节点时终止），分解的子问题也有相同的解决问题的思路（对于每个节点的遍历都是往左或往右），符合递归的条件！于是我们得到递归代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">            &#123;2, 0, 0, 0&#125;,</span><br><span class="line">            &#123;3, 4, 0, 0&#125;,</span><br><span class="line">            &#123;6, 5, 7, 0&#125;,</span><br><span class="line">            &#123;4, 1, 8, 3&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public static int traverse(int i, int j) &#123;</span><br><span class="line">    int totalRow &#x3D; 4; &#x2F;&#x2F; 总行数</span><br><span class="line">    if (i &gt;&#x3D;  totalRow - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往左下节点走时</span><br><span class="line">    int leftSum &#x3D; traverse(i+1, j) + triangle[i+1][j];</span><br><span class="line">    &#x2F;&#x2F; 往右下节点走时</span><br><span class="line">    int rightSum &#x3D; traverse(i+1, j+1) + triangle[i+1][j+1];</span><br><span class="line">    &#x2F;&#x2F; 记录每个节点往左和往右遍历的路径和的最小值</span><br><span class="line">    return Math.min(leftSum, rightSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">    int sum &#x3D; traverse(0, 0) + triangle[0][0];</span><br><span class="line">    System.out.println(&quot;sum &#x3D; &quot; + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是多少呢，从以下伪代码可以看出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">traverse(i, j) &#x3D; &#123;</span><br><span class="line">    traverse(i+1, j);    向节点i,j 下面的左节点走一步</span><br><span class="line">    traverse(i+1, j+1);    向节点i,j 下面的右节点走一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个节点，要么向左或向右，每个问题都分解成了两个子问题，和斐波那契数列一样，如果画出递归树也是个二叉树，所以时间复杂度是 O(2^n),也是指数级别。</p>
<p>2、分析在递归的过程中是否存在大量的重复子问题</p>
<p>为啥时间复杂度是指数级别呢，我们简单分析一下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oy5ZYAPFibbVJ7tdaCIlVF412kVHXb7RK74vtwQ3nLtHr5ib9SX4zibFNw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>对于节点 3 和 4 来说，如果节点 3 往右遍历， 节点 4 往左遍历，都到了节点 5，节点 5 往下遍历的话就会遍历两次，所以此时就会出现重复子问题</p>
<p>3、采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</p>
<p>既然出现了，那我们就用备忘录把中间节点缓存下来</p>
<p>于是我们的代码改为如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">            &#123;2, 0, 0, 0&#125;,</span><br><span class="line">            &#123;3, 4, 0, 0&#125;,</span><br><span class="line">            &#123;6, 5, 7, 0&#125;,</span><br><span class="line">            &#123;4, 1, 8, 3&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 记录中间状态的 map</span><br><span class="line">private static HashMap&lt;String, Integer&gt; map &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">public static int traverse(int i, int j) &#123;</span><br><span class="line">    String key &#x3D; i + &quot;&quot; + j;</span><br><span class="line">    if (map.get(key) !&#x3D; null) &#123;</span><br><span class="line">        return map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int totalRow &#x3D; 4; &#x2F;&#x2F; 总行数</span><br><span class="line">    if (i &gt;&#x3D;  totalRow - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往左下节点走时</span><br><span class="line">    int leftSum &#x3D; traverse(i+1, j) + triangle[i+1][j];</span><br><span class="line">    &#x2F;&#x2F; 往右下节点走时</span><br><span class="line">    int rightSum &#x3D; traverse(i+1, j+1) + triangle[i+1][j+1];</span><br><span class="line">    &#x2F;&#x2F; 记录每个节点往左和往右遍历的路径和的最小值</span><br><span class="line">    int result &#x3D; Math.min(leftSum, rightSum);</span><br><span class="line">    map.put(key, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么一来，就达到了剪枝的目的，避免了重复子问题，时间复杂度一下子下降到 O(n), 空间复杂度呢，由于我们用哈希表存储了所有的节点的状态，所以空间复杂度是 O(n)。</p>
<p>4、改用自底向上的方式来递推，即动态规划</p>
<p>重点来了，如何采用自底向上的动态规划来解决问题呢? 我们这么来看，要求节点 2 到底部边的最短路径，只要先求得节点 3 和 节点 4 到底部的最短路径值，然后取这两者之中的最小值再加 2 不就是从 2 到底部的最短路径了吗，同理，要求节点 3 或 节点 4 到底部的最小值，只要求它们的左右节点到底部的最短路径再取两者的最小值再加节点本身的值（3 或 4）即可。</p>
<p>我们知道对于三角形的最后一层节点，它们到底部的最短路径就是其本身，于是问题转化为了已知最后一层节点的最小值怎么求倒数第二层到最开始的节点到底部的最小值了。先看倒数第二层到底部的最短路径怎么求</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oRo3tk4otRSrvFzKMibib3UoubqYQ6jOjQWuiaKgictXicckfnDWv06yYERQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>同理，第二层对于节点 3 ，它到最底层的最短路径转化为了 3 到 7， 6 节点的最短路径的最小值，即 9, 对于节点 4，它到最底层的最短路径转化为了 4 到 6， 10 的最短路径两者的最小值，即 10。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1ofLTlo7P4ju4Ft7d0e6DgiatWwx5uGibTm0zU55ia7XT9sfSueIEutl94Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>接下来要求 2 到底部的路径就很简单了，只要求 2 到节点 9 与 10 的最短路径即可，显然为 11。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1o4Vxc3Gd3z1SAndqD5wg8vhtc7O3DqlpAZ472S4ibVw7add06RXqRr0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>于是最终的 11 即为我们所求的值，接下来我们来看看怎么定义 DP 的状态与状态转移方程。 我们要求每个节点到底部的最短路径，于是 DP 状态 DP[i,j] 定义为 i,j 的节点到底部的最小值，DP状态转移方程定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DP[i,j] &#x3D; min(DP[i+1, j], D[i+1, j+1]) + triangle[i,j]</span><br></pre></td></tr></table></figure>

<p>这个状态转移方程代表要求节点到最底部节点的最短路径只需要求左右两个节点到最底部的最短路径两者的最小值再加此节点本身！仔细想想我们上面的推导过程是不是都是按这个状态转移方程推导的，实在不明白建议多看几遍上面的推导过程，相信不难明白。</p>
<p>DP 状态 DP[i,j] 有两个变量，需要分别从下而上，从左到右循环求出所有的 i,j, 有了状态转移方程求出代码就比较简单了，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static int[][] triangle &#x3D; &#123;</span><br><span class="line">        &#123;2, 0, 0, 0&#125;,</span><br><span class="line">        &#123;3, 4, 0, 0&#125;,</span><br><span class="line">        &#123;6, 5, 7, 0&#125;,</span><br><span class="line">        &#123;4, 1, 8, 3&#125;</span><br><span class="line">&#125;;</span><br><span class="line">public static int traverse() &#123;</span><br><span class="line">    int ROW &#x3D; 4;</span><br><span class="line">    int[] mini &#x3D; triangle[ROW - 1];</span><br><span class="line">    &#x2F;&#x2F; 从倒数第二行求起，因为最后一行的值本身是固定的</span><br><span class="line">    for (int i &#x3D; ROW - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; triangle[j].length; j++) &#123;</span><br><span class="line">            mini[j] &#x3D; triangle[i][j] + Math.min(mini[j], mini[j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mini[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">    int minPathSum &#x3D; traverse();</span><br><span class="line">    System.out.println(&quot;sum &#x3D; &quot; + minPathSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有一些人对 mini 数组的定义有疑问，这里其实用了一个比较取巧的方式，首先我们定义 mini 的初始值为最后一行的节点，因为最后一行的每个节点的 DP[i,j] 是固定值，只要从倒数第二行求起即可，其次我们知道每个节点到底部的最短路径只与它下一层的 D[I+1,j], D[i+1, j] 有关，所以只要把每一层节点的 DP[i,j] 求出来保存到一个数组里即可，就是为啥我们只需要定义一下 mini 一维数组的原因</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oIU6kxhnnSsZuksqzQialuNjMavbu2eShp8E5rWpC63kqKC8jXySRQzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示：要求节点 2 到底部的最短路径，它只关心节点 9， 10，之前层数的节点无需再关心！因为 9，10 已经是最优子结构了，所以只保存每层节点（即一维数组）的最值即可！</em></p>
<p>当自下而上遍历完成了，mini[0] 的值即为 DP[0,0],即为节点 2 到 底部的最短路径。mini 的定义可能有点绕，大家可以多思考几遍，当然，你也可以定义一个二维数组来保存所有的 DP[i,j]，只不过多耗些空间罢了。</p>
<p>这里我们再来谈谈<strong>最优子结构</strong>，在以上的推导中我们知道每一层节点到底部的最短路径依赖于它下层的左右节点的最短路径，求得的下层两个节点的最短路径对于依赖于它们的节点来说就是<strong>最优子结构</strong>，最优子结构对于子问题来说属于全局最优解，这样我们不必去求节点到最底层的所有路径了，只需要依赖于它的最优子结构即可推导出我们所要求的最优解，所以最优子结构有两层含义，一是它是子问题的全局最优解，依赖于它的上层问题只要根据已求得的最优子结构推导求解即可得全局最优解，二是它有缓存的含义，这样就避免了多个依赖于它的问题的重复求解（消除重叠子问题）。</p>
<p>总结：仔细回想一下我们的解题思路，我们先看了本题是否可用递归来解，在递归的过程中发现了有重叠子问题，于是我们又用备忘录来消除递归中的重叠子问题，既然我们发现了此问题可以用递归+备忘录来求解，自然而然地想到它可以用自底向上的动态规划来求解。是的，求解动态规划就按这个套路来即可，最重要的是要找出它的状态转移方程，这需要在自下而上的推导中仔细观察。</p>
<h3 id="进阶：凑零钱"><a href="#进阶：凑零钱" class="headerlink" title="进阶：凑零钱"></a>进阶：凑零钱</h3><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 输入: coins = [1, 2, 5], amount = 11，输出: 3  解释: 11 = 5 + 5 + 1 输入: coins = [2], amount = 3，输出: -1</p>
</blockquote>
<p>来套用一下我们的动态规划解题四步曲</p>
<p><strong>一、判断是否可用递归来解</strong></p>
<p>对于 amount 来说，如果我们选择了 coins 中的任何一枚硬币，则问题的规模(amount)是不是缩小了,再对缩小的 amount 也选择 coins 中的任何一枚硬币,直到再也不能选择（amount &lt;= 0, amount = 0 代表有符合条件的解，小于0代表没有符合条件的解），从描述中我们可以看出问题可以分解成子问题，子问题与原问题具有相同的解决问题的思路，同时也有临界条件，符合递归的条件，由此可证可以用递归求解，接下来我们来看看，如何套用<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener">递归四步曲</a>来解题</p>
<p>1、定义这个函数，明确这个函数的功能,函数的功能显然是给定一个 amount，用定义好的 coins 来凑，于是我们定义函数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static int f(int amount, int[] coins) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、寻找问题与子问题的关系，即递推公式 这题的递推关系比较难推导，我们一起看下，假设 f(amount, coins) 为零钱 amount 的所需要的最少硬币数，当选中了coins 中的第一枚硬币之后（即为 coins[0]），则需再对剩余的 amount - coins[0] 金额求最少硬币数，即调用 f(amount - coins[0], coins)  ,由此可知当选了第一枚硬币后的递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(amount, coins) &#x3D; f(amount-coins[0]) + 1 (这里的 1 代表选择了第一枚硬币)</span><br></pre></td></tr></table></figure>

<p>如果选择了第二，第三枚呢，递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(amount, coins) &#x3D; f(amount-coins[1]) + 1 (这里的 1 代表选择了第二枚硬币)</span><br><span class="line">f(amount, coins) &#x3D; f(amount-coins[2]) + 1 (这里的 1 代表选择了第三枚硬币)</span><br></pre></td></tr></table></figure>

<p>我们的目标是求得所有以上 f(amount, coins) 解的的最小值，于是可以得到我们的总的递推公式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(amount, coins) &#x3D; min&#123; f(amount - coins[i]) + 1) &#125;, 其中 i 的取值为 0 到 coins 的大小，coins[i] 表示选择了此硬币, 1 表示选择了coins[i]  这一枚硬币</span><br></pre></td></tr></table></figure>

<p>3、将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中</p>
<p>得出了递推公式用代码实现就简单了，来简单看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    private static int exchange(int amount, int[] coins) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明零钱刚好凑完</span><br><span class="line">        if (amount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有满足的条件</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            int subMin &#x3D; exchange(amount - coins[i], coins);</span><br><span class="line">            if (subMin &#x3D;&#x3D; -1) continue;</span><br><span class="line">            result &#x3D; Math.min(subMin + 1, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有符合问题的解</span><br><span class="line">        if (result &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">        int amount &#x3D; 11;</span><br><span class="line">        int[] coins &#x3D; &#123;1,2,5&#125;;</span><br><span class="line">        int result &#x3D; exchange(amount, coins);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、计算时间复杂度 这道题的时间复杂度很难看出来，一般看不出来的时候我们可以画递归树来分析，针对 amount = 11 的递归树 如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1osIhg65Y6jKelL9nVjgSibPlC4icvGFkqNHiaBvB5YTK1cIkfB9ASiauJGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>前文我们说到斐波那契的递归树是一颗二叉树，时间复杂度是指数级别，而凑零钱的递归树是一颗三叉树 ，显然时间复杂度也是指数级别!</p>
<p><strong>二、分析在递归的过程中是否存在大量的重叠子问题（动态规划第二步）</strong></p>
<p>由上一节的递归树可知，存在重叠子问题，上一节中的 9， 8，都重复算了,所以存在重叠子问题！</p>
<p><strong>三、采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</strong></p>
<p>既然我们知道存在重叠子问题，那么就可以用备忘录来存储中间结果达到剪枝的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 保存中间结果</span><br><span class="line">    private static HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 带备忘录的递归求解</span><br><span class="line">    private static int exchangeRecursive(int amount, int[] coins) &#123;</span><br><span class="line">        if (map.get(amount) !&#x3D; null) &#123;</span><br><span class="line">            return map.get(amount);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 说明零钱已经凑完</span><br><span class="line">        if (amount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有满足的条件</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;</span><br><span class="line">            int subMin &#x3D; exchangeRecursive(amount - coins[i], coins);</span><br><span class="line">            if (subMin &#x3D;&#x3D; -1) continue;</span><br><span class="line">            result &#x3D; Math.min(subMin + 1, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 说明没有符合问题的解</span><br><span class="line">        if (result &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(amount, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args)  throws Throwable &#123;</span><br><span class="line">        int amount &#x3D; 11;</span><br><span class="line">        int[] coins &#x3D; &#123;1,2,5&#125;;</span><br><span class="line">        int result &#x3D; exchangeRecursive(amount, coins);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四、改用自底向上的方式来递推，即动态规划</strong></p>
<p>前面我们推导出了如下递归公式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(amount, coins) &#x3D; min&#123; f(amount - coins[i]) + 1) &#125;, 其中 i 的取值为 0 到 coins 的大小，coins[i] 表示选择了此硬币, 1 表示选择了coins[i]  这一枚硬币</span><br></pre></td></tr></table></figure>

<p>从以上的递推公式中我们可以获取 DP 的解题思路，我们定义 DP(i) 为凑够零钱 i 需要的最小值，状态转移方程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DP[i] &#x3D;  min&#123; DP[ i - coins[j] ] + 1 &#125; &#x3D; min&#123; DP[ i - coins[j] ]&#125; + 1,  其中 j 的取值为 0 到 coins 的大小，i 代表取了 coins[j] 这一枚硬币。</span><br></pre></td></tr></table></figure>

<p>于是我们只要自底向上根据以上状态转移方程依次求解 DP[1], DP[2],DP[3].,….DP[11]，最终的 DP[11]，即为我们所求的解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态规划求解</span><br><span class="line">private static int exchangeDP(int amount, int[] coins) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[amount + 1];</span><br><span class="line">    &#x2F;&#x2F; 初始化每个值为 amount+1，这样当最终求得的 dp[amount] 为 amount+1 时，说明问题无解</span><br><span class="line">    for (int i &#x3D; 0; i &lt; amount + 1; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; amount + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 0 硬币本来就没有，所以设置成 0</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; amount + 1; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; coins.length; j++) &#123;</span><br><span class="line">            if (i &gt;&#x3D; coins[j]) &#123;</span><br><span class="line">                dp[i] &#x3D; Math.min(dp[i- coins[j]], dp[i]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dp[amount] &#x3D;&#x3D; amount + 1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>画外音：以上只是求出了凑成零钱的的最小数量，但如果想求由哪些面值的硬币构成的，该如何修改呢？</p>
<p>凑零钱这道题还可以用另外一道经典的青蛙跳台阶的思路来考虑，从最底部最少跳多少步可以跳到第 11 阶，一次可以跳 1，2，5步 。由此可知最后一步一定是跳 1 或 2 或 5 步，于是如果用 f(n) 代表跳台阶 n 的最小跳数，则问题转化为了求 f(n-1)，f(n-2) ，f(n-5)的最小值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLU9gC99hDeLNlboZOHUEz1oXsUknhWR5OkBffKQSRGk5iaufSiaX9dKGmO3L4lJagM5Q9DDqRBZAGkw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><em>如图示：最后一跳一定是跳 1 或 2 或 5 步，只要求  f(n-1)，f(n-2) ，f(n-5)的最小值即可</em></p>
<p>写出递推表达式， 即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; min&#123; f(n-1)，f(n-2)，f(n-5)&#125; + 1 （1代表最后一跳）</span><br></pre></td></tr></table></figure>

<p>我们的 DP 状态转移方程对比一下，可以发现两者其实是等价的，只不过这种跳台阶的方式可能更容易理解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过几个简单的例子强化了大家动态规划的三要素：最优子结构，状态转移方程，重叠子问题的理解，相信大家对动态规划的理解应该深刻了许多，怎么看出是否可以用动态规划来解呢，先看题目是否可以用递归来推导，在用递归推导的过程如果发现有大量地重叠子问题，则有两种方式可以优化，一种是递归 + 备忘录，另一种就是采用动态规划了，动态规划一般是自下而上的， 通过状态转移方程自下而上的得出每个子问题的最优解（即最优子结构），最优子结构其实也是穷举了所有的情况得出的最优解，得出每个子问题的最优解后，也就是每个最优解其实是这个子问题的<strong>全局最优解</strong>，这样依赖于它的上层问题根据状态转移方程自然而然地得出了全局最优解。动态规划自下而上的求解方式还有一个好处就是避免了重叠子问题，因为依赖于子问题的上层问题可能有很多，如果采用自顶而下的方式来求解，就有可能造成大量的重叠子问题，时间复杂度会急剧上升。</p>
<p>参考： </p>
<p>动态规划详解： <a href="https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA</a></p>
<p>欢迎添加笔者微信交流哦</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLU9gC99hDeLNlboZOHUEz1owLLD2OpEOZQsplZj1TeyqhCV0RUyUqel2Oy9BfpiawibzicvpXYTPDQRw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz_jpg/fHqxZcj5WRMPpKaZgAib5OUAwzia6vibZNIZOM7yFovPia1k4UVr8kqMovp7Sibebx33dAuBJh30fRsIP4ic5e1YJZ7A/0?wx_fmt=jpeg" alt="img"></p>
<p>码海</p>
<p>赞赏诚可贵，在看价更高</p>
<p><img src="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21&key=ba5643939c77c9dac1e103914fea899ec35916484235410891e12cb48be85774010bdc218ef860e4b1db4b2d30aa6b5c7de3285d2fcc316d95bce803ba617e3a1bb63830930894b74d67faa103b9d806&ascene=1&uin=MTg2Mjc2ODc1&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=ATA0YU%2BMGaQrlTj01b9mF9Q%3D&pass_ticket=8PQrfl2i9UflzIeNreLR7Nu73lDnVlTLk%2FD%2FBdm7udY%3D&winzoom=1" alt="赞赏二维码">)<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21&key=ba5643939c77c9dac1e103914fea899ec35916484235410891e12cb48be85774010bdc218ef860e4b1db4b2d30aa6b5c7de3285d2fcc316d95bce803ba617e3a1bb63830930894b74d67faa103b9d806&ascene=1&uin=MTg2Mjc2ODc1&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=ATA0YU%2BMGaQrlTj01b9mF9Q%3D&pass_ticket=8PQrfl2i9UflzIeNreLR7Nu73lDnVlTLk%2FD%2FBdm7udY%3D&winzoom=1##" target="_blank" rel="noopener">喜欢作者</a></p>
<p><a href="javascript:;">13</a> 人喜欢</p>
<p><img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM5agVKfunUFTs9Tuv1fvKjle8wmJHuv0k020a903D2okQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/ialqibzk8KFoKOAd5HnAKnLvicCZCCq8fzLmmKiafwbvEGM/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM7yfRs1VFoTbId5DKRWibeOZ9sRwib2PzUDEgUglcu1vYpg/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/rKBCaRcVshMH0ic1RQ4V8uzP1Z0szDLDGxcRA3z8kbXeXbvseRWY8tw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/LIND77SSex8ZqicVrRMfK6ryNhWN9DY5lHvHFnSf4micmhbnEjTYReBQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6aItiau00AS7TQnsYprP9cO5RFHEr99ZE2hgD2faTsucQ/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/PiajxSqBRaEKE0yMqibUYlXRI21tb7MicV5XOzTJ9wA17KHiaRmODlZ50w/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM5vBgys23lGvvCzYTF12Md6FMTM9MhKA2eLvdiaksJOYbg/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/PiajxSqBRaEKKPZg1mcmxWvwAnsIsXqImEYwUmFHibKbRgvAEzLYYU7g/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6QpLxsdKvdk3iaIGkTrSJzxnmAheibiadzQtcyGeAsIPOCw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/0nn3FBrD9a0kGOjmw514CXCBic5B4RjPmQ2qjgq4q4kbiaKPFdanvV4Q/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6cuM8XXlnebhmicSEHjZKCZwTEIC0gtQ0yicjYrdKkGsYw/132" alt="img">)<img src="http://wx.qlogo.cn/mmhead/ChCs6YSVOGX48AOdnS0YcicoM0QePT80iaRa7gicaKjnGH2RnhjbszvqA/132" alt="img"></p>
<p>文章已于2020-02-17修改</p>
<p>阅读 2251</p>
<p> 在看51</p>
<p><img src="http://wx.qlogo.cn/mmopen/ajNVdqHZLLBOFc3SlxHl8SiaktwhbV86M3npkpic3p0UOBic8jG6ofkTYYkAkt8r03JH2ErTDpYoAfLe2XReXd2MQ/132" alt="img"></p>
<p>写下你的留言</p>
<p><strong>精选留言</strong></p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ09VoiciamsXIuCxp5OPLQMicnzxsxWaKMZscEfI3uWe0Hhej2KGckMgOXXBfVicev1ibvMMaCcv1fNlibJGlKvftB75cia/96" alt="img">)<strong>子非鱼(朋友)</strong>置顶</p>
<p> 9</p>
</li>
</ul>
<p>  订正 1.最后一段代码两层for循环里的dp[i] = Math.min(dp[i- coins[j]], dp[i]) + 1 改为  dp[i] = Math.min(dp[i- coins[j]]+1, dp[i])  2. 三角形问题的dp方法的第二层for循环的判断语句 triangle[j].length里的 j 应该改成 i</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ09VoiciamsXIuCxp5OPLQMicnzxsxWaKMZscEfI3uWe0Hhej2KGckMgOXXBfVicev1ibvMMaCcv1fNlibJGlKvftB75cia/96" alt="img">)<strong>子非鱼(朋友)</strong></p>
<p> 9</p>
</li>
</ul>
<p>  原创真心不容易，大家记得顺手点点在看，你们轻轻点一下，我能开心一整天！！！</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ict5LWgjrbsy2KfIib6ibXfxVIbu2DCSQaOoB1IoV9e6aqTwXlWvuHJJFgNIiboGR7W7L1kW46M4rJ7ky5AxaCaVDr/96" alt="img"><strong>张原</strong></p>
<p> 3</p>
</li>
</ul>
<p>  写得很深入，有理有节，一气呵成，从浅到深，看得出来花了不少功夫。</p>
<p>  作者</p>
<p>   3</p>
<p>  写了一周</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/Ku8HXXjjiaeCkcvpdGkRgEQZia6o6z9ibQcJ5f6WhQmycbQmO2icn2xxXKibsBb41ewqcZuiakiaFHGkApd3fMVnfNvmiaEgzmXTWMRo/96" alt="img"><strong>Mark.Zhang</strong></p>
<p> 2</p>
</li>
</ul>
<p>  请问大神内容是如何排版的，很好看！</p>
<p>  作者</p>
<p>  关于排版，翻一下历史记录，有一篇自我介绍的文章里有介绍哦</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkWVXxmibPGFQqkzneicQIhgLbDthmTvzWhiaStzQqianFWRIwhhQUftDNbIeE30BI7afh9ibXBDzsiacqI4BUicD3AQfTk/96" alt="img"><strong>晨晨nu_morninglovelight光</strong></p>
<p> 1</p>
</li>
</ul>
<p>  最近正在研究运输问题，这篇文章正好提供了思路。感谢大神的原创！</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDcktoRhvFoE5uV7ygPu7hFJmK4oYpBzcfI89iaZPq9tkqjCSictciaDeDnI6BtH0Jl1hSZa9ib1TiahwYkkciansic7EVTf/96" alt="img"><strong>LeoRambo.木子李</strong></li>
</ul>
<p>  没有Python版的代码解析吗？</p>
<p>  作者</p>
<p>   1</p>
<p>  目前没有，之后的算法会加上Python 版本,这篇文章的动态规划到时也会补上，不过文章不能改了，建议关注下 <a href="https://github.com/allentofight/algorithm" target="_blank" rel="noopener">https://github.com/allentofight/algorithm</a> 这个地址，到时会加上</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/dH8QVxmk2IXSGuH5ibZ4C7NCvhvodzRibicicB23Hb5ro8AwvjCL3kwc6oe2iaoPibbmoruVvHFF0dictAA5zD25DjXcA/96" alt="img"><strong>晴久🍩</strong></p>
<p> 1</p>
</li>
</ul>
<p>  真香！</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDcnXfmmSeOkR041UHaTbgm0cQGYeVaj2hcfLq4AMXLhYrltUo1FaYZpiciaQWDKpicxMctB0qmoIG417RyM9uJZDXx3/96" alt="img"><strong>轩辕之风</strong></p>
<p> 1</p>
</li>
</ul>
<p>  摩拜算法大侠</p>
<p>  作者</p>
<p>  共同进步</p>
<ul>
<li><p><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkUYbgJricIeraiaia5WoHjZqBWgo8aclB0QFKOhpBqTICdZwEWSFZ7viaTabeRHKlWMbOBvpOWic8r1qib2uBGOkffOcic/96" alt="img"><strong>zenblo</strong></p>
<p> 1</p>
</li>
</ul>
<p>  写的真好，排版看的很舒服！收藏了</p>
<p>  作者</p>
<p>  多谢支持！</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkVtkaV2XenwQ0a2ibEe5vVCBuMdFVBH9CpMiauC8icxRIbVvGMd74RIweqfMC5VyjLHtOnfhaWbDU8HticcUCD7ricgz/96" alt="img"><strong>胡兴胜</strong></li>
</ul>
<p>  [[2, 0, 0, 0], [5, 4, 0, 0], [6, 5, 7, 0], [12, 3, 3, 3]] sum2: 12                                            加一行打印原数组，原数组最后一行变了</p>
<p>  作者</p>
<p>  大概明白你的意思，你应该是说原来mini指向的是最后一行，在不断修改中把最后一行给改了，但改了又有啥关系呢，不影响问题的求解吧，除非题目说不能修改原数组</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkVtkaV2XenwQ0a2ibEe5vVCBuMdFVBH9CpMiauC8icxRIbVvGMd74RIweqfMC5VyjLHtOnfhaWbDU8HticcUCD7ricgz/96" alt="img"><strong>胡兴胜</strong></li>
</ul>
<p>   非常精彩，请问一个问题：三角形最小路径和采用dp方式时，为什么原triangle数组发生了改变？[[92, 0, 0, 0], [94, 52, 0, 0], [24, 1, 74, 0], [60, 55, 56, 4]] –&gt;[[92, 0, 0, 0], [94, 52, 0, 0], [24, 1, 74, 0], [200, 4, 4, 4]],即最后一行的值换成了min[]数组了</p>
<p>  作者</p>
<p>  triangle没变，只是min数组一直在变，你是否看错了</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/Q3auHgzwzM4vf6HiaRRT1ibl1G0fesnUib3w2bcA8DWlTPuic4YHm2AtfVqxmK4XujyibjPuptqnpgib6ic8JHHA8PvSQ/96" alt="img"><strong>Tansir</strong></li>
</ul>
<p>  写得真好</p>
<p>  作者</p>
<p>  多谢支持</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ibz2Ollk38ubPwudDYBDw2lkxBsyVicS0kyhA2Gz2E1vAh35Bt50ayula9YxAKq8rllSFJ9D2rQuktq4crFXkzeb/96" alt="img"><strong>Zheng.</strong></li>
</ul>
<p>  作者辛苦了 看得我很过瘾 收获很多🌝</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/Ku8HXXjjiaeCkcvpdGkRgEVUXKW723zCEf2or9CYCAv1tDrqiaz1kyZZBhNSvlBJ411TjfsGTeOwoZ0ZZwiaiamGkcVAM4dIFibgE/96" alt="img"><strong>H[- -] ᒼ</strong></li>
</ul>
<p>  请问哪里有完整的source code呢</p>
<p>  作者</p>
<p>  你好， <a href="https://github.com/allentofight/algorithm" target="_blank" rel="noopener">https://github.com/allentofight/algorithm</a> 所有相关的代码都在这个地址上，这篇文章的代码这两天会更新哈，敬请关注哦</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkUiasONmCDSk5lDIsauSiaNlzGwrbr1XRATMOVGZqbayAXibAT0tt6dLam50IjHLW7NzDibI5SFTFRJHgsLpCvCMiaPw/96" alt="img"><strong>又要过年了🌚疯狂暗示</strong></li>
</ul>
<p>  666</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/QfQd6oIDDclEbwE43hBwzsiaGAEtVPwySrpGtYsWeyXkKrWQknAKlmDy11oMyP2diaxElzIdtrOcbdIhicNKvM7mfastDTYiangr/96" alt="img"><strong>失火的夏天</strong></li>
</ul>
<p>  前天刚刚才玩了这个零钱</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/q2vicicoSCkkWMeB4Our7tXp3lROpe1tncuFjmnAnAqyXCFK7Zwtokgav6LM85NickchC4RJzIcwGWhO3p3BbmfzZYknyCzjur4/96" alt="img"><strong>why</strong></li>
</ul>
<p>  牛皮！沙发。</p>
<ul>
<li><img src="http://wx.qlogo.cn/mmopen/pBhOGFpZZ0ib93U81FtF1YPkYKuas2xWKiaYibxHcmu3fTrhgvn3OxgZibHm5ShoP6r4yRzNN2ATcQbH7icZDcaRx30NLxEvVeMrg/96" alt="img"><strong>大白</strong></li>
</ul>
<p>  强势收藏!</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-位运算解决八皇后的问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E5%86%B3%E5%85%AB%E7%9A%87%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98/"
    >位运算解决八皇后的问题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E5%86%B3%E5%85%AB%E7%9A%87%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-05-15T01:43:38.170Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="位运算回溯法解决八皇后-N皇后-问题"><a href="#位运算回溯法解决八皇后-N皇后-问题" class="headerlink" title="位运算回溯法解决八皇后(N皇后)问题"></a>位运算回溯法解决八皇后(N皇后)问题</h1><h2 id="1-以下为背景"><a href="#1-以下为背景" class="headerlink" title="1. 以下为背景"></a>1. 以下为背景</h2><p>​        八皇后问题，一个古老而著名的问题，是<a href="https://baike.baidu.com/item/回溯算法/9258495" target="_blank" rel="noopener">回溯算法</a>的典型案例。该问题由国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的<a href="https://baike.baidu.com/item/国际象棋/80888" target="_blank" rel="noopener">国际象棋</a>上摆放八个<a href="https://baike.baidu.com/item/皇后/15860305" target="_blank" rel="noopener">皇后</a>，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<a href="https://baike.baidu.com/item/高斯/24098" target="_blank" rel="noopener">高斯</a>认为有 76 种方案。1854 年在柏林的象棋杂志上不同的作者发表了 40 种不同的解，后来有人用<a href="https://baike.baidu.com/item/图论/1433806" target="_blank" rel="noopener">图论</a>的方法解出 92 种结果。<a href="https://baike.baidu.com/item/计算机/140338" target="_blank" rel="noopener">计算机</a>发明后，有多种计算机语言可以编程解决此问题。</p>
<h2 id="2-传统的穷举法解决"><a href="#2-传统的穷举法解决" class="headerlink" title="2. 传统的穷举法解决"></a>2. 传统的穷举法解决</h2><p>​        八皇后问题如果用<a href="https://baike.baidu.com/item/穷举法/1431412" target="_blank" rel="noopener">穷举法</a>需要尝试 88 =16,777,216 种情况。每一列放一个<a href="https://baike.baidu.com/pic/八皇后问题/11053477/26857349/86d6277f9e2f070828387b62726caf99a9014c085432?fr=lemma&ct=cover" target="_blank" rel="noopener"><img src="https://bkimg.cdn.bcebos.com/pic/86d6277f9e2f070828387b62726caf99a9014c085432?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1" alt="八皇后问题">)八皇后问题(3张)</a> 皇后，可以放在第 1 行，第 2 行，……，直到第 8 行。穷举的时候从所有皇后都放在第 1 行的方案开始，检验皇后之间是否会相互攻击。如果会，把列 H 的皇后挪一格，验证下一个方案。移到底了就 “进位” 到列 G 的皇后挪一格，列 H 的皇后重新试过全部的 8 行。如图 1 所示，这种方法无疑是非常低效率的，因为它并不是哪里有冲突就调整哪里，而是盲目地按既定顺序枚举所有的可能方案。</p>
<p>​        此方法明显效率很低, 即使是现在计算机效率很高的情况下</p>
<h2 id="3-位运算解决"><a href="#3-位运算解决" class="headerlink" title="3. 位运算解决"></a>3. 位运算解决</h2><p>​        此方法是运用了二进制的特性,用一个n位的二进制来代表,可以在一行上进行查找,00000000为初始,当为11111111的时候查找结束,下一层摆放位置根据上一层的摆放位置来产生,每次都从最右侧找一个可以摆放的位置,摆放后将该位置从可摆放的位置中剔除,然后剔除该位置的左右对角线位置, 递归调用本方法进行下一层位置的摆放,</p>
<p>假如摆放完的位置不是11111111,而可摆放的位置又没有了,就会进行回溯,从新摆放上一层的位置, 当所有的位置都摆放完之后,sum(统计摆放完成的次数)+1,当完成所有的摆法之后,程序结束,</p>
<p>​        java代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaHuangHou</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>, upperlimit = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 纵列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ld 左斜线</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rd 右斜线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> ld, <span class="keyword">int</span> rd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当row=11111111的时候，就是全部找完了。</span></span><br><span class="line">        <span class="keyword">if</span> (row != upperlimit) &#123;</span><br><span class="line">            <span class="comment">//找到该列的所以可以放的位置</span></span><br><span class="line">            <span class="keyword">int</span> pos = upperlimit &amp; ~(row | ld | rd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pos != <span class="number">0</span>)<span class="comment">//没有可摆放的位置,回溯</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//取出第一个可以放的位置，也就是最右边的1</span></span><br><span class="line">                <span class="keyword">int</span> p = pos &amp; -pos;</span><br><span class="line">                <span class="comment">//去除刚取出来的位置</span></span><br><span class="line">                pos -= p;</span><br><span class="line">                <span class="comment">//继续寻找,个个参数平移一位</span></span><br><span class="line">                compute(row + p, (ld + p) &lt;&lt; <span class="number">1</span>, (rd + p) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  sum++;<span class="comment">//种数自加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入皇后数字</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">14</span>;</span><br><span class="line">        <span class="comment">//设置开始时间</span></span><br><span class="line">        start = Calendar.getInstance();</span><br><span class="line">        <span class="comment">//保证数字在1到32之间，避免系统溢出</span></span><br><span class="line">        <span class="keyword">if</span> ((n &lt; <span class="number">1</span>) || (n &gt; <span class="number">32</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">" 只能计算1-32之间\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(n + <span class="string">" 皇后\n"</span>);</span><br><span class="line">        <span class="comment">//结束标志 uperlimti=255 转换为二进制就是11111111</span></span><br><span class="line">        upperlimit = (upperlimit &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从0，0，0开始</span></span><br><span class="line">        compute(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"共有"</span></span><br><span class="line">                + sum</span><br><span class="line">                + <span class="string">"种排列, 计算时间"</span></span><br><span class="line">                + (Calendar.getInstance().getTimeInMillis() - start</span><br><span class="line">                .getTimeInMillis()) / <span class="number">1000</span> + <span class="string">"秒 \n"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">15</span> 皇后</span><br><span class="line"></span><br><span class="line">共有<span class="number">2279184</span>种排列, 计算时间<span class="number">2610</span>毫秒</span><br></pre></td></tr></table></figure>



<h2 id="4-go语言实现方法"><a href="#4-go语言实现方法" class="headerlink" title="4. go语言实现方法"></a>4. go语言实现方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   八皇后问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> upperlimit <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(row <span class="keyword">int</span>, ld <span class="keyword">int</span>, rd <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> row != upperlimit &#123;</span><br><span class="line">		pos := upperlimit &amp;^ (row | ld | rd)</span><br><span class="line">		<span class="keyword">for</span> pos != <span class="number">0</span> &#123; <span class="comment">//当没有可放置的位置,回溯</span></span><br><span class="line">			<span class="comment">//取出第一个可以放的位置,也就是最右边的1</span></span><br><span class="line">			p := pos &amp; - pos</span><br><span class="line">			pos -= p <span class="comment">//将取出的改位置删除</span></span><br><span class="line">			test(row+p, (ld+p)&lt;&lt;<span class="number">1</span>, (rd+p)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sum++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="comment">//指定皇后的数字以及棋盘的尺寸</span></span><br><span class="line">	n := <span class="number">8</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"请输入1到32中间的数"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	upperlimit = upperlimit&lt;&lt;n - <span class="number">1</span></span><br><span class="line">	test(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%v皇后,共有 %v 摆放方法 耗时 %v 毫秒"</span>,n,sum,time.Since(start)/<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">15</span>皇后,共有 <span class="number">2279184</span> 摆放方法 耗时 <span class="number">1.922809</span>ms 毫秒</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>总结,go和java的运行效率差距还是明显的</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-云服务器的使用" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"
    >云服务器的使用</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2020-05-15T01:43:38.169Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库 :"></a>数据库 :</h2><p>​        阿里云的数据库使用分为内网地址和外网地址,内网地址即阿里云业务内部访问的地址,外网就是之外的网络访问的地址,需要注意的是,外网的访问需要将访问者的<code>ip</code>地址添加进白名单中,而且这个<code>ip</code>不是局域网的<code>ip</code>而是针对外网的<code>ip</code>,通过百度搜索<code>ip</code>即可在首页看到.</p>
<p>​        阿里云的服务器使用也是遵循数据库的使用规则,区别就是需要在安全组里面定义外部可以访问的端口,添加的时候注意格式为(8080/8080),前缀就是该服务器的外网地址.</p>
<p>​        阿里云的<code>OSS</code>对象储存服务需要注意的是在添加<code>jar</code>包之后,新建工具类,可以将别人已经写好的工具类拿过来,需要注意的是将里面的四个参数更改为自己的<code>OSS</code>的参数,然后可能会出现一个jar包版本错误的问题,只需将这个jar包的版本改对即可</p>
<h3 id="部署系统和运行环境"><a href="#部署系统和运行环境" class="headerlink" title="部署系统和运行环境:"></a>部署系统和运行环境:</h3><p>将<code>linux</code>版本的JDK下载安装到云服务器中的文件夹中,可以借助工具,直接粘贴过去.然后配置系统的环境变量.</p>
<h4 id="配置linux的java环境变量"><a href="#配置linux的java环境变量" class="headerlink" title="配置linux的java环境变量 :"></a>配置<code>linux</code>的java环境变量 :</h4><p>本质是在/etc/profile文件的末尾加上环境变量的内容 :</p>
<p>JAVA_HOME=/home/jdk1.8.0_211<br>JRE_HOME=$JAVA_HOME/jre<br>CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib<br>PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</p>
<p>可以使用vim命令 :vim etc/profile来更改,或者直接打开该文件来更改</p>
<p>安装成功后可能会出现以下现象,因为权限不够,执行以下代码即可,/ 斜杠后面为jdk路径 :<br>chmod -R 755 /home/jdk1.8.0_211</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-二叉堆以及堆排序" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E4%BA%8C%E5%8F%89%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/"
    >二叉堆以及堆排序</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E4%BA%8C%E5%8F%89%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2020-05-15T01:43:38.168Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="1-二叉堆"><a href="#1-二叉堆" class="headerlink" title="1. 二叉堆"></a>1. 二叉堆</h1><h3 id="什么是二叉堆"><a href="#什么是二叉堆" class="headerlink" title="什么是二叉堆"></a>什么是二叉堆</h3><p>二叉堆本质上是一种完全二叉树, 它分为两个类型</p>
<ul>
<li>最大堆</li>
<li>最小堆</li>
</ul>
<p>最大堆: 堆的每一个父节点都大于或等于他的左子节点和右子节点</p>
<p>最小堆: 堆的每一个父节点都小于或等于他的左子节点和右子节点</p>
<p>​        二叉堆的根节点叫做堆顶, 最大堆和最小堆的特性决定了,最大堆的顶点是整个堆中元素的最大值,最小堆的顶点是整个堆中元素的最小值</p>
<h3 id="二叉堆的自我调整"><a href="#二叉堆的自我调整" class="headerlink" title="二叉堆的自我调整"></a>二叉堆的自我调整</h3><p>​        二叉堆的几种操作</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>构建二叉堆</li>
</ul>
<p>​        这几种操作都是基于堆的自我调整, 就是把一个不符合堆性质的完全二叉堆, 调整成一个堆, 下面让我们已最小堆为例, 看一个二叉堆是如何调整的</p>
<ol>
<li><p>插入节点</p>
<p>​    当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个 新节点，值是 0。这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节点“上 浮”，和父节点交换位置。继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。继续比较，最终新节点0“上浮”到了堆顶位置。</p>
</li>
<li><p>删除节点</p>
<p>​        二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节 点。例如删除最小堆的堆顶节点1。这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到 原本堆顶的位置。接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果左、右孩 子节点中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。继续让节点10和它的左、右孩子做比较，左、右孩子中最小的是节点7，由于10 大于7，让节点10继续“下沉”。这样一来，二叉堆重新得到了调整。</p>
</li>
<li><p>构建二叉堆</p>
<p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是让所有 非叶子节点依次“下沉”。首先，从最后一个非叶子节点开始，也就是从节点10开始。如果节点10大于它 左、右孩子节点中最小的一个，则节点10“下沉”。接下来轮到节点3，如果节点3大于它左、右孩子节点中最小的一个，则节点 3“下沉”。然后轮到节点1，如果节点1大于它左、右孩子节点中最小的一个，则节点1“下 沉”。事实上节点1小于它的左、右孩子，所以不用改变。经过上述几轮比较和“下沉”操作，最终每一节点都小于它的左、右孩子节 点，一个无序的完全二叉树就被构建成了一个最小堆。</p>
</li>
</ol>
<h3 id="二叉堆的代码实现"><a href="#二叉堆的代码实现" class="headerlink" title="二叉堆的代码实现"></a>二叉堆的代码实现</h3><p>​        在展示代码之前，我们还需要明确一点：二叉堆虽然是一个完全二叉树，但它 的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储 在数组中.</p>
<p>​        在数组中，在没有左、右指针的情况下，如何定位一个父节点的左孩子和右孩 子呢？假设父节点的下标是parent，那么它的左孩子下标就是 2×parent+1；右孩子 下标就是2×parent+2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 上浮调整,</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> childIndex = array.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//temp 保存插入的子叶节点的值,用于最后赋值</span></span><br><span class="line">       <span class="keyword">int</span> temp = array[array.length - <span class="number">1</span>];</span><br><span class="line">       <span class="comment">//当上浮到顶点之前,切该值比父节点的值小,进行赋值</span></span><br><span class="line">       <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[parentIndex]) &#123;</span><br><span class="line">           <span class="comment">//不需换值,直接赋值即可,最后一次在填入值</span></span><br><span class="line">           array[childIndex] = array[parentIndex];</span><br><span class="line">           childIndex = parentIndex;</span><br><span class="line">           parentIndex = (parentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//因为是在进行子父节点的运算后退出的循环,所以这里的childIndex才是最后需要换值得节点</span></span><br><span class="line">       array[childIndex] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * "下沉调整"</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array       待调整的堆</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parentIndex 要下沉的父节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length      堆的有效大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//保存父节点的值,用于最后赋值</span></span><br><span class="line">       <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">       <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">           <span class="comment">//如果有右孩子,且右孩子的值小于左孩子的值,则定位右孩子</span></span><br><span class="line">           <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &lt; array[childIndex]) &#123;</span><br><span class="line">               childIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果父节点小于任何一个孩子的值,立刻跳出</span></span><br><span class="line">           <span class="keyword">if</span> (array[parentIndex] &lt; array[childIndex]) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//条件判断结果未true后,节点下沉</span></span><br><span class="line">           array[parentIndex] = array[childIndex];</span><br><span class="line">           parentIndex = childIndex;</span><br><span class="line">           childIndex = childIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       array[parentIndex] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构建堆</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">       <span class="comment">//从最后一个非叶子节点开始,依次进行下沉调整</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i =(array.length-<span class="number">2</span>)/<span class="number">2</span> ; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">           downAdjust(array,i, array.length);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">       upAdjust(array);</span><br><span class="line">       System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">       array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line">       buildHeap(array);</span><br><span class="line"></span><br><span class="line">       System.out.println(Arrays.toString(array));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-优先队列"><a href="#2-优先队列" class="headerlink" title="2.优先队列"></a>2.优先队列</h1><h5 id="优先队列不再遵循先入先出的原则，而是分为两种情况。-最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队-最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队"><a href="#优先队列不再遵循先入先出的原则，而是分为两种情况。-最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队-最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队" class="headerlink" title="优先队列不再遵循先入先出的原则，而是分为两种情况。 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队"></a>优先队列不再遵循先入先出的原则，而是分为两种情况。 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队</h5><p>​        先来回顾一下二叉堆的特性。 1. 最大堆的堆顶是整个堆中的最大元素。 2. 最小堆的堆顶是整个堆中的最小元素。 因此，可以用最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆 的插入操作，每一次出队操作就是删除堆顶节点</p>
<p>以下为代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现的是最大堆,所以出队的顺序是从大到小 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数组长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        array[size++] = key;</span><br><span class="line">        upAdjust();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"the queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[--size];</span><br><span class="line">        downAdjust();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用temp保存父节点的值,用于最后赋值</span></span><br><span class="line">        <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子,且右孩子的值大于左孩子的值, 则定位到左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果父节点大于任何一个孩子的值,则跳出</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; array[childIndex]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断结束,进行换值</span></span><br><span class="line">            array[parentIndex] = array[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = parentIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//temp用于保存叶子节点的值,用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">        <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex]) &#123;</span><br><span class="line">            array[childIndex] = array[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[childIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组扩容的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newSize = array.length * <span class="number">2</span>;</span><br><span class="line">        array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">6</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">78</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">213</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">45</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">456</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">78</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">76</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">8524</span>);</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">" 出队元素："</span> + priorityQueue.deQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3. 堆排序"></a>3. 堆排序</h1><p>​        把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大 到小排序，则构建成最小堆。 2. 循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶</p>
<p>​        代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下沉调整</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array       要调整的堆</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parentIndex 待下沉的父节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> length      堆的有效大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//保存父节点的值,用于最后赋值</span></span><br><span class="line">       <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">       <span class="keyword">int</span> childIndex = parentIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">           <span class="comment">//如果有右孩子,且右孩子的值大于左孩子的值,则定位右孩子</span></span><br><span class="line">           <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">               childIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果父节点的值大于每一个子节点的值,直接跳出</span></span><br><span class="line">           <span class="keyword">if</span> (temp &gt; array[childIndex]) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断结束进行换值</span></span><br><span class="line">           array[parentIndex] = array[childIndex];</span><br><span class="line">           parentIndex = childIndex;</span><br><span class="line">           childIndex = childIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       array[parentIndex] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 堆排序(升序)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">       <span class="comment">//把无序数组构建成最大堆</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">           downAdjust(array,i, array.length);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 循环的删除堆顶元素, 移到集合尾部, 调整堆产生新的堆</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length-<span class="number">1</span>; i &gt;<span class="number">0</span> ; i--) &#123;</span><br><span class="line">           <span class="comment">// 最后1个元素和第1个元素进行交换</span></span><br><span class="line">           <span class="keyword">int</span> temp = array[i];</span><br><span class="line">           array[i] = array[<span class="number">0</span>];</span><br><span class="line">           array[<span class="number">0</span>] = temp;</span><br><span class="line">           <span class="comment">// “下沉”调整最大堆</span></span><br><span class="line">           downAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">       heapSort(arr);</span><br><span class="line">       System.out.println(Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序算法的步骤"><a href="#堆排序算法的步骤" class="headerlink" title="堆排序算法的步骤"></a>堆排序算法的步骤</h4><p>​        把无序数组构建成二叉堆。 2. 循环删除堆顶元素，并将该元素移到集合尾部，调整堆产生新的堆顶。 第1步，把无序数组构建成二叉堆，这一步的时间复杂度是O(n)。 第2步，需要进行n-1次循环。每次循环调用一次downAdjust方法，所以第2步 的计算规模是 (n-1)×logn ，时间复杂度为O(nlogn)。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-ssh踩坑经历" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/ssh%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"
    >ssh踩坑经历</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/ssh%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/" class="article-date">
  <time datetime="2020-05-15T01:43:38.167Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="SSH项目总结"><a href="#SSH项目总结" class="headerlink" title="SSH项目总结"></a>SSH项目总结</h1><p>在前端的对应的标签上添加对应的<code>js</code>函数(),在外部单独的定义这个js函数</p>
<p><code>&lt;dl&gt;   &lt;dt    onclick=&quot;this.parentNode.className=this.parentNode.className==&#39;open&#39;?&#39;&#39;:&#39;open&#39;;&quot;&gt;订单业务  &lt;/dt&gt;   &lt;dd&gt;&lt;a href=&quot;javascript:all_order()&quot;&gt;所有订单&lt;/a&gt;&lt;/dd&gt;   &lt;dd&gt;&lt;a href=&quot;javascript:addnew()&quot;&gt;新增订单&lt;/a&gt;&lt;/dd&gt;   &lt;dd&gt;&lt;a href=&quot;javascript:delete_by_id()&quot;&gt;删除订单&lt;/a&gt;&lt;/dd&gt;&lt;/dl&gt;</code>,</p>
<p>后面对应的是对应的action的方法实现</p>
<p><code>function all_order(){             document.getElementById(&quot;iframe&quot;).src = &quot;torderfindAll&quot;;         }</code></p>
<p>​        然后请求就会根据给定的路径去找对应的action(<code>torderfindAll</code>代表名为<code>torder</code>的action的<code>findALL</code>方法),执行方法之后,将查询到的信息封装到session中,执行结束后,会根据方法与<code>jsp</code>的对应关系,将该session中储存的信息回填到<code>jsp</code>页面中展示给用户.</p>
<h2 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系 :"></a>对应关系 :</h2><h3 id="以下是各个层之间的对应关系"><a href="#以下是各个层之间的对应关系" class="headerlink" title="以下是各个层之间的对应关系 :"></a>以下是各个层之间的对应关系 :</h3><p>在这个文件夹中 applicationContext.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- TOrder dao --&gt;&lt;bean id="OrderDaoImpl" class="com.accp.dao.impl.OrderDaoImpl"&gt;   &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt;&lt;!-- biz --&gt;&lt;bean id="OrderBizImpl" class="com.accp.biz.impl.OrderBizImpl"&gt;   &lt;property name="orderDao" ref="OrderDaoImpl" /&gt;&lt;/bean&gt;&lt;!-- action --&gt;&lt;bean id="OrderAction" class="com.accp.action.OrderAction" scope="prototype"&gt;   &lt;property name="orderBiz" ref="OrderBizImpl" /&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="hibernate-cfg-xml-的配置-里面需要配置连接数据库的信息"><a href="#hibernate-cfg-xml-的配置-里面需要配置连接数据库的信息" class="headerlink" title="hibernate.cfg.xml 的配置,里面需要配置连接数据库的信息"></a>hibernate.cfg.xml 的配置,里面需要配置连接数据库的信息</h3><p>里面还会配置数据库表对应的实体类信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span>        <span class="meta-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>        <span class="meta-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span>    <span class="comment">&lt;!--&lt;property name="connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;--&gt;</span>    <span class="comment">&lt;!--&lt;property name="connection.url"&gt;jdbc:oracle:thin:@localhost:1521:hibernate_office&lt;/property&gt;--&gt;</span>   <span class="comment">&lt;!--&lt;property name="connection.username"&gt;office&lt;/property&gt;--&gt;</span>   <span class="comment">&lt;!--&lt;property name="connection.password"&gt;office&lt;/property&gt;--&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://119.23.31.181:3306/ssh_office<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>xuhong<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>xuhong<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.OracleDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="comment">&lt;!--&lt;property name="connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;--&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_size"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.min_size"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.timeout"</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_statements"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.idle_test_period"</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.acquire_increment"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myeclipse.connection.profile"</span>&gt;</span>ssh_office<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.accp.pojo.Users"</span> /&gt;</span>   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.accp.pojo.TOrder"</span> /&gt;</span>   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.accp.pojo.Email"</span> /&gt;</span>   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.accp.pojo.Vacation"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="strus-xml的配置"><a href="#strus-xml的配置" class="headerlink" title="strus.xml的配置"></a>strus.xml的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /* 原始 struts2 */ &lt;action name="user*" class="com.accp.demo.action.UserinfoAction" method="&#123;1&#125;"&gt; &lt;result name="ok"&gt;/ok.jsp&lt;/result&gt;    &lt;result name="err"&gt;/err.jsp&lt;/result&gt; &lt;result name="back" type="redirect"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; --&gt;</span><span class="comment">&lt;!-- 现在交由Spring,class 应该写applicationContext.xml中 action 的 ID --&gt;</span><span class="comment">&lt;!-- user action --&gt;</span><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"user*"</span> <span class="attr">class</span>=<span class="string">"UsersAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"login"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"relogin"</span>&gt;</span>/<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"out"</span> <span class="attr">type</span>=<span class="string">"redirect"</span>&gt;</span>/<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"update"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"updatePwd"</span>&gt;</span>/account.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"selectFirstPage"</span>&gt;</span>/account_list.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"selectNextPage"</span>&gt;</span>/account_list.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span>userselectFirstPage<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span>userselectFirstPage<span class="tag">&lt;/<span class="name">result</span>&gt;</span>   <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><action>标签中的那么表示所有user开头的请求的对应关系都在这里配置,class是对应的action类</p>
<p><result>标签中的name是对应的action中具体的方法名,标签中间的<code>xxx.jsp</code>是是该方法对应的<code>jsp</code>文件</p>
<h3 id="实体类与数据库表的对应关系"><a href="#实体类与数据库表的对应关系" class="headerlink" title="实体类与数据库表的对应关系 :"></a>实体类与数据库表的对应关系 :</h3><ul>
<li><input disabled="" type="checkbox"> <pre><code class="xml"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span><span class="meta-string">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"</span>&gt;</span><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span>    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.accp.pojo.TOrder"</span> <span class="attr">table</span>=<span class="string">"t_order"</span>&gt;</span>        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"assigned"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">id</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phone"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"phone"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderType"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"order_type"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"status"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"status"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"picture"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"picture"</span> <span class="attr">length</span>=<span class="string">"150"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"createUser"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"create_user"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"createTime"</span> <span class="attr">type</span>=<span class="string">"java.sql.Timestamp"</span>&gt;</span>            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"create_time"</span> <span class="attr">length</span>=<span class="string">"30"</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="comment">&lt;!--       &lt;set name="emails"&gt;         &lt;key cloumn="RECIPIENTS"&gt;&lt;/key&gt;         &lt;one-to-many class="com.accp.pojo.Email"/&gt;      &lt;/set&gt; --&gt;</span><span class="comment">&lt;!--       &lt;set name="vacations"&gt;         &lt;key cloumn="NAME"&gt;&lt;/key&gt;         &lt;one-to-many class="com.accp.pojo.Vacation"/&gt;      &lt;/set&gt; --&gt;</span>    <span class="tag">&lt;/<span class="name">class</span>&gt;</span><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></code></pre>
</li>
</ul>
<p><class name="com.accp.pojo.TOrder" table="t_order">其中的name表示实体类的全类名,table表示的是表名,而且必须将需要查询的的所有字段与实体类对应起来(包括数据类型的匹配),否则查询不到</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-SSH框架" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/SSH%E6%A1%86%E6%9E%B6/"
    >SSH框架</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/SSH%E6%A1%86%E6%9E%B6/" class="article-date">
  <time datetime="2020-05-15T01:43:38.166Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>1.加入Spring</p>
<p>2.加入Hibernate</p>
<p>3.同时持久化类,和对应的.hbm.xml文件</p>
<p>4.Spring整合Hibernate</p>
<p>5.加入Strust2</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-redis配置文件" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"
    >redis配置文件</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2020-05-15T01:43:38.165Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="redis-conf配置"><a href="#redis-conf配置" class="headerlink" title="redis.conf配置"></a>redis.conf配置</h2><p>redis.conf配置说明如下 ：</p>
<ol>
<li>Redis默认不是以守护线程的方式运行,可以通过该配置项修改,使用yes启用守护线程, daemonize</li>
</ol>
<p>yes</p>
<ol start="2">
<li><p>当Redis以守护线程运行时,Redis默认会把pid写入/run/redis.pid文件,可以通过profile指定 pidfile/var/run/redis.pid</p>
</li>
<li><p>指定Redis监听端口,默认端口为6379,作者在自己的一篇博文中解释了为什么选用6379作为端口,因为6379在手机上上的按键MERZ的对应的号码,而MERZ取自意大利歌女Alessia Merz的名字 </p>
</li>
</ol>
<p>port 6379</p>
<ol start="4">
<li>绑定的主机地址 : bind 127.0.0.1</li>
</ol>
<p>​     假如需要远程访问的话需将其注释<code>#</code>,或者改为0.0.0.0</p>
<ol start="5">
<li><p>当客户端闲置多长时间后关闭连接,如果时间为0,表示关闭该功能, timeout 300</p>
</li>
<li><p>指定日志记录级别,Redis总共支持四个级别: debug, verbose, notice, warning, 摩尔恩为verbose</p>
</li>
<li><p>日志记录方式,默认为标准输出, 如果配置Redis为守护线程方式运行,而这里又配置为日志记录方式为标注输出,则日志会发送给/dev/null/logfile stdout</p>
</li>
<li><p>设置数据库的数量,默认数据库为0,可以使用SELECT<dbid>命令在连接指定数据库id</p>
<p>database 16</p>
</li>
<li><p>指定在多长时间内,有多少次更新操作,就讲数据同步到数据文件,可以多个条件配合 save<seconds><changes></p>
</li>
</ol>
<p>redis默认配置文件中提供了三个条件 :</p>
<p>save 900 1 </p>
<p>save 300 10</p>
<p>save 60 10000</p>
<p>分别表示900秒(15分钟)内有1个更改,300秒(5分钟)内有10个更改以及60秒有10000个更改</p>
<ol start="10">
<li><p>指定存储至本地数据库时是否压缩数据,默认为YES,Redis采用LZF压缩,如果为了节省CPU时间,可以关闭该选项, 但会导致数据库文件变的巨大, rdbcompression yes</p>
</li>
<li><p>指定本地数据库文件名, 默认值为 dump.db    dbfilename dump.db</p>
</li>
<li><p>指定本地数据库存放目录     dir./</p>
</li>
<li><p>设置当本机为slav服务时, 设置master服务的IP地址及端口,在Redis启动时, 它会主动从master进行数据同步,  slaveof<masterip><masterport></p>
</li>
<li><p>当master服务设置了密码保护时,salv服务连接master的密码    masterauth <master-password></p>
</li>
<li><p>设置Redis连接密码,如果配置了连接密码,客户端在连接Redis时需要通过 AUTH<password>命令提供密码,默认关闭  requirepass fobared</p>
</li>
<li><p>设置同一时间最大客户端连接数,默认无限制,Redis可以同时打开的客户端数为为Redis进程可以打开的最大文件描述符数,如果设置maxclients 0, 如果不做限制.当客户端连接数达到限制时,Redis会关闭新的连接并向客户端返回 max number of clients reched错误信息</p>
</li>
<li><p>指定Redis最大内存限制,Redis在启动时会把数据加载到内存中, 达到最大内存后, Redis会先尝试清楚已到期或即将到期的key, 当此方法处理后,仍达到最大内存设置,将无法再进行写入操作,但仍可以进行读取操作,Redis新的vm机制,会把key存到内存,value存到swap区 maxmemory<bytes></p>
</li>
<li><p>指定是否每次更新操作后进行日志同步记录, Redis在默认情况下是异步的把数据写入磁盘, 如果不开启, 可能会在断电时导致一段时间内的数据消失. 因为Redis本身同步数据文件是按上面save条件来同步的,所以有的数据会在一段时间内只存在内存中,默认为 no    appendonly no</p>
</li>
<li><p>指定更新日志文件名, 默认为appendonly.aof      apppendfiename appendonly.aof</p>
</li>
<li><p>指定跟新日志条件, 共有3个可选值 : </p>
</li>
<li><p>no : 表示等操作系统进行数据缓存同步到磁盘</p>
<p>always : 表示你每次更新操作后手动地调用fsnc()将数据写到磁盘(慢,安全)</p>
<p>everysec : 表示每秒同步一次 (折中,默认值)</p>
</li>
<li><p>虚拟内存文件路径, 默认值为 /tem/redis.swap, 不可多个Redis实例共享 vm-swap-file/temp/redis.swap</p>
</li>
<li><p>将所有大于vm-max-momory的数据存入虚拟内存,无论vm-max-memory设置多小, 所有索引数据都是内存存储的(Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实所有value都存在于磁盘,默认值为0     vm-max-memory 0 </p>
</li>
<li><p>Redis swap文件分成了很多的page,一个对象可以保存多个page上面, 但一个page上不能被多个对象共享, vm-page-size是要根据储存的数据大小来设定的, 作者建议如果存储很多小对象,page的大小最好设置为32或者64bytes;如果存储很大对象,则可以使用更大的page,如果不确定, 就使用默认值  vm-page-size 32</p>
</li>
<li><p>设置swap文件中的page数量,由于页表(一种表示页面空闲或使用的bitmap)是放在内存中的, 在磁盘上每8个pages将消耗一个byte的内存, vm-pages 134217728</p>
</li>
<li><p>设置访问swap问价你的线程数,最好不要超过及其的核数, 如果设置为0, 那么所有的swap文件都是串行的, 可能会造成比较长的延迟,默认值为4 vm-max-threads 4 </p>
</li>
<li><p>上设置在向客户端应答时,是否把较小的包合并为一个包发送,默认为开启,  glueoutputbuf     yes</p>
</li>
<li><p>指定在超过一定的数量户或者最大的元素超过某一临界值时,采用一种特殊的哈希算法, hash-max-zipmap-entries   64        hash-max-zipmap-values  512</p>
</li>
<li><p>指定是否激活重置哈希,默认为开启   activerehashing yes</p>
</li>
<li><p>指定包含其他的配置文件, 可以在同一主机上多个Redis实例主键使用同一配置文件, 而同时各个实例又拥有自己的特定配置文件, include /path / to/local.conf</p>
<h4 id="总结-在linux系统上-配置文件很重要-因为没有图形界面-所以几乎所以所有的更改配置的操作都是通过修改配置文件来完成的-等同于windows的设置-在更改的时候最好将配置文件-xxxx-conf单独copy一份来修改-这样可以避免修改错误不能回滚-修改完成后可以通过这份新的配置文件来启动应用-达到修改配置的目的"><a href="#总结-在linux系统上-配置文件很重要-因为没有图形界面-所以几乎所以所有的更改配置的操作都是通过修改配置文件来完成的-等同于windows的设置-在更改的时候最好将配置文件-xxxx-conf单独copy一份来修改-这样可以避免修改错误不能回滚-修改完成后可以通过这份新的配置文件来启动应用-达到修改配置的目的" class="headerlink" title="总结  : 在linux系统上,配置文件很重要,因为没有图形界面,所以几乎所以所有的更改配置的操作都是通过修改配置文件来完成的,等同于windows的设置,在更改的时候最好将配置文件 xxxx.conf单独copy一份来修改,这样可以避免修改错误不能回滚,修改完成后可以通过这份新的配置文件来启动应用,达到修改配置的目的"></a>总结  : 在linux系统上,配置文件很重要,因为没有图形界面,所以几乎所以所有的更改配置的操作都是通过修改配置文件来完成的,等同于windows的设置,在更改的时候最好将配置文件 xxxx.conf单独copy一份来修改,这样可以避免修改错误不能回滚,修改完成后可以通过这份新的配置文件来启动应用,达到修改配置的目的</h4></li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> 丰之霸
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
</body>

</html>