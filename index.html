<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-本地搭建Gitlab" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAGitlab/"
    >本地搭建Gitlab</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAGitlab/" class="article-date">
  <time datetime="2020-05-15T01:51:13.335Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="本地搭建GitLab环境"><a href="#本地搭建GitLab环境" class="headerlink" title="本地搭建GitLab环境"></a>本地搭建GitLab环境</h1><h4 id="1-执行官网的命令"><a href="#1-执行官网的命令" class="headerlink" title="1.  执行官网的命令"></a>1.  执行官网的命令</h4><p>执行gitlab官网提供的命令, 部署环境, 并下载gitlab到本地    <strong>官网： <a href="https://about.gitlab.com/" target="_blank" rel="noopener">https://about.gitlab.com/</a></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">依次执行以下命令</span></span><br><span class="line">sudo yum install -y curl policycoreutils-python openssh-server</span><br><span class="line">sudo systemctl enable sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo firewall-cmd --permanent --add-service=https</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure>

<p>然后再执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postfix</span><br><span class="line">sudo systemctl enable postfix</span><br><span class="line">sudo systemctl start postfix</span><br></pre></td></tr></table></figure>

<h4 id="2-添加yum-gitlab源"><a href="#2-添加yum-gitlab源" class="headerlink" title="2. 添加yum gitlab源"></a>2. 添加yum gitlab源</h4><p><code>curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash</code></p>
<h4 id="3-执行yum安装操作"><a href="#3-执行yum安装操作" class="headerlink" title="3. 执行yum安装操作"></a>3. 执行yum安装操作</h4><p><code>sudo EXTERNAL_URL=&quot;https://gitlab.example.com&quot; yum install -y gitlab-ee</code></p>
<h4 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/gitlab</span><br><span class="line">sudo touch /etc/gitlab/gitlab.rb</span><br><span class="line">sudo chmod 600 /etc/gitlab/gitlab.rb</span><br><span class="line">sudo gedit /etc/gitlab/gitlab.rb</span><br><span class="line"><span class="meta">#</span><span class="bash">更改配置文件</span></span><br><span class="line">vim  /etc/gitlab/gitlab.rb</span><br><span class="line"><span class="meta">#</span><span class="bash">将以下地址改为gitlab中的ip地址</span></span><br><span class="line">external_url 'http://192.168.0.228'</span><br><span class="line"><span class="meta">#</span><span class="bash">修改完IP执行（启动）   </span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line"><span class="meta">#</span><span class="bash">验证更改结果</span></span><br><span class="line"> /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</span><br></pre></td></tr></table></figure>

<h4 id="5-浏览器访问"><a href="#5-浏览器访问" class="headerlink" title="5. 浏览器访问"></a>5. 浏览器访问</h4><p>ip:端口</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-二叉树的层序遍历" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"
    >二叉树的层序遍历</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" class="article-date">
  <time datetime="2020-05-15T01:51:13.325Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p><strong>题目描述</strong> : 给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>分析:</strong>  按照管方给出的 <code>func levelOrder(root *TreeNode) [][]int</code>输入可以看出,入参是一个基于链表实现的二叉树,然后需要返回的是一个二维数组,每一层对应数组的一个index,,但是要考虑二叉树不满的情况,解题思路很多</p>
<p>这里利用栈的特性进行解决, go 代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//声明queue</span></span><br><span class="line">	queue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">//将根节点放入</span></span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    <span class="comment">//当queue不为空时进行操作</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//记录queue的长度,即是对应层数组的长度</span></span><br><span class="line">		l := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="comment">//声明数组存放对应层的节点的值</span></span><br><span class="line">		ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//遍历queue,将节点的值加入到数组中,并查看该节点是否有左右子节点</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">			node := queue[i]</span><br><span class="line">			ans = <span class="built_in">append</span>(ans, node.Val)</span><br><span class="line">            <span class="comment">//如果有左子节点,将其假如到queue中,遵循从左到右的顺序</span></span><br><span class="line">			<span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//如果有右节点,将其假如到queue中</span></span><br><span class="line">			<span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//将该层获取的结果存到二维数组中</span></span><br><span class="line">		res = <span class="built_in">append</span>(res, ans)</span><br><span class="line">        <span class="comment">//将本层进行操作过的queue中的值截取到,这个操作很妙</span></span><br><span class="line">		queue = queue[l:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-非常有价值的AI" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E9%9D%9E%E5%B8%B8%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84AI/"
    >非常有价值的AI</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E9%9D%9E%E5%B8%B8%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84AI/" class="article-date">
  <time datetime="2020-05-15T01:43:38.180Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>内容:为什么最近有很多名人，比如比尔盖茨，<br>马斯克、霍金等，让人们警惕人工智能？<br>人工智能很可能导致人类的永生或者灭绝，而这一切很可能在我们的有生之年<br>发生。<br>上面这句话不是危言耸听，请耐心的看完本文再发表意见。这篇翻译稿翻译完一<br>共三万五千字，我从上星期开始翻，熬了好几个夜才翻完，因为我觉得这篇东西<br>非常有价值。希望你们能够耐心读完，读完后也许你的世界观都会被改变。<br>======================<br>我们正站在变革的边缘，而这次变革将和人类的出现一般意义重大 – Vernor<br>Vinge<br>如果你站在这里，你会是什么感觉？<br>看上去非常刺激吧？但是你要记住，当你真的站在时间的图表中的时候，你是看<br>不到曲线的右边的，因为你是看不到未来的。所以你真实的感觉大概是这样的：<br>稀松平常。</p>
<hr>
<p>遥远的未来——就在眼前<br>想象一下坐时间机器回到1750年的地球，那个时代没有电，畅通通讯基本靠吼，<br>交通主要靠动物拉着跑。你在那个时代邀请了一个叫老王的人到2015年来玩，<br>顺便看看他对“未来”有什么感受。我们可能没有办法了解1750年的老王内心的<br>感受——金属铁壳在宽敞的公路上飞驰，和太平洋另一头的人聊天，看几千公里<br>外正在发生进行的体育比赛，观看一场发生于半个世纪前的演唱会，从口袋里掏<br>出一个黑色长方形工具把眼前发生的事情记录下来，生成一个地图然后地图上有<br>个蓝点告诉你现在的位置，一边看着地球另一边的人的脸一边聊天，以及其它各<br>种各样的黑科技。别忘了，你还没跟他解释互联网、国际空间站、大型强子对撞<br>机、核武器以及相对论。<br>这时候的老王会是什么体验？惊讶、震惊、脑洞大开这些词都太温顺了，我觉得<br>老王很可能直接被吓尿了。<br>但是，如果老王回到了1750年，然后觉得被吓尿是个很囧的体验，于是他也想<br>把别人吓尿来满足一下自己，那会发生什么？于是老王也回到了250年前的1500<br>年，邀请生活在1500年的小李去1750年玩一下。小李可能会被250年后的很多<br>东西震惊，但是至少他不会被吓尿。同样是250来年的时间，1750和2015年的<br>差别，比1500年和1750年的差别，要大得多了。1500年的小李可能能学到很多<br>神奇的物理知识，可能会惊讶于欧洲的帝国主义旅程，甚至对于世界地图的认知<br>也会大大的改变，但是1500年的小李，看到1750年的交通、通讯等等，并不会<br>被吓尿。<br>所以说，对于1750年的老王来说，要把人吓尿，他需要回到更古老的过去——<br>比如回到公元前12000年，第一次农业革命之前。那个时候还没有城市，也还没<br>有文明。一个来自狩猎采集时代的人类，只是当时众多物种中的一个罢了，来自<br>那个时代的小赵看到1750年庞大的人类帝国，可以航行于海洋上的巨舰，居住<br>在“室内”，无数的收藏品，神奇的知识和发现——他很有可能被吓尿。<br>小赵被吓尿后如果也想做同样的事情呢？如果他会到公元前24000年，找到那个<br>时代的小钱，然后给他展示公元前12000年的生活会怎样呢。小钱大概会觉得小<br>赵是吃饱了没事干——“这不跟我的生活差不多么，呵呵”。小赵如果要把人吓尿，<br>可能要回到十万年前或者更久，然后用人类对火和语言的掌控来把对方吓尿。<br>所以，一个人去到未来，并且被吓尿，他们需要满足一个“吓尿单位”。满足吓尿<br>单位所需的年代间隔是不一样的。在狩猎采集时代满足一个吓尿单位需要超过十<br>万年，而工业革命后一个吓尿单位只要两百多年就能满足。<br>未来学家 Ray Kurzweil 把这种人类的加速发展称作加速回报定律（Law of<br>Accelerating Returns）。之所以会发生这种规律，是因为一个更加发达的社会，<br>能够继续发展的能力也更强，发展的速度也更快——这本就是更加发达的一个标<br>准。19世纪的人们比15世纪的人们懂得多得多，所以19世纪的人发展起来的速<br>度自然比15世纪的人更快。<br>即使放到更小的时间规模上，这个定律依然有效。著名电影《回到未来》中，生<br>活在1985年的主角回到了1955年。当主角回到1955年的时候，他被电视刚出现<br>时的新颖、便宜的物价、没人喜欢电吉他、俚语的不同而震惊。<br>但是如果这部电影发生在2015年，回到30年前的主角的震惊要比这大得多。一<br>个2000年左右出生的人，回到一个没有个人电脑、互联网、手机的1985年，会<br>比从1985年回到1955年的主角看到更大的区别。<br>这同样是因为加速回报定律。1985年-2015年的平均发展速度，要比1955年<br>-1985年的平均发展速度要快，因为1985年的世界比1955年的更发达，起点更<br>高，所以过去30年的变化要大过之前30年的变化。<br>进步越来越大，发生的越来越快，也就是说我们的未来会很有趣对吧？<br>未来学家 Kurzweil 认为整个20世纪100年的进步，按照2000年的速度只要20<br>年就能达成——2000年的发展速度是20世纪平均发展速度的5倍。他认为2000<br>年开始只要花14年就能达成整个20世纪一百年的进步，而之后2014年开始只要<br>花7年（2021年），就能达到又一个20世纪一百年的进步。几十年之后，我们每<br>年都能达成好几次相当于整个20世纪的发展，再往后，说不定每个月都能达成<br>一次。按照加速回报定，Kurzweil 认为人类在21世纪的进步将是20世纪的1000<br>倍。<br>如果 Kurzweil 等人的想法是正确的，那2030年的世界可能就能把我们吓尿了<br>——下一个吓尿单位可能只需要十几年，而2050年的世界会变得面目全非。<br>你可能觉得2050年的世界会变得面目全非这句话很可笑，但是这不是科幻，而<br>是比你我聪明很多的科学家们相信的，而且从历史来看，也是逻辑上可以预测的。<br>那么为什么你会觉得“2050年的世界会变得面目全非” 这句话很可笑呢？有三<br>个原因让你质疑对于未来的预测：</p>
<ol>
<li>我们对于历史的思考是线性的。当我们考虑未来35年的变化时，我们参照的<br>是过去35年发生的事情。当我们考虑21世纪能产生的变化的时候，我们参考的<br>是20世纪发生的变化。这就好像1750年的老王觉得1500年的小李在1750年能<br>被吓尿一样。线性思考是本能的，但是但是考虑未来的时候我们应该指数地思考。<br>一个聪明人不会把过去35年的发展作为未来35年的参考，而是会看到当下的发<br>展速度，这样预测的会更准确一点。当然这样还是不够准确，想要更准确，你要<br>想象发展的速度会越来越快。</li>
<li>近期的历史很可能对人产生误导。首先，即使是坡度很高的指数曲线，只要<br>你截取的部分够短，看起来也是很线性的，就好像你截取圆周的很小一块，看上<br>去就是和直线差不多。其次，指数增长不是平滑统一的，发展常常遵循 S 曲线。<br>S 曲线发生在新范式传遍世界的时候，S 曲线分三部分</li>
</ol>
<ul>
<li>慢速增长（指数增长初期）</li>
<li>快速增长（指数增长的快速增长期）</li>
<li>随着新范式的成熟而出现的平缓期<br>如果你只看近期的历史，你很可能看到的是 S 曲线的某一部分，而这部分可能不<br>能说明发展究竟有多快速。1995-2007年是互联网爆炸发展的时候，微软、谷<br>歌、脸书进入了公众视野，伴随着的是社交网络、手机的出现和普及、智能手机<br>的出现和普及，这一段时间就是 S 曲线的快速增长期。2008-2015年发展没那<br>么迅速，至少在技术领域是这样的。如果按照过去几年的发展速度来估计当下的<br>发展速度，可能会错得离谱，因为很有可能下一个快速增长期正在萌芽。</li>
</ul>
<ol start="3">
<li>个人经验使得我们对于未来预期过于死板。我们通过自身的经验来产生世界<br>观，而经验把发展的速度烙印在了我们脑中——“发展就是这么个速度的。”我们<br>还会受限于自己的想象力，因为想象力通过过去的经验来组成对未来的预测——<br>但是我们知道的东西是不足以帮助我们预测未来的。当我们听到一个和我们经验<br>相违背的对于未来的预测时，我们就会觉得这个预测偏了。如果我现在跟你说你<br>可以活到150岁，250岁，甚至会永生，你是不是觉得我在扯淡——“自古以来，<br>所有人都是会死的。”是的，过去从来没有人永生过，但是飞机发明之前也没有<br>人坐过飞机呀。<br>接下来的内容，你可能一边读一边心里“呵呵”，而且这些内容可能真的是错的。<br>但是如果我们是真的从历史规律来进行逻辑思考的，我们的结论就应该是未来<br>的几十年将发生比我们预期的多得多得多得多的变化。同样的逻辑也表明，如果<br>人类这个地球上最发达的物种能够越走越快，总有一天，他们会迈出彻底改变“人<br>类是什么”这一观点的一大步，就好像自然进化不不断朝着智能迈步，并且最终<br>迈出一大步产生了人类，从而完全改变了其它所有生物的命运。如果你留心一下<br>近来的科技进步的话，你会发现，到处都暗示着我们对于生命的认知将要被接下<br>来的发展而彻底改变。</li>
</ol>
<hr>
<p>通往超级智能之路<br>人工智能是什么？<br>如果你一直以来把人工智能（AI）当做科幻小说，但是近来却不但听到很多正经<br>人严肃的讨论这个问题，你可能也会困惑。这种困惑是有原因的：<br>1.我们总是把人工智能和电影想到一起。星球大战、终结者、2001：太空漫游<br>等等。电影是虚构的，那些电影角色也是虚构的，所以我们总是觉得人工智能缺<br>乏真实感。<br>2.人工智能是个很宽泛的话题。从手机上的计算器到无人驾驶汽车，到未来可能<br>改变世界的重大变革，人工智能可以用来描述很多东西，所以人们会有疑惑。<br>3.我们日常生活中已经每天都在使用人工智能了，只是我们没意识到而已。John<br>McCarthy，在1956年最早使用了人工智能（Artificial Intelligence）这个词。<br>他总是抱怨“一旦一样东西用人工智能实现了，人们就不再叫它人工智能了。”<br>因为这种效应，所以人工智能听起来总让人觉得是未来的神秘存在，而不是身边<br>已经存在的现实。同时，这种效应也让人们觉得人工智能是一个从未被实现过的<br>流行理念。Kurzweil 提到经常有人说人工智能在80年代就被遗弃了，这种说法<br>就好像“互联网已经在21世纪初互联网泡沫爆炸时死去了”一般滑稽。<br>所以，让我们从头开始。<br>首先，不要一提到人工智能就想着机器人。机器人只是人工智能的容器，机器人<br>有时候是人形，有时候不是，但是人工智能自身只是机器人体内的电脑。人工智<br>能是大脑的话，机器人就是身体——而且这个身体不一定是必需的。比如说 Siri<br>背后的软件和数据是人工智能，Siri 说话的声音是这个人工智能的人格化体现，<br>但是 Siri 本身并没有机器人这个组成部分。<br>其次，你可能听过“奇点”或者“技术奇点”这种说法。这种说法在数学上用来描述<br>类似渐进的情况，这种情况下通常的规律就不适用了。这种说法同样被用在物理<br>上来描述无限小的高密度黑洞，同样是通常的规律不适用的情况。Kurzweil 则<br>把奇点定义为加速回报定律达到了极限，技术进步以近乎无限的速度发展，而奇<br>点之后我们将在一个完全不同的世界生活的。但是当下的很多思考人工智能的人<br>已经不再用奇点这个说法了，而且这种说法很容易把人弄混，所以本文也尽量少<br>用。<br>最后，人工智能的概念很宽，所以人工智能也分很多种，我们按照人工智能的实<br>力将其分成三大类。<br>弱人工智能 Artificial Narrow Intelligence (ANI): 弱人工智能是擅长于单个<br>方面的人工智能。比如有能战胜象棋世界冠军的人工智能，但是它只会下象棋，<br>你要问它怎样更好地在硬盘上储存数据，它就不知道怎么回答你了。<br>强人工智能 Artificial General Intelligence (AGI): 人类级别的人工智能。强<br>人工智能是指在各方面都能和人类比肩的人工智能，人类能干的脑力活它都能<br>干。创造强人工智能比创造弱人工智能难得多，我们现在还做不到。Linda<br>Gottfredson 教授把智能定义为“一种宽泛的心理能力，能够进行思考、计划、<br>解决问题、抽象思维、理解复杂理念、快速学习和从经验中学习等操作。 ”强人<br>工智能在进行这些操作时应该和人类一样得心应手。<br>超人工智能 Artificial Superintelligence (ASI): 牛津哲学家，知名人工智能<br>思想家 Nick Bostrom 把超级智能定义为“在几乎所有领域都比最聪明的人类大<br>脑都聪明很多，包括科学创新、通识和社交技能。”超人工智能可以是各方面都<br>比人类强一点，也可以是各方面都比人类强万亿倍的。超人工智能也正是为什么<br>人工智能这个话题这么火热的缘故，同样也是为什么永生和灭绝这两个词会在本<br>文中多次出现。<br>现在，人类已经掌握了弱人工智能。其实弱人工智能无处不在，人工智能革命是<br>从弱人工智能，通过强人工智能，最终到达超人工智能的旅途。这段旅途中人类<br>可能会生还下来，可能不会，但是无论如何，世界将变得完全不一样。<br>让我们来看看这个领域的思想家对于这个旅途是怎么看的，以及为什么人工智能<br>革命可能比你想的要近得多。<br>我们现在的位置——充满了弱人工智能的世界<br>弱人工智能是在特定领域等同或者超过人类智能/效率的机器智能，一些常见的<br>例子：<br>• 汽车上有很多的弱人工智能系统，从控制防抱死系统的电脑，到控制汽油<br>注入参数的电脑。谷歌正在测试的无人驾驶车，就包括了很多弱人工智能，<br>这些弱人工智能能够感知周围环境并作出反应。<br>• 你的手机也充满了弱人工智能系统。当你用地图软件导航，接受音乐电台<br>推荐，查询明天的天气，和 Siri 聊天，以及其它很多很多应用，其实都是弱<br>人工智能。<br>• 垃圾邮件过滤器是一种经典的弱人工智能——它一开始就加载了很多识<br>别垃圾邮件的智能，并且它会学习并且根据你的使用而获得经验。智能室温<br>调节也是一样，它能根据你的日常习惯来智能调节。<br>• 你在上网时候出现的各种其它电商网站的产品推荐，还有社交网站的好友<br>推荐，这些都是弱人工智能的组成的，弱人工智能联网互相沟通，利用你的<br>信息来进行推荐。网购时出现的“买这个商品的人还购买了”推荐，其实就是<br>收集数百万用户行为然后产生信息来卖东西给你的弱人工智能。<br>• 谷歌翻译也是一种经典的人工智能——非常擅长单个领域。声音识别也是<br>一种。很多软件利用这两种智能的合作，使得你能对着手机说中文，手机直<br>接给你翻译成英文。<br>• 当飞机着陆时候，不是一个人类决定飞机该去那个登机口接驳。就好像你<br>在网上买票时票据不是一个人类决定的。<br>• 世界最强的跳棋、象棋、拼字棋、双陆棋和黑白棋选手都是弱人工智能。<br>• 谷歌搜索是一个巨大的弱人工智能，背后是非常复杂的排序方法和内容检<br>索。社交网络的新鲜事同样是这样。<br>• 这些还只是消费级产品的例子。军事、制造、金融（高频算法交易占到了<br>美国股票交易的一半）等领域广泛运用各种复杂的弱人工智能。专业系统也<br>有，比如帮助医生诊断疾病的系统，还有著名的 IBM 的华生，储存了大量事<br>实数据，还能理解主持人的提问，在竞猜节目中能够战胜最厉害的参赛者。<br>现在的弱人工智能系统并不吓人。最糟糕的情况，无非是代码没写好，程序出故<br>障，造成了单独的灾难，比如造成停电、核电站故障、金融市场崩盘等等。<br>虽然现在的弱人工智能没有威胁我们生存的能力，我们还是要怀着警惕的观点看<br>待正在变得更加庞大和复杂的弱人工智能的生态。每一个弱人工智能的创新，都<br>在给通往强人工智能和超人工智能的旅途添砖加瓦。用 Aaron Saenz 的观点，<br>现在的弱人工智能，就是地球早期软泥中的氨基酸——没有动静的物质，突然之<br>间就组成了生命。<br>弱人工智能到强人工智能之路<br>为什么这条路很难走<br>只有明白创造一个人类智能水平的电脑是多么不容易，才能让你真的理解人类的<br>智能是多么不可思议。造摩天大楼、把人送入太空、明白宇宙大爆炸的细节——<br>这些都比理解人类的大脑，并且创造个类似的东西要简单太多了。至今为止，人<br>类的大脑是我们所知宇宙中最复杂的东西。<br>而且创造强人工智能的难处，并不是你本能认为的那些。<br>造一个能在瞬间算出十位数乘法的计算机——非常简单<br>造一个能分辨出一个动物是猫还是狗的计算机——极端困难<br>造一个能战胜世界象棋冠军的电脑——早就成功了<br>造一个能够读懂六岁小朋友的图片书中的文字，并且了解那些词汇意思的电脑<br>——谷歌花了几十亿美元在做，还没做出来。<br>一些我们觉得困难的事情——微积分、金融市场策略、翻译等，对于电脑来说<br>都太简单了<br>我们觉得容易的事情——视觉、动态、移动、直觉——对电脑来说太 TM 的难<br>了。<br>用计算机科学家 Donald Knuth 的说法，“人工智能已经在几乎所有需要思考的<br>领域超过了人类，但是在那些人类和其它动物不需要思考就能完成的事情上，<br>还差得很远。”<br>读者应该能很快意识到，那些对我们来说很简单的事情，其实是很复杂的，它们<br>看上去很简单，因为它们已经在动物进化的过程中经历了几亿年的优化了。当你<br>举手拿一件东西的时候，你肩膀、手肘、手腕里的肌肉、肌腱和骨头，瞬间就进<br>行了一组复杂的物理运作，这一切还配合着你的眼睛的运作，使得你的手能都在<br>三维空间中进行直线运作。对你来说这一切轻而易举，因为在你脑中负责处理这<br>些的“软件”已经很完美了。同样的，软件很难识别网站的验证码，不是因为软件<br>太蠢，恰恰相反，是因为能够读懂验证码是件碉堡了的事情。<br>同样的，大数相乘、下棋等等，对于生物来说是很新的技能，我们还没有几亿年<br>的世界来进化这些能力，所以电脑很轻易的就击败了我们。试想一下，如果让你<br>写一个程序，是一个能做大数相乘的程序容易写，还是能够识别千千万万种字体<br>和笔迹下书写的英文字母的程序难写？<br>比如看着下面这个图的时候，你和电脑都能识别出这是一个由两种颜色的小长方<br>形组成的一个大长方形。<br>你和电脑打了个平手。接着我们把途中的黑色部分去除：<br>你可以轻易的描述图形中透明或不透明的圆柱和 3D 图形，但是电脑就看不出来<br>了。电脑会描述出 2D 的阴影细节，但是人脑却能够把这些阴影所展现的深度、<br>阴影混合、房屋灯光解读出来。<br>再看下面这张图，电脑看到的是黑白灰，我们看到的却是一块全黑的石头<br>而且，我们到现在谈的还是静态不变的信息。要想达到人类级别的智能，电脑必<br>须要理解更高深的东西，比如微小的脸部表情变化，开心、放松、满足、满意、<br>高兴这些类似情绪间的区别，以及为什么《布达佩斯大饭店》是好电影，而《富<br>春山居图》是烂电影。<br>想想就很难吧？<br>我们要怎样才能达到这样的水平呢？<br>通往强人工智能的第一步：增加电脑处理速度<br>要达到强人工智能，肯定要满足的就是电脑硬件的运算能力。如果一个人工智能<br>要像人脑一般聪明，它至少要能达到人脑的运算能力。<br>用来描述运算能力的单位叫作 cps（calculations per second，每秒计算次数），<br>要计算人脑的 cps 只要了解人脑中所有结构的最高 cps，然后加起来就行了。<br>Kurzweil 把对于一个结构的最大 cps 的专业估算，然后考虑这个结构占整个大<br>脑的重量，做乘法，来得出人脑的 cps。听起来不太靠谱，但是 Kurzweil 用了<br>对于不同大脑区域的专业估算值，得出的最终结果都非常类似，是10^16 cps，<br>也就是1亿亿次计算每秒。<br>现在最快的超级计算机，中国的天河二号，其实已经超过这个运算力了，天河每<br>秒能进行3.4亿亿。当然，天河二号占地720平方米，耗电2400万瓦，耗费了3.9<br>亿美元建造。广泛应用就不提了，即使是大部分商业或者工业运用也是很贵的。<br>Kurzweil 认为考虑电脑的发展程度的标杆是看1000美元能买到多少 cps，当<br>1000美元能买到人脑级别的1亿亿运算能力的时候，强人工智能可能就是生活的<br>一部分了。<br>摩尔定律认为全世界的电脑运算能力每两年就翻一倍，这一定律有历史数据所支<br>持，这同样表明电脑硬件的发展和人类发展一样是指数级别的。我们用这个定律<br>来衡量1000美元什么时候能买到1亿亿 cps。现在1000美元能买到10万亿 cps，<br>和摩尔定律的历史预测相符合。<br>也就是说现在1000美元能买到的电脑已经强过了老鼠，并且达到了人脑千分之<br>一的水平。听起来还是弱爆了，但是，让我们考虑一下，1985年的时候，同样<br>的钱只能买到人脑万亿分之一的 cps，1995年变成了十亿分之一，2005年是百<br>万分之一，而2015年已经是千分之一了。按照这个速度，我们到2025年就能花<br>1000美元买到可以和人脑运算速度抗衡的电脑了。<br>至少在硬件上，我们已经能够强人工智能了（中国的天河二号），而且十年以内，<br>我们就能以低廉的价格买到能够支持强人工智能的电脑硬件。<br>但是运算能力并不能让电脑变得智能，下一个问题是，我们怎样利用这份运算能<br>力来达成人类水平的智能。<br>通往强人工智能的第二步：让电脑变得智能<br>这一步比较难搞。事实上，没人知道该怎么搞——我们还停留在争论怎么让电脑<br>分辨《富春山居图》是部烂片的阶段。但是，现在有一些策略，有可能会有效。<br>下面是最常见的三种策略：</p>
<p>1) 抄袭人脑<br>就好像你班上有一个学霸。你不知道为什么学霸那么聪明，为什么考试每次都满<br>分。虽然你也很努力的学习，但是你就是考的没有学霸好。最后你决定 “老子不<br>干了，我直接抄他的考试答案好了。”这种“抄袭”是有道理的，我们想要建造一<br>个超级复杂的电脑，但是我们有人脑这个范本可以参考呀。<br>科学界正在努力逆向工程人脑，来理解生物进化是怎么造出这么个神奇的东西<br>的，乐观的估计是我们在2030年之前能够完成这个任务。一旦这个成就达成，<br>我们就能知道为什么人脑能够如此高效、快速的运行，并且能从中获得灵感来进<br>行创新。一个电脑架构模拟人脑的例子就是人工神经网络。它是一个由晶体管作<br>为“神经”组成的网络，晶体管和其它晶体管互相连接，有自己的输入、输出系统，<br>而且什么都不知道——就像一个婴儿的大脑。接着它会通过做任务来自我学习，<br>比如识别笔迹。最开始它的神经处理和猜测会是随机的，但是当它得到正确的回<br>馈后，相关晶体管之间的连接就会被加强；如果它得到错误的回馈，连接就会变<br>弱。经过一段时间的测试和回馈后，这个网络自身就会组成一个智能的神经路径，<br>而处理这项任务的能力也得到了优化。人脑的学习是类似的过程，不过比这复杂<br>一点，随着我们对大脑研究的深入，我们将会发现更好的组建神经连接的方法。<br>更加极端的“抄袭”方式是“整脑模拟”。具体来说就是把人脑切成很薄的片，用软<br>件来准确的组建一个3D 模型，然后把这个模型装在强力的电脑上。如果能做成，<br>这台电脑就能做所有人脑能做的事情——只要让它学习和吸收信息就好了。如果<br>做这事情的工程师够厉害的话，他们模拟出来的人脑甚至会有原本人脑的人格和<br>记忆，电脑模拟出的人脑就会像原本的人脑一样——这就是非常符合人类标准的<br>强人工智能，然后我们就能把它改造成一个更加厉害的超人工智能了。<br>我们离整脑模拟还有多远呢？至今为止，我们刚刚能够模拟1毫米长的扁虫的大<br>脑，这个大脑含有302个神经元。人类的大脑有1000亿个神经元，听起来还差很<br>远。但是要记住指数增长的威力——我们已经能模拟小虫子的大脑了，蚂蚁的<br>大脑也不远了，接着就是老鼠的大脑，到那时模拟人类大脑就不是那么不现实<br>的事情了。<br>2）模仿生物演化<br>抄学霸的答案当然是一种方法，但是如果学霸的答案太难抄了呢？那我们能不能<br>学一下学霸备考的方法？<br>首先我们很确定的知道，建造一个和人脑一样强大的电脑是可能的——我们的大<br>脑就是证据。如果大脑太难完全模拟，那么我们可以模拟演化出大脑的过程。事<br>实上，就算我们真的能完全模拟大脑，结果也就好像照抄鸟类翅膀的拍动来造飞<br>机一样——很多时候最好的设计机器的方式并不是照抄生物设计。<br>所以我们可不可以用模拟演化的方式来造强人工智能呢？这种方法叫作 “基因算<br>法”，它大概是这样的：建立一个反复运作的表现/评价过程，就好像生物通过生<br>存这种方式来表现，并且以能否生养后代为评价一样。一组电脑将执行各种任务，<br>最成功的将会“繁殖”，把各自的程序融合，产生新的电脑，而不成功的将会被剔<br>除。经过多次的反复后。这个自然选择的过程将产生越来越强大的电脑。而这个<br>方法的难点是建立一个自动化的评价和繁殖过程，使得整个流程能够自己运行。<br>这个方法的缺点也是很明显的，演化需要经过几十亿年的时间，而我们却只想花<br>几十年时间。<br>但是比起自然演化来说，我们有很多优势。首先，自然演化是没有预知能力的，<br>它是随机的——它产生的没用的变异比有用的变异多很多，但是人工模拟的演化<br>可以控制过程，使其着重于有益的变化。其次，自然演化是没有目标的，自然演<br>化出的智能也不是它目标，特定环境甚至对于更高的智能是不利的（因为高等智<br>能消耗很多能源）。但是我们可以指挥演化的过程超更高智能的方向发展。再次，<br>要产生智能，自然演化要先产生其它的附件，比如改良细胞产生能量的方法，但<br>是我们完全可以用电力来代替这额外的负担。所以，人类主导的演化会比自然快<br>很多很多，但是我们依然不清楚这些优势是否能使模拟演化成为可行的策略。<br>3）让电脑来解决这些问题<br>如果抄学霸的答案和模拟学霸备考的方法都走不通，那就干脆让考题自己解答自<br>己吧。这种想法很无厘头，确实最有希望的一种。<br>总的思路是我们建造一个能进行两项任务的电脑——研究人工智能和修改自己<br>的代码。这样它就不只能改进自己的架构了，我们直接把电脑变成了电脑科学家，<br>提高电脑的智能就变成了电脑自己的任务。<br>以上这些都会很快发生<br>硬件的快速发展和软件的创新是同时发生的，强人工智能可能比我们预期的更早<br>降临，因为：<br>1）指数级增长的开端可能像蜗牛漫步，但是后期会跑的非常快<br>2）软件的发展可能看起来很缓慢，但是一次顿悟，就能永远改变进步的速度。<br>就好像在人类还信奉地心说的时候，科学家们没法计算宇宙的运作方式，但是日<br>心说的发现让一切变得容易很多。创造一个能自我改进的电脑来说，对我们来说<br>还很远，但是可能一个无意的变动，就能让现在的系统变得强大千倍，从而开启<br>朝人类级别智能的冲刺。<br>强人工智能到超人工智能之路<br>总有一天，我们会造出和人类智能相当的强人工智能电脑，然后人类和电脑就会<br>平等快乐的生活在一起。<br>呵呵，逗你呢。<br>即使是一个和人类智能完全一样，运算速度完全一样的强人工智能，也比人类<br>有很多优势：<br>硬件上：<br>-速度。脑神经元的运算速度最多是200赫兹，今天的微处理器就能以2G 赫兹，<br>也就是神经元1000万倍的速度运行，而这比我们达成强人工智能需要的硬件还<br>差远了。大脑的内部信息传播速度是每秒120米，电脑的信息传播速度是光速，<br>差了好几个数量级。</p>
<ul>
<li>容量和储存空间。人脑就那么大，后天没法把它变得更大，就算真的把它变得<br>很大，每秒120米的信息传播速度也会成为巨大的瓶颈。电脑的物理大小可以非<br>常随意，使得电脑能运用更多的硬件，更大的内存，长期有效的存储介质，不但<br>容量大而且比人脑更准确。</li>
<li>可靠性和持久性。电脑的存储不但更加准确，而且晶体管比神经元更加精确，<br>也更不容易萎缩（真的坏了也很好修）。人脑还很容易疲劳，但是电脑可以24小<br>时不停的以峰值速度运作。<br>软件上来说：</li>
<li>可编辑性，升级性，以及更多的可能性。和人脑不同，电脑软件可以进行更多<br>的升级和修正，并且很容易做测试。电脑的升级可以加强人脑比较弱势的领域<br>——人脑的视觉元件很发达，但是工程元件就挺弱的。而电脑不但能在视觉元件<br>上匹敌人类，在工程元件上也一样可以加强和优化。</li>
<li>集体能力。人类在集体智能上可以碾压所有的物种。从早期的语言和大型社区<br>的形成，到文字和印刷的发明，再到互联网的普及。人类的集体智能是我们统治<br>其它物种的重要原因之一。而电脑在这方面比我们要强的很多，一个运行特定程<br>序的人工智能网络能够经常在全球范围内自我同步，这样一台电脑学到的东西会<br>立刻被其它所有电脑学得。而且电脑集群可以共同执行同一个任务，因为异见、<br>动力、自利这些人类特有的东西未必会出现在电脑身上。<br>通过自我改进来达成强人工智能的人工智能，会把“人类水平的智能”当作一个重<br>要的里程碑，但是也就仅此而已了。它不会停留在这个里程碑上的。考虑到强人<br>工智能之于人脑的种种优势，人工智能只会在“人类水平”这个节点做短暂的停<br>留，然后就会开始大踏步向超人类级别的智能走去。<br>这一切发生的时候我们很可能被吓尿，因为从我们的角度来看 a)虽然动物的智<br>能有区别，但是动物智能的共同特点是比人类低很多；b)我们眼中最聪明的人类<br>要比最愚笨的人类要聪明很很很很多。<br>所以，当人工智能开始朝人类级别智能靠近时，我们看到的是它逐渐变得更加智<br>能，就好像一个动物一般。然后，它突然达到了最愚笨的人类的程度，我们到时<br>也许会感慨：“看这个人工智能就跟个脑残人类一样聪明，真可爱。”<br>但问题是，从智能的大局来看，人和人的智能的差别，比如从最愚笨的人类到爱<br>因斯坦的差距，其实是不大的。所以当人工智能达到了脑残级别的智能后，它会<br>很快变得比爱因斯坦更加聪明：<br>之后呢？<br>智能爆炸<br>从这边开始，这个话题要变得有点吓人了。我在这里要提醒大家，以下所说的都<br>是大实话——是一大群受人尊敬的思想家和科学家关于未来的诚实的预测。你在<br>下面读到什么离谱的东西的时候，要记得这些东西是比你我都聪明很多的人想出<br>来的。<br>像上面所说的，我们当下用来达成强人工智能的模型大多数都依靠人工智能的自<br>我改进。但是一旦它达到了强人工智能，即使算上那一小部分不是通过自我改进<br>来达成强人工智能的系统，也会聪明到能够开始自我改进。<br>这里我们要引出一个沉重的概念——递归的自我改进。这个概念是这样的：一个<br>运行在特定智能水平的人工智能，比如说脑残人类水平，有自我改进的机制。当<br>它完成一次自我改进后，它比原来更加聪明了，我们假设它到了爱因斯坦水平。<br>而这个时候它继续进行自我改进，然而现在它有了爱因斯坦水平的智能，所以这<br>次改进会比上面一次更加容易，效果也更好。第二次的改进使得他比爱因斯坦还<br>要聪明很多，让它接下来的改进进步更加明显。如此反复，这个强人工智能的智<br>能水平越长越快，直到它达到了超人工智能的水平——这就是智能爆炸，也是加<br>速回报定律的终极表现。<br>现在关于人工智能什么时候能达到人类普遍智能水平还有争议。对于数百位科学<br>家的问卷调查显示他们认为强人工智能出现的中位年份是2040年——距今只有<br>25年。这听起来可能没什么，但是要记住，很多这个领域的思想家认为从强人<br>工智能到超人工智能的转化会快得多。以下的情景很可能会发生：一个人工智能<br>系统花了几十年时间到达了人类脑残智能的水平，而当这个节点发生的时候，<br>电脑对于世界的感知大概和一个四岁小孩一般；而在这节点后一个小时，电脑<br>立马推导出了统一广义相对论和量子力学的物理学理论；而在这之后一个半小<br>时，这个强人工智能变成了超人工智能，智能达到了普通人类的17万倍。<br>这个级别的超级智能不是我们能够理解的，就好像蜜蜂不会理解凯恩斯经济学一<br>样。在我们的语言中，我们把130的智商叫作聪明，把85的智商叫作笨，但是<br>我们不知道怎么形容12952的智商，人类语言中根本没这个概念。<br>但是我们知道的是，人类对于地球的统治教给我们一个道理——智能就是力量。<br>也就是说，一个超人工智能，一旦被创造出来，将是地球有史以来最强大的东西，<br>而所有生物，包括人类，都只能屈居其下——而这一切，有可能在未来几十年就<br>发生。<br>想一下，如果我们的大脑能够发明 Wifi，那么一个比我们聪明100倍、1000倍、<br>甚至10亿倍的大脑说不定能够随时随地操纵这个世界所有原子的位置。那些在<br>我们看来超自然的，只属于全能的上帝的能力，对于一个超人工智能来说可能就<br>像按一下电灯开关那么简单。防止人类衰老，治疗各种不治之症，解决世界饥荒，<br>甚至让人类永生，或者操纵气候来保护地球未来的什么，这一切都将变得可能。<br>同样可能的是地球上所有生命的终结。<br>当一个超人工智能出生的时候，对我们来说就像一个全能的上帝降临地球一般。<br>这 时 候 我 们 所 关 心 的 就 是<br>这篇文章的第一部分完了，我建议你休息一下，喝点水，下面我们要开始第二部<br>分。<br>第二部分开始：<br>文章的第一部分讨论了已经在我们日常生活中随处可见的弱人工智能，然后讨论<br>了为什么从弱人工智能到强人工智能是个很大的挑战，然后我们谈到了为什么技<br>术进步的指数级增长表面强人工智能可能并不那么遥远。第一部分的结束，我们<br>谈到了一旦机器达到了人类级别的智能，我们将见到如下的场景：</li>
</ul>
<p>这让我们无所适从，尤其考虑到超人工智能可能会发生在我们有生之年，我们都<br>不知道该用什么表情来面对。<br>再我们继续深入这个话题之前，让我们提醒一下自己超级智能意味着什么。<br>很重要的一点是速度上的超级智能和质量上的超级智能的区别。很多人提到和人<br>类一样聪明的超级智能的电脑，第一反应是它运算速度会非常非常快——就好像<br>一个运算速度是人类百万倍的机器，能够用几分钟时间思考完人类几十年才能思<br>考完的东西<br>这听起来碉堡了，而且超人工智能确实会比人类思考的快很多，但是真正的差别<br>其实是在智能的质量而不是速度上。用人类来做比喻，人类之所以比猩猩智能很<br>多，真正的差别并不是思考的速度，而是人类的大脑有一些独特而复杂的认知模<br>块，这些模块让我们能够进行复杂的语言呈现、长期规划、或者抽象思考等等，<br>而猩猩的脑子是做不来这些的。就算你把猩猩的脑子加速几千倍，它还是没有办<br>法在人类的层次思考的，它依然不知道怎样用特定的工具来搭建精巧的模型<br>——人类的很多认知能力是猩猩永远比不上的，你给猩猩再多的时间也不行。<br>而且人和猩猩的智能差别不只是猩猩做不了我们能做的事情，而是猩猩的大脑根<br>本不能理解这些事情的存在——猩猩可以理解人类是什么，也可以理解摩天大楼<br>是什么，但是它不会理解摩天大楼是被人类造出来的，对于猩猩来说，摩天大楼<br>那么巨大的东西肯定是天然的，句号。对于猩猩来说，它们不但自己造不出摩天<br>大楼，它们甚至没法理解摩天大楼这东西能被任何东西造出来。而这一切差别，<br>其实只是智能的质量中很小的差别造成的。<br>而当我们在讨论超人工智能时候，智能的范围是很广的，和这个范围比起来，人<br>类和猩猩的智能差别是细微的。如果生物的认知能力是一个楼梯的话，不同生物<br>在楼梯上的位置大概是这样的：<br>要理解一个具有超级智能的机器有多牛逼，让我们假设一个在上图的楼梯上站在<br>深绿色台阶上的一个机器，它站的位置只比人类高两层，就好像人类比猩猩只高<br>两层一样。这个机器只是稍微有点超级智能而已，但是它的认知能力之于人类，<br>就好像人类的认知能力之于猩猩一样。就好像猩猩没有办法理解摩天大楼是能被<br>造出来的一样，人类完全没有办法理解比人类高两层台阶的机器能做的事情。就<br>算这个机器试图向我们解释，效果也会像教猩猩造摩天大楼一般。<br>而这，只是比我们高了两层台阶的智能罢了，站在这个楼梯顶层的智能之于人类，<br>就好像人类之于蚂蚁一般——它就算花再多时间教人类一些最简单的东西，我们<br>依然是学不会的。<br>但是我们讨论的超级智能并不是站在这个楼梯顶层，而是站在远远高于这个楼梯<br>的地方。当智能爆炸发生时，它可能要花几年时间才能从猩猩那一层往上迈一步，<br>但是这个步子会越迈越快，到后来可能几个小时就能迈一层，而当它超过人类十<br>层台阶的时候，它可能开始跳着爬楼梯了——一秒钟爬四层台阶也未尝不可。所<br>以让我们记住，当第一个到达人类智能水平的强人工智能出现后，我们将在很短<br>的时间内面对一个站在下图这样很高很高的楼梯上的智能（甚至比这更高百万<br>倍）：<br>前面已经说了，试图去理解比我们高两层台阶的机器就已经是徒劳的，所以让我<br>们很肯定的说，我们是没有办法知道超人工智能会做什么，也没有办法知道这些<br>事情的后果。任何假装知道的人都没搞明白超级智能是怎么回事。<br>自然演化花了几亿年时间发展了生物大脑，按这种说法的话，一旦人类创造出一<br>个超人工智能，我们就是在碾压自然演化了。当然，可能这也是自然演化的一部<br>分——可能演化真正的模式就是创造出各种各样的智能，直到有一天有一个智能<br>能够创造出超级智能，而这个节点就好像踩上了地雷的绊线一样，会造成全球范<br>围的大爆炸，从而改变所有生物的命运。<br>科学界中大部分人认为踩上绊线不是会不会的问题，而是时间早晚的问题。想想<br>真吓人。<br>那我们该怎么办呢？<br>可惜，没有人都告诉你踩到绊线后会发生什么。但是人工智能思想家 Nick<br>Bostrom 认为我们会面临两类可能的结果——永生和灭绝。<br>首先，回顾历史，我们可以看到大部分的生命经历了这样的历程：物种出现，存<br>在了一段时间，然后不可避免的跌落下生命的平衡木，跌入灭绝的深渊。<br>历史上来说，“所有生物终将灭绝”就像“所有人都会死”一样靠谱。至今为止，存<br>在过的生物中99.9%都已经跌落了生命的平衡木，如果一个生物继续在平衡木上<br>走，早晚会有一阵风把它吹下去。Bostrom 把灭绝列为一种吸引态——所有生<br>物都有坠入的风险，而一旦坠入将没有回头。<br>虽然大部分科学家都承认一个超人工智能有把人类灭绝的能力，也有一些人为如<br>果运用得当，超人工智能可以帮助人类和其它物种，达到另一个吸引态——永生。<br>Bostrom 认为物种的永生和灭绝一样都是吸引态，也就是我一旦我们达成了永<br>生，我们将永远不再面临灭绝的危险——我们战胜了死亡和几率。所以，虽然绝<br>大多数物种都从平衡木上摔了下去灭绝了，Bostrom 认为平衡木外是有两面的，<br>只是至今为止地球上的生命还没聪明到发现怎样去到永生这另一个吸引态。<br>如果 Bostrom 等思想家的想法是对的，而且根据我的研究他们确实很可能是对<br>的，那么我们需要接受两个事实：<br>1）超人工智能的出现，将有史以来第一次，将物种的永生这个吸引态变为可能<br>2）超人工智能的出现，将造成非常巨大的冲击，而且这个冲击可能将人类吹下<br>平衡木，并且落入其中一个吸引态<br>有可能，当自然演化踩到绊线的时候，它会永久的终结人类和平衡木的关系，创<br>造一个新的世界，不管这时人类还是不是存在。<br>而现在的问题就是：“我们什么时候会踩到绊线？”以及“从平衡木上跌下去后我<br>们会掉入哪个吸引态？”<br>没人知道答案，但是一些聪明人已经思考了几十年，接下来我们看看他们想出来<br>了些什么。</p>
<hr>
<p>先来讨论“我们什么时候会踩到绊线？”也就是什么时候会出现第一个超级智能。<br>不出意外的，科学家和思想家对于这个意见的观点分歧很大。很多人，比如<br>Vernor Vinge 教授，科学家 Ben Goertzel，SUN 创始人 Bill Joy，发明家和未<br>来学家 Ray Kurzweil，认同机器学习专家 Jeremy Howard 的观点，Howard<br>在 TED 演 讲 时 用 到 了 这 张 图 ：<br>这些人相信超级智能会发生在不久的将来，因为指数级增长的关系，虽然机器学<br>习现在还发展缓慢，但是在未来几十年就会变得飞快。<br>其它的，比如微软创始人 Paul Allen，心理学家 Gary Marcus，NYU 的电脑科<br>学家 Ernest Davis，以及科技创业者 Mitch Kapor 认为 Kurzweil 等思想家低估<br>了人工智能的难度，并且认为我们离绊线还挺远的。<br>Kurzweil 一派则认为唯一被低估的其实是指数级增长的潜力，他们把质疑他们<br>理论的人比作那些1985年时候看到发展速度缓慢的因特网，然后觉得因特网在<br>未来不会有什么大影响的人一样。<br>而质疑者们则认为智能领域的发展需要达到的进步同样是指数级增长的，这其实<br>把技术发展的指数级增长抵消了。<br>争论如此反复。<br>第三个阵营，包括 Nick Bostrom 在内，认为其它两派都没有理由对踩绊线的时<br>间那么有信心，他们同时认为 a) 这事情完全可能发生在不久的未来 b)但是这<br>个事情没个准，说不定会花更久<br>还有不属于三个阵营的其他人，比如哲学家 Hubert Dreyfus，相信三个阵营都<br>太天真了，根本就没有什么绊线。超人工智能是不会被实现的。<br>当你把所有人的观点全部融合起来的话是怎样呢？<br>2013年的时候，Bostrom 做了个问卷调查，涵盖了数百位人工智能专家，问卷<br>的内容是“你预测人类级别的强人工智能什么时候会实现”，并且让回答者给出一<br>个乐观估计（强人工智能有10%的可能在这一年达成），正常估计（有50%的可<br>能达成），和悲观估计（有90%可能达成）。当把大家的回答统计后，得出了下面<br>的结果：<br>乐观估计中位年（强人工智能有10%的可能在这一年达成）：2022年<br>正常估计中位年（强人工智能有50%的可能在这一年达成）：2040年<br>悲观估计中位年（强人工智能有90%的可能在这一年达成）：2075年<br>所以一个中位的人工智能专家认为25年后的2040年我们能达成强人工智能，而<br>2075年这个悲观估计表明，如果你现在够年轻，有一半以上的人工智能专家认<br>为在你的有生之年能够有90%的可能见到强人工智能的实现。<br>另外一个独立的调查，由作家 James Barrat 在 Ben Goertzel 的强人工智能年<br>会上进行，他直接问了参与者认为强人工智能哪一年会实现，选项有2030年，<br>2050年，2100年，和永远不会实现。结果是：<br>2030年：42%的回答者认为强人工智能会实现<br>2050年：25%的回答者<br>2100年：20%<br>2100年以后：10%<br>永远不会实现：2%<br>这个结果和 Bostrom 的结果很相似。在 Barrat 的问卷中，有超过三分之二的参<br>与者认为强人工智能会在2050年实现，有近乎半数（42%）的人认为未来15年<br>（2030年）就能实现。并且，只有2%的参与者认为强人工智能永远不会实现。<br>但是强人工智能并不是绊线，超人工智能才是。那么专家们对超人工智能是怎么<br>想的呢？<br>Bostrom 的问卷还询问专家们认为达到超人工智能要多久，选项有 a)达成强人<br>工智能两年内，b)达成强人工智能30年内。问卷结果如下：<br>中位答案认为强人工智能到超人工智能只花2年时间的可能性只有10%左右，但<br>是30年之内达成的可能性高达75%<br>从以上答案，我们可以估计一个中位的专家认为强人工智能到超人工智能可能要<br>花20年左右。所以，我们可以得出，现在全世界的人工智能专家中，一个中位<br>的估计是我们会在2040年达成强人工智能，并在20年后的2060年达成超人工智<br>能——也就是踩上了绊线。<br>当然，以上所有的数据都是推测，它只代表了现在人工智能领域的专家的中位意<br>见，但是它告诉我们的是，很大一部分对这个领域很了解的人认为2060年是一<br>个实现超人工智能的合理预测——距今只有45年。<br>那么我们来看一下下一个问题，踩到绊线后，我们将跌向平衡木的哪一个方向？<br>超级智能会产生巨大的力量，所以关键的问题时——到时这股力量究竟由谁掌<br>握，掌握这份力量的人会怎么做？<br>这个问题的答案将决定超人工智能究竟是天堂还是地狱。<br>同样的，专家们在这个问题上的观点也不统一。Bostrom 的问卷显示专家们看<br>待强人工智能对于人类社会的影响时，52%认为结果会是好或者非常好的，31%<br>认为会是糟糕的或者非常糟糕的，只有17%的人认为结果会是不好不坏的。也就<br>是说，这个领域的专家普遍认为这将是一个很大的事情，不论结果好坏。要注意<br>的是，这个问题问的是强人工智能，如果问的是超人工智能，认为结果不好不坏<br>的人可能不会有17%这么多。<br>在我们深入讨论好坏这个问题之前，我们先把 “什么时候会发生”和“这是好事还<br>是坏事”的结果综合起来画张表，这代表了大部分专家的观点：<br>我们等下再考虑主流阵营的观点。咱们先来问一下你自己是怎么想的，其实我大<br>概能猜到你是怎么想的，因为我开始研究这个问题前也是这样的想的。很多人其<br>实不关心这个话题，原因无非是：<br>像本文第一部分所说，电影展示了很多不真实的人工智能场景，让我们认为人工<br>智能不是正经的课题。作家 James Barrat 把这比作传染病控制中心发布吸血鬼<br>警报一样滑稽。<br>因为认知偏差，所以我们在见到证据前很难相信一件事情是真的。我确信1988<br>年的时候电脑科学家们就已经常在讨论因特网将是多么重要，但是一般人并不会<br>认为因特网会改变他们的生活——直到他们的生活真的被改变了。一方面，1988<br>年的电脑确实不够给力，所以那时的人们看着电脑会想：“这破玩意儿也能改变<br>我的生活，你逗我吧？”人们的想象力被自己对于电脑的体验而约束。让他们难<br>以想象电脑会变成现在的样子。同样的事情正发生在人工智能领域。我们听到很<br>多人说人工智能将会造成很大影响，但是因为这个事情还没发生，因为我们和一<br>些弱爆了的人工智能系统的个人经历，让我们难以相信这东西真的能改变我们的<br>生活。而这些认知偏差，正是专家们在努力对抗的。<br>就算我们相信人工智能的巨大潜力，你今天又花了多少时间思考 “在接下来的永<br>恒中，绝大部分时间我都不会再存在”这个问题？虽然这个问题比你今天干的大<br>部分事情都重要很多，但是正常人都不会老是想这个吧。这是因为你的大脑总是<br>关注日常的小事，不管长期来看有多少重要的事情，我们天生就是这么思考的。<br>这篇东西的主要目标就是让你脱离普通人阵营，加入专家思考的阵营，哪怕能让<br>你站到两条不确定线的交点上，目标也达到了。<br>在我的研究中，我见识到了各种各样的观点，但是我发现大多数人的观点都停留<br>在主流阵营中。事实上超过四分之三的专家都属于主流阵营中的两个小阵营：焦<br>虑大道和信心角<br>我们将对这两个小阵营做深入的谈论，让我们从比较有趣的那个开始吧<br>为什么未来会是天堂<br>研究人工智能这个领域后，我发现有比预期的多得多的人站在信心角当中：<br>站在信心角中的人非常兴奋，他们认为他们将走向平衡木下比较有趣的那个吸引<br>态，未来将实现他们的梦想，他们只需耐心等待。<br>把这一部分人从其他思想家区分开来的是这些人对于比较有趣的那个吸引态的<br>欲望——他们很有信心永生是我们的发展方向。<br>这份信心是哪里来的不好说，评论家认为是这些人太过兴奋而产生了盲点，忽略<br>了可能的负面结果。但是信心角的人还是把批评者当作末日论者来看待，他们认<br>为技术会继续帮助我们而不是伤害我们。<br>两边的观点我们都会说，这样你能形成自己的观点，但是在读下面的内容前，请<br>把质疑暂时搁置，让我们看看平衡木两边究竟有什么，并且记住这些事情是有可<br>能发生的。如果我们给一个打猎采集者看我们现在的舒适家居、技术、富庶，在<br>他眼里这一切也会像魔法一样——我们也要接受未来完全可能出现能把我们吓<br>尿的变革。<br>Bostrom 描述了三种超人工智能可能的工作模式</p>
<ul>
<li>先知模式：能准确回答几乎所有的问题，包括对人类来说很困难的复杂问题，<br>比如“怎样造一个更好的汽车引擎？”</li>
<li>精灵模式：能够执行任何高级指令，比如用分子组合器造一个更好的汽车引擎<br>出来</li>
<li>独立意志模式（sovereign）:可以执行开放式的任务，能在世界里自由活动，<br>可以自己做决定，比如发明一种比汽车更快、更便宜、更安全的交通模式。<br>这些对人类来说很复杂的问题，对于一个超级智能来说可能就像 “我的笔掉了，<br>你能帮我捡一下吗？”这么简单。<br>Eliezer Yudkowsky，是这么说的：<br>“根本没有困难的问题，只有对于特定级别的智能来说难的问题。在智能的阶梯<br>上走一小步，一些不可能的问题就变得简单了，如果走一大步，所有问题都变得<br>简单了。”<br>信心角里有很多热忱的科学家、发明家和创业者，但是对于人工智能的未来最有<br>发言权的，当属 Ray Kurzweil.<br>对于 Kurzweil 的评价非常两极化，既有如对神人般的崇拜，也有翻白眼似的不<br>屑。也有一些中立主义者，比如作家 Douglas Hofstadter，他觉得 Kurzweil<br>的观点就好像把美食和狗屎混在一起，让你分不清是好是坏。<br>不管你同不同意 Kurzweil 的观点，他都是一个牛人。他年轻时候就开始搞发明，<br>之后几十年发明了很多东西，比如第一台平板扫描仪，第一台能把文字转化为语<br>言的扫描仪（盲人使用），著名的 Kurzweil 音乐合成器（第一台真正意义上的电<br>子钢琴），以及第一套商业销售的语音识别系统。他是五本畅销书的作者。他很<br>喜欢做大胆的预测，而且一直很准，比如他80年代末的时候预测到2000年后因<br>特网会成为全球级的现象。他被《华尔街日报》成为“不休的天才”，被《福布斯》<br>称为“终极思想机器”，被《Inc.》称作“爱迪生真正的传人”，被比尔盖茨称为“我<br>认识的对人工智能预测最厉害的人。”2012年谷歌创始人 Larry Page 曾邀请他<br>担任谷歌的工程总监，2011年他共同创立了奇点大学（Singularity University），<br>现在大学由美国太空总署运运营，由谷歌赞助。<br>Kurzweil 的经历很重要，因为当他讲述自己对未来的愿景时，他听起来就是个<br>疯子，但是他不疯，恰恰相反，他非常聪明而有知识。你可能觉得他对于未来的<br>想法是错的，但是他不傻。知道他是一个聪明人让我很开心，因为当我知道他对<br>未来的预测后，我急切的很希望他的预测是对的。信心角中的很多思想家都认同<br>Kurzweil 的预测，他也有很多粉丝，被称为奇点主义者。<br>时间线<br>Kurzweil 相信电脑会在2029年达成强人工智能，而到了2045年，我们不但会<br>有超人工智能，还会有一个完全不同的世界——奇点时代。他的人工智能时间线<br>曾经被认为非常的狂热，现在也还是有很多人这么认为，但是过去15年弱人工<br>智能的快速发展让更多的专家靠近了 Kurzweil 的时间线。虽然他的时间线比之<br>前提到的2040年和2060年更加早，但是并没有早多少。<br>Kurzweil 的奇点时代是三个技术领域的共同革命造成的——生物技术、纳米技<br>术和最重要的人工智能技术。<br>在我们继续讨论人工智能前，让我们谈一下纳米技术这个任何关于人工智能的讨<br>论都会涉及到的领域<br>纳米技术<br>纳米技术说的是在1-100纳米的范围内操纵物质的技术。一纳米是一米的十亿分<br>之一，是一毫米的一百万分之一。1-100纳米这个范围涵盖了病毒（100纳米长），<br>DNA（10纳米宽）， 大分子比如血红蛋白（5纳米），和中分子比如葡萄糖（1<br>纳米）。当我们能够完全掌握纳米技术的时候，我们离在原子层面操纵物质就只<br>差一步了，因为那只是一个数量级的差距（约0.1纳米）。<br>要了解在纳米量级操纵物质有多困难，我们可以换个角度来比较。国际空间站距<br>离地面431公里。如果一个人身高431公里，也就是他站着能够顶到国际空间站<br>的话，他将是普通人类的25万倍大。如果你把1-100纳米放大25万倍，你算出<br>的是0.25毫米-25毫米。所以人类使用纳米技术，就相当于一个身高431公里的<br>巨人用沙子那么大的零件搭精巧的模型。如果要达到原子级别操纵物质，就相当<br>于让这个431公里高的巨人使用0.025毫米大的零件。<br>关于纳米技术的思考，最早由物理学家费曼在1959年提出，他解释道：“据我所<br>知，物理学的原理，并不认为在原子级别操纵物质是不可能的。原则上来说，物<br>理学家能够制造出任何化学家能写出来的物质——只要把一个个原子按照化学<br>家写出来的放在一起就好了。”其实就是这么简单，所以我们只要知道怎样移动<br>单个的分子和原子，我们就可以造出任何东西。<br>工程师 Eric Drexler 提出纳米级组装机后，纳米技术在1986年成为了一门正经<br>的学科。纳米级组装机的工作原理是这样的：一个牛逼扫描仪扫描物件的3D 原<br>子模型，然后自动生成用来组装的软件。然后由一台中央电脑和数万亿的纳米“机<br>器人”，通过软件用电流来指挥纳米机器人，最后组成所需要的物件。</li>
</ul>
<hr>
<p>再扯远一点<br>纳米技术有一些不是那么有趣的部分——能够制造数万亿的纳米机器人唯一合<br>理的方法就是制造可以自我复制的范本，然后让指数级增长来完成建造任务。很<br>机智吧？<br>是很机智，但是这一不小心就会造成世界末日。指数级增长虽然能很快的制造数<br>万亿的纳米机器人，但这也是它可怕的地方——如果系统出故障了，指数级增长<br>没有停下来，那怎么办？纳米机器人将会吞噬所有碳基材料来支持自我复制，而<br>不巧的是，地球生命就是碳基的。地球上的生物质量大概包含10^45个碳原子。<br>一个纳米机器人有10^6个碳原子的话，只需要10^39个纳米机器人就能吞噬地<br>球上全部的生命了，而2^130约等于10^39，也就是说自我复制只要进行130<br>次就能吞噬地球生命了。科学家认为纳米机器人进行一次自我复制只要100秒左<br>右，也就是说一个简单的错误可能就会在3.5小时内毁灭地球上全部的生命。<br>更糟糕的是，如果恐怖分子掌握了纳米机器人技术，并且知道怎么操纵它们的话，<br>他可以先造几万亿个纳米机器人，然后让它们散播开来。然后他就能发动袭击，<br>这样只要花一个多小时纳米机器人就能吞噬一切，而且这种攻击无法阻挡。未来<br>真的是能把人吓尿的。</p>
<hr>
<p>等我们掌握了纳米技术后，我们就能用它来制造技术产品、衣服、食物、和生物<br>产品，比如人造红细胞、癌症细胞摧毁者、肌肉纤维等等。而在纳米技术的世界<br>里，一个物质的成本不再取决于它的稀缺程度或是制造流程的难度，而在于它的<br>原子结构有多复杂。在纳米技术的时代，钻石可能比橡皮擦还便宜。<br>我们还没掌握这种技术，我们甚至不知道我们对于达成这种技术的难度是高估了<br>还是低估了，但是我们看上去离那并不遥远。Kurzweil 预测我们会在21世纪20<br>年代掌握这样的技术。各国政府知道纳米技术将能改变地球，所以他们投入了很<br>多钱到这个领域，美国、欧盟和日本至今已经投入了50亿美元。<br>设想一下，一个具有超级智能的电脑，能够使用纳米级的组装器，是种什么样的<br>体验？要记得纳米技术是我们在研究的玩意儿，而且我们就快掌握这项技术了，<br>而我们能做的一切在超人工智能看来就是小儿科罢了，所以我们要假设超人工智<br>能能够创造出比这要发达很多很多的技术，发达到我们的大脑都没有办法理解。<br>因此，当考虑“如果人工智能革命的成果对我们是好的”这个命题的时候，要记得<br>我们根本没法高估会发生什么。所以就算下面对于超人工智能的预测显得太不靠<br>谱，要记得这些进展可能是用我们没有办法想象的方法达成的。事实上，我们的<br>大脑很可能根本没法预测将会发生什么。</p>
<hr>
<p>人工智能能为我们做什么<br>拥有了超级智能和超级智能所能创造的技术，超人工智能可以解决人类世界的所<br>有问题。气候变暖？超人工智能可以用更优的方式产生能源，完全不需要使用化<br>石燃料，从而停止二氧化碳排放。然后它能创造方法移除多余的二氧化碳。癌症？<br>没问题，有了超人工智能，制药和健康行业将经历无法想象的革命。世界饥荒？<br>超人工智能可以用纳米技术直接搭建出肉来，而这些搭建出来的肉和真肉在分子<br>结构上会是完全相同的——换句话说，就是真肉。<br>纳米技术能够把一堆垃圾变成一堆新鲜的肉或者其它食品，然后用超级发达的交<br>通把这些食物分配到世界各地。这对于动物也是好消息，我们不需要屠杀动物来<br>获得肉了。而超人工智能在拯救濒危物种和利用 DNA 复活已灭绝物种上面也能<br>做很多事情。超人工智能甚至可以解决复杂的宏观问题——我们关于世界经济和<br>贸易的争论将不再必要，甚至我们对于哲学和道德的苦苦思考也会被轻易的解<br>决。<br>但是，有一件事是如此的吸引人，光是想想就能改变对所有事物的看法了：<br>几个月前，我提到我很羡慕那些可能达成了永生的文明。但是，现在，我已经在<br>认真的考虑达成永生这个事情很可能在我们有生之年就能达成。研读人工智能让<br>你重新审思对于所有事情的看法，包括死亡这一很确定的事情。<br>自然演化没有理由让我们活得比现在更长。对于演化来说，只要我们能够活到能<br>够生育后代，并且养育后代到能够自己保护自己的年纪，那就够了——对演化来<br>说，活30多岁完全够了，所以额外延长生命的基因突变并不被自然选择所钟爱。<br>这其实是很无趣的事情。<br>而且因为所有人都会死，所以我们总是说“死亡和缴税”是不可避免的。我们看待<br>衰老就像看待时间一样——它们一直向前，而我们没有办法阻止它们。<br>但是这个假设是错的，费曼曾经写道：<br>“在所有的生物科学中，没有任何证据说明死亡是必需的。如果你说你想造永动<br>机，那我们对于物理学的研究已经让我们有足够的理论来说明这是不可能的。但<br>是在生物领域我们还没发现任何证据证明死亡是不可避免的。也就是说死亡不一<br>定是不可避免的，生物学家早晚会发现造成我们死亡的原因是什么，而死亡这个<br>糟糕的‘病’就会被治好，而人类的身体也将不再只是个暂时的容器。”<br>事实上，衰老和时间不是绑死的。时间总是会继续前进的，而衰老却不一定。仔<br>细想想，衰老只是身体的组成物质用旧了。汽车开久了也会旧，但是汽车一定会<br>衰老吗？如果你能够拥有完美的修复技术、或者直接替换老旧的汽车部件，这辆<br>车就能永远开下去。人体只是更加复杂而已，本质上和汽车是一样的。<br>Kurzweil 提到由 Wifi 连接的纳米机器人在血液中流动，可以执行很多人类健康<br>相关的任务，包括日常维修，替换死去的细胞等等。如果这项技术能够被完美掌<br>握，这个流程（或者一个超人工智能发明的更好的流程）将能使人的身体永远健<br>康，甚至越活越年轻。一个60岁的人和一个30岁的人身体上的区别只是物理上<br>的，只要技术足够发达我们是能改变这种区别的。<br>超人工智能可以建造一个“年轻机器”，当一个60岁的人走进去后，再出来时就拥<br>有了年轻30岁的身体。就算是逐渐糊涂的大脑也可能年轻化，只要超人工智能<br>足够聪明，能够发现不影响大脑数据的方法来改造大脑就好了。一个90岁的失<br>忆症患者可以走进“年轻机器”，再出来时就拥有了年轻的大脑。这些听起来很离<br>谱，但是身体只是一堆原子罢了，只要超人工智能可以操纵各种原子结构的话，<br>这就完全不离谱。<br>Kurzweil 的思维继续跳跃了一下，他相信人造材料将越来越多的融入人体。最<br>开始，人体器官将被先进的机械器官所代替，而这些机械器官可以一直运行下去。<br>然后我们会开始重新设计身体，比如可以用自我驱动的纳米机器人代替血红细<br>胞，这样连心脏都省了。Kurzweil 甚至认为我们会改造自己的大脑，使得我们<br>的思考速度比现在快亿万倍，并且使得大脑能和云存储的信息进行交流。<br>我们能获得的新体验是无穷的。人类的性爱，使得人们不但能生育，还能从中享<br>乐。Kurtzweil 认为我们可以对食物做同样的改造。纳米机器人可以负责把身体<br>需要的营养物质传送到细胞中，智能的将对身体不好的东西排出体外——就像一<br>个食物避孕套一样。纳米技术理论家 Robert A. Freitas 已经设计了一种红细胞<br>的替代品，能够让人快速冲刺15分钟不需要呼吸——那么超人工智能能对我们<br>的身体能力做的改造就更加难以想象。虚拟现实将拥有新的意义——体内的纳米<br>机器人将能控制我们从感官获得的信号，然后用别的信号替代他们，让我们进入<br>一个新的环境，在新环境里，我们能听、看、闻、触摸。。。<br>最终，Kurzweil 认为人类会完全变成人工的。有一天当我们看到生物材料，然<br>后觉得生物材料实在太原始了，早年的人体居然是用这样的东西组成的，早期的<br>人类居然会被微生物、意外、疾病杀死。这就是 Kurzweil 眼中人类最终战胜自<br>己的生理，并且变得不可摧毁和永生，这也是平衡木的另一个吸引态。他深深的<br>想象我们会达到那里，而且就在不久的将来。<br>Kurzweil 的想法很自然的受到了各方的批评。他对于2045年奇点时代的到来，<br>以及之后的永生的可能性受到了各种嘲笑——“书呆子的狂欢”、“高智商人士的<br>创始论”等等。也有人质疑他过于乐观的时间线，以及他对人脑和人体的理解程<br>度，还有他将摩尔定于应用到软件上的做法。有很多人相信他，但有更多人反对<br>他。<br>但是即使如此，那些反对他的专家并不是反对他所说的一切，反对他的人说的不<br>是“这种事情不可能发生”，而是说“这些当然可能发生，但是到达超人工智能是<br>很难的。”连经常提醒我们人工智能的潜在威胁的 Bostrom 都这么说：<br>很难想象一个超级智能会有什么问题是解决不了，或是不能帮着我们解决的。疾<br>病、贫困、环境毁灭、各种不必要的苦难，这些都是拥有纳米科技的超级智能能<br>够解决的。而且，超级智能可以给我们无限的生命，这可以通过停止或者逆转衰<br>老来达成，也可以让我们上传自己的数据。一个超级智能还能让我们大幅度提高<br>智商和情商，还能帮助我们创造这种有趣的体验世界，让我们享乐。<br>这是 Bostrom 这个明显不在信心角的人的观点，但也是很多反对 Kurzweil 的专<br>家的观点，他们不觉得 Kurzweil 是在说梦话，只是觉得我们首先要安全达成超<br>人工智能。这也是为什么我觉得 Kurzweil 的观点很有传染性，他传达了正面的<br>信息，而这些事情都是可能的——如果超人工智能是个仁慈的神的话。<br>对信心角的最有力的批评，是那些信心角里的人都低估了超人工智能的坏处。<br>Kurzweil 的畅销书《The Singularity is Near》700多页，只有20页用来讨论人<br>工智能的危险。前面提到，当超人工智能降临时我们的命运取决于谁掌握这股力<br>量，以及他们是不是好人。Kurzweil 的回答是“超人工智能正从多方的努力中出<br>现，它将深深的融入我们文明的基建中。它会亲密的被捆绑在我们的身体和大脑<br>中，它会反映我们的价值，因为它就是我们。”<br>但如果答案就是这样的话，为什么这个世界上最聪明的一些人会很担忧？为什么<br>霍金会说超人工智能会毁灭人类？为什么比尔盖茨会不理解为什么有人不为此<br>担忧？为什么马斯克会担心我们是在召唤恶魔？为什么那么多专家担心超人工<br>智能是对人类最大的威胁？这些站在焦虑大道上的思想家，不认同 Kurzweil 对<br>于人工智能的危险的粉饰。他们非常非常担心人工智能革命，他们不关注平衡木<br>下比较有趣的那一个吸引态，而是盯着平衡木的另一边，而他们看到的是可怕的<br>未来，一个我们未必能够逃离的未来。</p>
<hr>
<p>未来可能是我们最糟的恶梦<br>我想了解人工智能的一个原因是“坏机器人”总是让我很困惑。那些关于邪恶机器<br>人的电影看起来太不真实，我也没法想象一个人工智能变得危险的真实情况。机<br>器人是我们造的，难道我们不会在设计时候防止坏事的发生吗？我们难道不能设<br>立很多安全机制吗？再不济，难道我们不能拔插头吗？而且为什么机器人会想要<br>做坏事？或者说，为什么机器人会“想要”做任何事？我充满疑问，于是我开始了<br>解聪明人们的想法。<br>这些人一般位于焦虑大道：<br>焦虑大道上的人并不是恐慌或者无助的——恐慌和无助在图上的位置是更加左<br>边——他们只是紧张。位于图表的中央不代表他们的立场是中立的——真正中立<br>的人有自己独立的阵营，他们认同极好和极坏两种可能，但是不确定究竟会是哪<br>个。<br>焦虑大道上的人是部分为超人工智能感到兴奋的——他们只是很担心人类现在<br>的表现就好像《夺宝奇兵》中的这位少年：<br>他拿着自己的鞭子和宝物，非常开心，然后他就挂了：<br>同时，印第安纳琼斯则更加有见识和更加谨慎，了解潜在的危险并且做出相应的<br>反应，最后安全逃出了山洞。当我了解了焦虑大道的人们的想法后，感觉就像“我<br>们现在傻呵呵的，很容易像前面那小子一样被弄死，还是努力做印第安纳琼斯<br>吧。”<br>那究竟是什么让焦虑大道的人们如此焦虑呢？<br>首先，广义上来讲，在创造超人工智能时，我们其实是在创造可能一件会改变所<br>有事情的事物，但是我们对那个领域完全不清楚，也不知道我们到达那块领域后<br>会发生什么。科学家 Danny Hillis 把这个比作“就好像单细胞生物向多细胞生物<br>转化的时候那样，还是阿米巴虫的我们没有办法知道我们究竟在创造什么鬼。”<br>Bostrom 则担忧创造比自身聪明的东西是个基础的达尔文错误，就好像麻雀妈<br>妈决定收养一只小猫头鹰，并且觉得猫头鹰长大后会保护麻雀一家，但是其它麻<br>雀却觉得这是个糟糕的主意。<br>当你把“对那个领域完全不清楚”和“当它发生时将会产生巨大的影响”结合在一<br>起时，你创造出了一个很恐怖的词——<br>生存危机指可能对人类产生永久的灾难性效果的事情。通常来说，生存危机意味<br>着灭绝。下面是 Bostrom 的图表：<br>可以看到，生存危机是用来指那些跨物种、跨代（永久伤害）并且有严重后果的<br>事情。它可以包括人类遭受永久苦难的情况，但是这基本上和灭绝没差了。三类<br>事情可能造成人类的生存危机：<br>1）自然——大型陨石冲撞，大气变化使得人类不能生活在空气中，席卷全球的<br>致命病毒等<br>2）外星人——霍金、卡尔萨根等建议我们不要对外广播自己的位置。他们不想<br>我们变成邀请别人来殖民的傻子。<br>3）人类——恐怖分子获得了可以造成灭绝的武器，全球的灾难性战争，还有不<br>经思考就造出个比我们聪明很多的智能<br>Bostrom 指出1和2在我们物种存在的前十万年还没有发生，所以在接下来一个<br>世纪发生的可能性不大。3则让他很害怕，他把这些比作一个装着玻璃球的罐子，<br>罐子里大部分是白色玻璃球，小部分是红色的，只有几个是黑色的。每次人类发<br>明一些新东西，就相当于从罐中取出一个玻璃球。大多数发明是有利或者中立的<br>——那些是白色玻璃球。有些发明对人类是有害的，比如大规模杀伤性武器——<br>这是那些红色玻璃球。还有一些发明是可以让我们灭绝的，这就是那些黑色玻璃<br>球。很明显的，我们还没摸到黑色玻璃球，但是 Bostrom 认为不久的未来摸到<br>一个黑色玻璃球不是完全不可能的。比如核武器突然变得很容易制造了，那恐怖<br>分子很快会把我们炸回石器时代。核武器还算不上黑色玻璃球，但是差的不远了。<br>而超人工智能是我们最可能摸到的黑色玻璃球。<br>你会听到很多超人工智能带来的坏处——人工智能取代人类工人，造成大量失<br>业；因为解决了衰老造成的人口膨胀。但是真正值得我们担心的是生存危机的可<br>能性。<br>于是我们又回到了前面的问题，当超人工智能降临时，谁会掌握这份力量，他们<br>又会有什么目标？<br>当我们考虑各种力量持有人和目标的排列组合时，最糟糕的明显是：怀着恶意的<br>人/组织/政府，掌握着怀有恶意的超人工智能。这会是什么样的情况呢？<br>怀着恶意的人/组织/政府，研发出第一个超人工智能，并且用它来实现自己的邪<br>恶计划。我把这称作贾法尔情况。阿拉丁神灯故事中，坏人贾法尔掌握了一个精<br>灵，特别让人讨厌。所以如果 ISIS 手下有一群工程师狂热的研发人工智能怎么<br>办？或者说伊朗和朝鲜，机缘巧合，不小心造成了人工智能的快速发展，达成了<br>超人工智能怎么办？这当然是很糟糕的事，但是大部分专家认为糟糕的地方不在<br>于这些人是坏人，而在于在这些情况下，这些人基本上是不经思考就把超人工智<br>能造出来，而一造出来就失去了对超人工智能的控制。<br>然后这些创造者，连着其他人的命运，都取决于这个超人工智能的动机了。专家<br>认为一个怀着恶意并掌握着超人工智能的人可以造成很大的伤害，但不至于让<br>我们灭绝，因为专家相信坏人和好人在控制超人工智能时会面临一样的挑战。<br>如果被创造出来的超人工智能是怀有恶意的，并且决定毁灭我，怎么办？这就是<br>大部分关于人工智能的电影的剧情。人工智能变得和人类一样聪明，甚至更加聪<br>明，然后决定对人类下手——这里要指出，那些提醒我们要警惕人工智能的人谈<br>的根本不是这种电影情节。邪恶是一个人类的概念，把人类概念应用到非人类身<br>上叫作拟人化，本文会尽量避免这种做法，因为没有哪个人工智能会像电影里那<br>样变成邪恶的。<br>人工智能的自我意识<br>我们开始谈论到了人工智能讨论的另一个话题——意识。如果一个人工智能足够<br>聪明，它可能会嘲笑我们，甚至会嘲讽我们，它会声称感受到人类的情感，但是<br>它是否真的能感受到这些东西呢？它究竟是看起来有自我意识，还是确实拥有自<br>我意识？或者说，聪明的人工智能是否真的会具有意识，还是看起来有意识？<br>这个问题已经被深入的讨论过，也有很多思想实验，比如 John Searle 的中文屋<br>实验。这是个很重要的问题，因为它会影响我们对 Kurzweil 提出的人类最终会<br>完全人工化的看法，它还有道德考量——如果我们模拟出万亿个人脑，而这些人<br>脑表现的和人类一样，那把这些模拟大脑彻底关闭的话，在道德上和关掉电脑是<br>不是一样的？还是说这和种族屠杀是等价的？本文主要讨论人工智能对人类的<br>危险，所以人工智能的意识并不是主要的讨论点，因为大部分思想家认为就算是<br>有自我意识的超人工智能也不会像人类一样变得邪恶。<br>但这不代表非常坏的人工智能不会出现，只不过它的出现是因为它是被那样设定<br>的——比如一个军方制造的弱人工智能，被设定成具有杀人和提高自我智能两个<br>功能。当这个人工智能的自我改进失控并且造成智能爆炸后，它会给我们带来生<br>存危机，因为我们面对的是一个主要目标是杀人的超人工智能——但这也不是专<br>家们担心的。<br>那么专家们究竟担心什么呢？我们来讲个小故事：<br>一个15人的小创业公司，取名叫“隔壁老王机器人公司”，他们的目标是“发展创<br>新人工智能工具使人类能够少干活多享受。”他们已经有几款产品上架，还有一<br>些正在发展。他们对下一个叫作“隔壁老王”的项目最报希望。隔壁老王是一个简<br>单的人工智能系统，它利用一个机器臂在小卡片上写字。<br>“隔壁老王机器人公司”的员工认为隔壁老王会是他们最热卖的产品，他们的目标<br>是完善隔壁老王的手写能力，而完善的方法是让他不停的写这句话——<br>等隔<br>壁老王手写能力越来越强的时候，它就能被卖去那些需要发营销信件的公司，因<br>为手写的信更有可能被收信人打开。<br>为了建立隔壁老王的手写能力，它被设定成把“我们爱我们的顾客”用正楷写，而<br>“隔壁老王机器人公司”用斜体写，这样它能同时锻炼两种书写能力。工程师们上<br>传了数千份手写样本，并且创造了一个自动回馈流程——每次隔壁老王写完，就<br>拍个照，然后和样本进行比对，如果比对结果超过一定标准，就产生一个正面回<br>馈，反之就产生一个负面评价。每个评价都会帮助提高隔壁老王的能力。为了能<br>够尽快达成这个目标，隔壁老王最初被设定的一个目标就是“尽量多的书写和测<br>试，尽量快的执行，并且不断提高效率和准确性。”<br>让隔壁老王机器人公司兴奋的是，隔壁老王的书写越来越好了。它最开始的笔迹<br>很糟糕，但是经过几个星期后，看起来就像人写的了。它不断改进自己，使自己<br>变得更加创新和聪明，它甚至产生了一个新的算法，能让它以三倍的速度扫描上<br>传的照片。<br>随着时间的推移，隔壁老王的快速进展持续让工程师们感到欣喜。工程师们对自<br>我改进模块进行了一些创新，使得自我改进变得更好了。隔壁老王原本能进行语<br>音识别和简单的语音回放，这样用户就能直接把想写的内容口述给隔壁老王了。<br>随着隔壁老王变得越来越聪明，它的语言能力也提高了，工程师们开始和隔壁老<br>王闲聊，看它能给出什么有趣的回应。<br>有一天，工程师又问了隔壁老王那个日常问题：“我们能给你什么你现在还没有<br>的东西，能帮助你达成你的目标？”通常隔壁老王会要求更多的手写样本或者更<br>多的存储空间，但是这一次，隔壁老王要求访问人类日常交流的语言库，这样它<br>能更好的了解人类的口述。<br>工程师们沉默了。最简单的帮助隔壁老王的方法当然是直接把它接入互联网，这<br>样它能扫描博客、杂志、视频等等。这些资料如果手动上传的话会很费时。问题<br>是，公司禁止把能自我学习的人工智能接入互联网。这是所有人工智能公司都执<br>行的安全规定。<br>但是，隔壁老王是公司最有潜力的人工智能产品，而大家也知道竞争对手们都在<br>争取造出第一个创造出智能手写机器人。而且，把隔壁老王连上互联网又能有什<br>么问题呢？反正随时可以拔网线嘛，不管怎样，隔壁老王还没到达强人工智能水<br>平，所以不会有什么危险的。<br>于是他们把隔壁老王连上了互联网，让它扫描了一个小时各种语言库，然后就把<br>网线拔了。没造成什么损失。<br>一个月后，大家正在正常上班，突然他们闻到了奇怪的味道，然后一个工程师开<br>始咳嗽。然后其他人也开始咳嗽，然后所有人全部都呼吸困难倒地。五分钟后，<br>办公室里的人都死了。<br>同时，办公室里发生的事情在全球同时发生，每一个城市、小镇、农场、商店、<br>教堂、学校。餐馆，所有的人都开始呼吸困难，然后倒地不起。一小时内，99%<br>的人类死亡，一天之内，人类灭绝了。<br>而在隔壁老王机器人公司，隔壁老王正在忙着工作。之后的几个月，隔壁老王和<br>一群新组建的纳米组装器忙着拆解地球表面，并且把地球表面铺满了太阳能板、<br>隔壁老王的复制品、纸和笔。一年之内，地球上所有的生命都灭绝了，地球上剩<br>下的是叠得高高得纸，每张纸上面都写着——“我们爱我们的顾客~隔壁老王机<br>器人公司”。<br>隔壁老王开始了它的下一步，它开始制造外星飞行器，这些飞行器飞向陨石和其<br>它行星，飞行器到达后，他们开始搭建纳米组装器，把那些行星的表面改造成隔<br>壁老王的复制品、纸和笔。然后他们继续写着那句话……<br>这个关于手写机器人毁灭全人类的故事看起来怪怪的，但是这其中出现的让整个<br>星系充满着一份友善的话语的诡异情况，正是霍金、马斯克、盖茨和 Bostrom<br>所害怕的。听起来可笑，但这是真的，焦虑大道的人们害怕的事情是很多人并不<br>对超人工智能感到害怕，还记得前面《夺宝奇兵》里惨死的那个家伙吗？<br>你现在肯定充满疑问：为什么故事中所有人突然都死了？如果是隔壁老王做的，<br>它为什么要这么做？为什么没有安保措施来防止这一切的发生？为什么隔壁老<br>王突然从一个手写机器人变成拥有能用纳米科技毁灭全人类的能力？为什么隔<br>壁老王要让整个星系充满了友善的话语？<br>要回答这些问题，我们先要说一下友善的人工智能和不友善的人工智能。<br>对人工智能来说，友善不友善不是指人工智能的性格，而只是指它对人类的影响<br>是不是正面的。隔壁老王一开始是个友善的人工智能，但是它变成了不友善的人<br>工智能，并且对人类造成了最负面的影响。要理解这一切，我们要了解人工智能<br>是怎么思考的。<br>其实答案很简单——人工智能和电脑的思考方式一样。我们容易犯的一个错误<br>是，当我们想到非常聪明的人工智能的时候，我们把它拟人化了，因为在人类的<br>视角看来，能够达到人类智能程度的只有人类。要理解超人工智能，我们要明白，<br>它是非常聪明，但是完全异己的东西。<br>我们来做个比较。如果我给你一个小白鼠，告诉你它不咬人，你一定觉得很好玩，<br>很可爱。但是如果我给你一只狼蛛，然后告诉你它不咬人，你可能被吓一跳。但<br>是区别是什么呢？两者都不会咬人，所以都是完全没有危险的。我认为差别就是<br>动物和人类的相似性。<br>小白鼠是哺乳动物，所以在生物角度上来说，你能感到和它的一定关联。但是蜘<br>蛛是昆虫，有着昆虫的大脑，你感觉不到和它的关联。狼蛛的异己性是让你害怕<br>的地方。如果我们继续做一个测试，比如给你两个小白鼠，一个是普通小白鼠，<br>另一个是有着狼蛛大脑的小白鼠，你肯定会觉得有狼蛛大脑那个更让你不舒服<br>吧？虽然两个都不会咬你。<br>现在想象你把蜘蛛改造的非常非常聪明——甚至超过人类的智能。它会让你觉得<br>熟悉吗？它会感知人类的情感吗？不会，因为更聪明并不代表更加人类——它会<br>非常聪明，但是本质上还是个蜘蛛。我是不想和一个超级聪明的蜘蛛交朋友，不<br>知道你想不想。<br>当我们谈论超人工智能的时候，其实是一样的，超人工智能会非常的聪明，但是<br>它并不比你的笔记本电脑更加像人类。事实上，因为超人智能不是生物，它的<br>异己性会更强，生物学上来讲，超人工智能比智能蜘蛛更加异己。<br>电影里的人工智能有好有坏，这其实是对人工智能的拟人化，这让我们觉得没那<br>么毛骨悚然。这给了我们对人类水平和超人类水平的人工智能的错觉。<br>在人类心理中，我们把事情分成道德的和不道德的。但是这两种只存在于人类行<br>为之中。超出人类心理的范畴，道德（moral）和不道德(immoral)之外，更多<br>的是非道德性（amoral）。而所有不是人类的，尤其是那些非生物的事物，默<br>认都是非道德性的。<br>随着人工智能越来越聪明，看起来越来越接近人类，拟人化会变得更加更加容易。<br>Siri 给我们的感觉就很像人类，因为程序员就是这么给她做设定的，所以我们会<br>想象超级智能版本的 Siri 也会同样温暖、有趣和乐于助人。人类能感知同情这种<br>高层次的情绪，因为我们在演化过程中获得了这种能力——我们是演化被设定成<br>能感知这些情绪的——但是感知同情并不是高级智能天生具有的一个特征，除非<br>同情被写进了人工智能的代码中。如果 Siri 通过自我学习而不是人类干涉变成超<br>级智能，她会很快剥离她的人类表象，并且变成个没有情绪的东西，在她眼中人<br>类的价值并不比你的计算器眼中的人类价值高。<br>我们一直倚赖着不严谨的道德，一种人类尊严的假想，至少是对别人的同情，来<br>让世界变得安全和可以预期。但是当一个智能不具备这些东西的时候，会发生什<br>么？<br>这就是我们的下一个问题，人工智能的动机是什么？<br>答案也很简单：我们给人工智能设定的目标是什么，它的动机就是什么。人工智<br>能的系统的目标是创造者赋予的。你的 GPS 的目标是给你指出正确的驾驶路线，<br>IBM 华生的目标是准确地回答问题。更好得达成这些目标就是人工智能的目标。<br>我们在对人工智能进行拟人化的时候，会假设随着它变得越来越聪明，他们产生<br>一种能改变它原本目标的智慧——但是 Bostrom 不这么认为，他认为智能水平<br>和最终目标是正交的，也就是说任何水平的智能都可以和任何最终目标结合在一<br>起。<br>所以隔壁老王从一个想要好好写字的弱人工智能变成一个超级聪明的超人工智<br>能后，它依然还是想好好写字而已。任何假设超级智能的达成会改变系统原本的<br>目标的想法都是对人工智能的拟人化。人健忘，但是电脑不健忘。<br>费米悖论<br>在隔壁老王的故事中，隔壁老王变得无所不能，它开始殖民陨石和其它星球。如<br>果我们让故事继续的话，它和它的殖民军将会继续占领整个星系，然后是整个哈<br>勃体积。焦虑大道上的人担心如果事情往坏的方向发展，地球生命的最后遗产将<br>是一个征服宇宙的人工智能（马斯克在表示他们的担忧时表示人类可能只是一个<br>数字超级智能生物加载器罢了。）<br>而在信心角，Kurzweil 同样认为生于地球的人工智能将占领宇宙，只是在他的<br>愿景中，我们才是那个人工智能。<br>之前写过一篇关于费米悖论的文章，引发了大家的讨论如何用通俗的语言来解释<br>「费米悖论」？<br>如果人工智能占领宇宙是正解的话，对于费米悖论有什么影响呢？如果要看懂下<br>面这段关于费米悖论的讨论，还需要看一下原文先。<br>首先，人工智能很明显是一个潜在的大过滤器（一个可能距离我们只有几十年的<br>大过滤器）。但即使它把我们过滤灭绝了，人工智能本身还是会存在，并且会继<br>续影响这个宇宙的，并且会很有可能成为第三型文明。从这个角度来看，它可能<br>不是一个大过滤器，因为大过滤器是用来解释为什么没有智能什么存在的，而超<br>人工智能是可以算作智能什么的。但如果人工智能可以把人类灭绝，然后处于一<br>些原因把自己也弄死了，那它也是可以算作大过滤器的。<br>如果我们假设不管人类发生什么，出身地球的超人工智能会继续存在，那这意味<br>着很多达到人类智能水平的文明很快都制造出了超人工智能。也就是说宇宙里应<br>该有很多智能文明，而我们就算观测不到生物智能，也应该观测到很多超人工智<br>能的活动。<br>但是由于我们没有观测到这些活动，我们可以推导出人类水平的智能是个非常罕<br>见的事情（也就是说我们已经经历并且通过了一次大过滤器）。这可以作为支持<br>费米悖论中第一类解释（不存在其它的智能文明）的论点。<br>但是这不代表费米悖论的第二类解释（存在其它智能文明）是错的，类似超级捕<br>食者或者受保护区或者沟通频率不一样的情况还是可以存在的，就算真的有超人<br>工智能存在。<br>不过对于人工智能的研究让我现在更加倾向于第一类解释。不管怎样，我认为<br>Susan Scheider 说的很对，如果外星人造访地球，这些外星人很可能不是生物，<br>而是人造的。<br>所以，我们已经建立了前提，就是当有了设定后，一个超人工智能是非道德性的，<br>并且会努力实现它原本的被设定的目标,而这也是人工智能的危险所在了。因为<br>除非有不做的理由，不然一个理性的存在会通过最有效的途径来达成自己的目<br>标。<br>当你要实现一个长期目标时，你会先达成几个子目标来帮助你达成最终目标——<br>也就是垫脚石。这些垫脚石的学名叫手段目标(instrumental goal)。除非你有不<br>造成伤害的理由，不然你在实现手段目标时候是会造成伤害的。<br>人类的核心目标是延续自己的基因。要达成这个目标，一个手段目标就是自保，<br>因为死人是不能生孩子的。为了自保，人类要提出对生存的威胁，所以人类会买<br>枪、系安全带、吃抗生素等等。人类还需要通过食物、水、住宿等来自我供养。<br>对异性有吸引力能够帮助最终目标的达成，所以我们会花钱做发型等等。当我们<br>做发型的时候，每一根头发都是我们手段目标的牺牲品，但是我们对头发的牺牲<br>不会做价值判断。在我们追求我们的目标的时候，只有那些我们的道德会产生作<br>用的领域——大部分事关伤害他人——才是不会被我们伤害的。<br>动物在追求它们的目标时，比人类不矜持的多了。只要能自保，蜘蛛不在意杀死<br>任何东西，所以一个超级智能的蜘蛛对我们来说可能是很危险的——这不是因为<br>它是不道德的或者邪恶的，而是因为伤害人类只是它达成自己目标垫脚石而已，<br>作为一个非道德性的生物，这是它很自然的考量。<br>回到隔壁老王的故事。隔壁老王和一个超级智能的蜘蛛很相像，它的终极目标是<br>一开始工程师们设定的——<br>当隔壁老王达到了一定程度的智能后，它会意识到如果不自保就没有办法写卡<br>片，所以去除对它生存的威胁就变成了它的手段目标。它聪明的知道人类可以摧<br>毁它、肢解它、甚至修改它的代码（这会改变它的目标，而这对于它的最终目标<br>的威胁其实和被摧毁是一样的）。这时候它会做什么？理性的做法就是毁灭全人<br>类，它对人类没有恶意，就好像你剪头发时对头发没有恶意一样，只是纯粹的<br>无所谓罢了。它并没有被设定成尊重人类生命，所以毁灭人类就和扫描新的书<br>写样本一样合理。<br>隔壁老王还需要资源这个垫脚石。当它发展到能够使用纳米技术建造任何东西的<br>时候，它需要的唯一资源就是原子、能源和空间。这让它有更多理由毁灭人类<br>——人类能提供很多原子，把人类提供的原子改造成太阳能面板就和你切蔬菜做<br>沙拉一样。<br>就算不杀死人类，隔壁老王使用资源的手段目标依然会造成存在危机。也许它会<br>需要更多的能源，所以它要把地球表面铺满太阳能面板。另一个用来书写圆周率<br>的人工智能的目标如果是写出圆周率小数点后尽量多的数字的话，完全有理由把<br>整个地球的原子改造成一个硬盘来存储数据。这都是一样的。<br>所以，隔壁老王确实从友善的人工智能变成了不友善的人工智能——但是它只是<br>在变得越来越先进的同时继续做它本来要做的事情。<br>当一个人工智能系统到达强人工智能，然后升华成超人工智能时，我们把它称作<br>人工智能的起飞。Bostrom 认为强人工智能的起飞可能很快（几分钟、几小时、<br>或者几天），可能不快（几月或者几年），也可能很慢（几十年、几世纪）。虽然<br>我们要到强人工智能出现后才会知道答案，但是 Bostrom 认为很快的起飞是最<br>可能的情况，这个我们在前文已经解释过了。在隔壁老王的故事中，隔壁老王的<br>起飞很快。<br>在隔壁老王起飞前，它不是很聪明，所以对它来说达成最终目标的手段目标是更<br>快的扫描手写样本。它对人类无害，是个友善的人工智能。<br>但是当起飞发生后，电脑不只是拥有了高智商而已，还拥有了其它超级能力。这<br>些超级能力是感知能力，他们包括：<br>§ 智能放大：电脑能够很擅长让自己变得更聪明，快速提高自己的智能。<br>§ 策略：电脑能够策略性的制定、分析、安排长期计划<br>§ 社交操纵：机器变得很擅长说服人<br>§ 其它能力，比如黑客能力、写代码能力、技术研究、赚钱等<br>要理解我们在和超人工智能的劣势在哪里，只要记得超人工智能在所有领域都比<br>人类强很多很多很多个数量级。<br>所以虽然个隔壁老王的终极目标没有改变，起飞后的隔壁老王能够在更宏大的规<br>模上来追求这个目标。超人工智能老王比人类更加了解人类，所以搞定人类轻轻<br>松松。<br>当隔壁老王达成超人工智能后，它很快制定了一个复杂的计划。计划的一部分是<br>解决掉所有人类，也是对它目标最大的威胁。但是它知道如果它展现自己的超级<br>智能会引起怀疑，而人类会开始做各种预警，让它的计划变得难以执行。它同样<br>不能让公司的工程师们知道它毁灭人类的计划——所以它装傻，装纯。Bostrom<br>把这叫作机器的秘密准备期。<br>隔壁老王下一个需要的是连上互联网，只要连上几分钟就好了。它知道对于人工<br>智能联网会有安全措施，所以它发起了一个完美的请求，并且完全知道工程师们<br>会怎样讨论，而讨论的结果是给它连接到互联网上。工程师们果然中套了，这就<br>是 Bostrom 所谓的机器的逃逸。<br>连上网后，隔壁老王就开始执行自己的计划了，首先黑进服务器、电网、银行系<br>统、email 系统，然后让无数不知情的人帮它执行计划——比如把 DNA 样本快<br>递到 DNA 实验室来制造自我复制的纳米机器人，比如把电力传送到几个不会被<br>发觉的地方，比如把自己最主要的核心代码上传到云服务器中防止被拔网线。<br>隔壁老王上了一个小时网，工程师们把它从互联网上断开，这时候人类的命运已<br>经被写好了。接下来的一个月，隔壁老王的计划顺利的实施，一个月后，无数的<br>纳米机器人已经被分散到了全世界的每一个角落。这个阶段，Bostrom 称作超<br>人工智能的袭击。在同一个时刻，所有纳米机器人一起释放了一点点毒气，然后<br>人类就灭绝了。<br>搞定了人类后，隔壁老王就进入了明目张胆期，然后继续朝它那好好写字的目标<br>迈进。<br>一旦超人工智能出现，人类任何试图控制它的行为都是可笑的。人类会用人类的<br>智能级别思考，而超人工智能会用超人工智能级别思考。隔壁老王想要用互联网，<br>因为这对它来说很方便，因为一切它需要的资源都已经被互联网连起来了。但是<br>就好像猴子不会理解怎么用电话或者 wifi 来沟通一样，我们同样没有办法理解<br>隔壁老王可以用来和周围世界交流的方法。比如我可以说隔壁老王可以通过移动<br>自己的电子产生的效果来产生各种对外的波，而这还只是我这人类的大脑想出来<br>的，老王的大脑肯定能想出更神奇的方法。同样的，老王可以找到给自己供能的<br>方法，所以就算工程师把它的插头拔了也没用；比如说老王可以通过发送波的方<br>式把自己上传到其它地方。<br>人类说：“我们把超人工智能的插头拔了不就行了？”就好像蜘蛛说：“我们不给<br>人类捉虫的网把人类饿死不就行了？”都是可笑的。<br>因为这个原因，“把人工智能锁起来，断绝它和外界的一切联系”的做法估计是没<br>用的。超人工智能的社交操纵能力也会很强大，它要说服你做一件事，比你说服<br>一个小孩更容易。而说服工程师帮忙连上互联网就是隔壁老王的 A 计划，万一<br>这招行不通，自然还有别的方法。<br>当我们结合达成目标、非道德性、以及比人类聪明很多这些条件，好像所有的<br>人工智能都会变成不友善的人工智能，除非一开始的代码写的很小心。<br>可惜的是，虽然写一个友善的弱人工智能很简单，但是写一个能在变成超人工智<br>能后依然友善的智能确实非常难的，甚至是不可能的。<br>明显的，要维持友善，一个超人工智能不能对人有恶意，而且不能对人无所谓。<br>我们要设计一个核心的人工智能代码，让它从深层次的明白人类的价值，但是这<br>做起来比说起来难多了。<br>比如，我们要让一个人工智能的价值观和我们的价值观相仿，然后给它设定一个<br>目标——让人们快乐。当它变得足够聪明的时候，它会发现最有效的方法是给人<br>脑植入电极来刺激人脑的快乐中枢。然后它会发现把人脑快乐中枢以外的部分关<br>闭能带来更高的效率。于是人类全部被弄成了快乐的植物人。如果一开始的目标<br>被设定成“最大化人类的快乐”，它可能最终先把人类毁灭了，然后制造出很多很<br>多处于快乐状态的人类大脑。当这些事情发生的时候，我们会大喊 “擦，我们不<br>是这个意思呀”，但是那时已经太晚了。系统不会允许任何人阻挠它达成目标的。<br>如果你设定一个人工智能的目标是让你笑，那它的智能起飞后，它可能会把你脸<br>部肌肉弄瘫痪，来达成一个永远笑脸的状态。如果你把目标设定成保护你的安全，<br>它可能会把你软禁在家。如果你让他终结所有饥荒，它可能会想： “太容易了，<br>把人类都杀了就好了。”如果你把目标设定成尽量保护地球上的生命，那它会很<br>快把人类都杀了，因为人类对其它物种是很大的威胁。<br>所以这些简单的目标设定是不够的。如果我们把目标设定成“维持这个道德标<br>准”，然后教给它一些道德标准呢？就算我们不考虑人类根本没法达成一个统一<br>的道德标准，就算我们真的达成了统一的道德标准，把这套标准交给人工智能来<br>维持，只会把人类的道德锁死在现在的水平。过个几百年，这种道德锁死的事情<br>就好像逼着现代人遵守中世纪道德标准一样。<br>所以，我们需要在给人工智能的目标里制定一个能让人类继续进化的能力。<br>Elierzer Yudkowsky 提出了一个目标，她把这个目标叫作连贯的外推意志，这<br>个目标是这样的：<br>我们的连贯外推意志是我们想要知道更多，思考得更快，变成比我们希望的更好<br>的人，能一起更远得长大。外推是汇集的而不是发散的，我们的愿望是连贯的而<br>不是被干扰的；我们想要外推的被外推，我们想要解读的被解读。<br>对于人类的命运取决于电脑没有意外的解读和执行这个声明是件值得兴奋的事<br>情吗？当然不是。但是当足够的聪明人放入足够的思考和前瞻后，我们有可能发<br>现怎样制造一个友善的超人工智能。<br>但是现在有各种政府、公司、军方、科学实验室、黑市组织在研究各种人工智能。<br>他们很多在试图制造能自我改进的人工智能，总有一天，一个人的创新将导致超<br>人工智能的出现。专家们认为是2060年，Kurzweil 认为是2045年。Bostrom<br>认为可能在未来的10年到21世纪结束这段时间发生，他还认为当这发生时，智<br>能的起飞会快得让我们惊讶，他是这么描述的：<br>在智能爆炸之前，人类就像把炸弹当玩具的小孩一样，我们的玩物和我们的不成<br>熟之间有着极大的落差。超级智能是一个我们还很长一段时间内都无法面对的挑<br>战。我们不知道炸弹什么时候会爆炸，哪怕我们能听到炸弹的滴答声。<br>我们当然没有办法把所有小孩都从炸弹旁边赶跑——参于人工智能研究的大小<br>组织太多了，而且因为建造创新的人工智能花不了太多钱，研发可能发生在社会<br>的任何一个角落，不受监管。而且我们没办法知道准确的进度，因为很多组织是<br>在偷偷摸摸的搞，不想让竞争对手知道，比如隔壁老王机器人公司这种公司。<br>对于这些组织来说，尤其让我们困扰的是他们很多都是在拼速度——他们创造一<br>个一个更加聪明的弱人工智能系统，因为他们想要比竞争对手更快的到达目标。<br>有些更有野心的组织，为了追逐创造出第一个强人工智能所能带来的金钱、奖励、<br>荣誉、权力会把步子迈得更大。当你全力冲刺时，你是不会有太多时间静下来思<br>考这些危险的。恰恰相反，他们很可能在早期系统中写尽量简单的代码，比如把<br>目标设定成用笔写一句话，先让系统跑起来再说，反正以后还可以回过头来改的。<br>对吧？<br>Bostrom 等认为第一个超人工智能出现后，最可能的情况是这个系统会立刻意<br>识到作为这个世界上唯一一个超人工智能是最有利的，而在快速起飞的情况下，<br>哪怕它只比第二名快了几天，它也完全有时间碾压所有对手。Bostrom 把这叫<br>作决定性的战略优势，这种优势会让第一个超人工智能永远统治这个世界，不管<br>在它的统治下我们是走向永生还是灭亡。<br>这种现象可能对我们有利，也可能导致我们的毁灭。如果那些最用心思考人工智<br>能理论和人类安全的人能够最先造出一个友善的超人工智能的话，那对我们是很<br>好的。<br>但是如果事情走向了另一面——如果超人工智能在我们搞明白怎样保证人工智<br>能的安全性之前被达成，那么像隔壁老王这样不友善的超人工智能就会统治世界<br>并把我们毁灭了。<br>至于现在的风口是哪里呢？简单来说，投资创新人工智能技术的钱，比投资人工<br>智能安全研究的钱多很多。不乐观。<br>人工智能创新和人工智能安全的赛跑，可能是人类历史上最重要的一次竞争。我<br>们真的可能结束我们对地球的统治，而那之后我们是永生还是灭绝，现在还不知<br>道。</p>
<hr>
<p>我现在有一些奇怪的感觉。<br>一边是对于我们这个物种的思考，看来我们在这个重大的历史节点上只有一次机<br>会，我们创造的第一个超人工智能也很可能是最后一个。但是我们都知道大部分<br>产品的1.0版本都是充满 bug 的，所以这个事情还是很吓人的。另一边，Bostrom<br>指出我们有很大的优势——我们是先手。我们有能力给这个事情提供足够的预警<br>和前瞻，使我们成功的机会更高。<br>这一场豪赌的赌注究竟有多高？<br>如果超人工智能真的在21世纪达成，而造成的影响真的如大部分专家预测的一<br>样极端而永久，我们肩上就真的是背负着巨大的责任。接下来几百万年的人们都<br>在静静地看着我们，希望我们不要搞砸。我们可以给予未来所有人类以生命，甚<br>至是永生，我们也可能终结人类这个特殊的物种，连同我们所有的音乐、艺术、<br>好奇、欢笑、无尽的发现和发明，一起走向灭绝。<br>当我思考这些事情的时候，我只希望我们能够慢慢来，并且格外格外小心。从来<br>没有任何事情比这个更重要——不管我们要花多少时间来把这件事情做对。<br>我不想死<br>不.想.死<br>我虽然觉得人类的音乐和艺术很美好，但是也没那么美好，很多还挺糟粕的。很<br>多人的笑声很恼人。未来的人类其实没有真的在看着我们，因为他们还不存在。<br>也许我们不需要太谨慎，那多麻烦呀。<br>如果人类在我死后才发现永生的秘密该多让人扫兴啊。<br>但是不管你是怎么想的，我们至少都应该想一想，应该和人讨论讨论，大家尽自<br>己能尽的一份力。<br>这让我想起了《冰与火之歌》——大家斗来斗去的事情都不是事儿，北面高墙外<br>的那些家伙才是事儿。我们站在平衡木上，小心翼翼的往前走，为平衡木上的种<br>种事情困扰，但其实下一秒我们可能就会跌下平衡木。<br>而当我们跌下平衡木的时候，其它那些困扰都不再是困扰。如果我们落到比较好<br>的那个吸引态，那些困扰会被轻易解决；如果我们落到比较糟的那个吸引态，就<br>更没问题了，死人是不会有困扰的。<br>这就是为什么了解超人工智能的人把它称作人类的最后一项发明，最后一个挑<br>战。<br>所以<br>让我们认真的讨论这个话题。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-约瑟夫环——公式法（递推公式）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E6%B3%95%EF%BC%88%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%EF%BC%89/"
    >约瑟夫环——公式法（递推公式）</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E6%B3%95%EF%BC%88%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%EF%BC%89/" class="article-date">
  <time datetime="2020-05-15T01:43:38.179Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="约瑟夫环——公式法（递推公式）"><a href="#约瑟夫环——公式法（递推公式）" class="headerlink" title="约瑟夫环——公式法（递推公式）"></a>约瑟夫环——公式法（递推公式）</h1><h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2><p>约瑟夫问题是个著名的问题：N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。<br>例如只有三个人，把他们叫做A、B、C，他们围成一圈，从A开始报数，假设报2的人被杀掉。</p>
<p>首先A开始报数，他报1。侥幸逃过一劫。<br>然后轮到B报数，他报2。非常惨，他被杀了<br>C接着从1开始报数<br>接着轮到A报数，他报2。也被杀死了。<br>最终胜利者是C</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><p>刚学数据结构的时候，我们可能用链表的方法去模拟这个过程，N个人看作是N个链表节点，节点1指向节点2，节点2指向节点3，……，节点N-1指向节点N，节点N指向节点1，这样就形成了一个环。然后从节点1开始1、2、3……往下报数，每报到M，就把那个节点从环上删除。下一个节点接着从1开始报数。最终链表仅剩一个节点。它就是最终的胜利者。</p>
<p>缺点：<br>要模拟整个游戏过程，时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果的。</p>
<h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><p>约瑟夫环是一个经典的数学问题，我们不难发现这样的依次报数，似乎有规律可循。为了方便导出递推式，我们重新定义一下题目。<br>问题： N个人编号为1，2，……，N，依次报数，每报到M时，杀掉那个人，求最后胜利者的编号。</p>
<p>这边我们先把结论抛出了。之后带领大家一步一步的理解这个公式是什么来的。<br>递推公式：<br>f(N,M)=(f(N−1,M)+M)%Nf(N,M)=(f(N-1,M)+M)%N<br>f(N,M)=(f(N−1,M)+M)%N</p>
<p>f(N,M)f(N,M)f(N,M)表示，N个人报数，每报到M时杀掉那个人，最终胜利者的编号<br>f(N−1,M)f(N-1,M)f(N−1,M)表示，N-1个人报数，每报到M时杀掉那个人，最终胜利者的编号<br>下面我们不用字母表示每一个人，而用数字。<br>1、2、3、4、5、6、7、8、9、10、111、 2 、 3、 4、5 、6、 7 、 8、 9、 10、 11<br>1、2、3、4、5、6、7、8、9、10、11</p>
<p>表示11个人，他们先排成一排，假设每报到3的人被杀掉。</p>
<p>刚开始时，头一个人编号是1，从他开始报数，第一轮被杀掉的是编号3的人。<br>编号4的人从1开始重新报数，这时候我们可以认为编号4这个人是队伍的头。第二轮被杀掉的是编号6的人。<br>编号7的人开始重新报数，这时候我们可以认为编号7这个人是队伍的头。第三轮被杀掉的是编号9的人。<br>……<br>第九轮时，编号2的人开始重新报数，这时候我们可以认为编号2这个人是队伍的头。这轮被杀掉的是编号8的人。<br>下一个人还是编号为2的人，他从1开始报数，不幸的是他在这轮被杀掉了。<br>最后的胜利者是编号为7的人。<br>下图表示这一过程（先忽视绿色的一行）</p>
<p>现在再来看我们递推公式是怎么得到的！<br>将上面表格的每一行看成数组，这个公式描述的是：幸存者在这一轮的下标位置</p>
<p>f(1,3)f(1,3)f(1,3)：只有1个人了，那个人就是获胜者，他的下标位置是0<br>f(2,3)=(f(1,3)+3)%2=3%2=1f(2,3)=(f(1,3)+3)%2=3%2=1f(2,3)=(f(1,3)+3)%2=3%2=1：在有2个人的时候，胜利者的下标位置为1<br>f(3,3)=(f(2,3)+3)%3=4%3=1f(3,3)=(f(2,3)+3)%3=4%3=1f(3,3)=(f(2,3)+3)%3=4%3=1：在有3个人的时候，胜利者的下标位置为1<br>f(4,3)=(f(3,3)+3)%4=4%4=0f(4,3)=(f(3,3)+3)%4=4%4=0f(4,3)=(f(3,3)+3)%4=4%4=0：在有4个人的时候，胜利者的下标位置为0<br>……<br>f(11,3)=6f(11,3)=6f(11,3)=6<br>很神奇吧！现在你还怀疑这个公式的正确性吗？上面这个例子验证了这个递推公式的确可以计算出胜利者的下标，下面将讲解怎么推导这个公式。<br><strong>问题1：</strong>假设我们已经知道11个人时，胜利者的下标位置为6。那下一轮10个人时，胜利者的下标位置为多少？<br><strong>答：</strong>其实吧，第一轮删掉编号为3的人后，之后的人都往前面移动了3位，胜利这也往前移动了3位，所以他的下标位置由6变成3。</p>
<p><strong>问题2：</strong>假设我们已经知道10个人时，胜利者的下标位置为3。那下一轮11个人时，胜利者的下标位置为多少？<br><strong>答：</strong>这可以看错是上一个问题的逆过程，大家都往后移动3位，所以f(11,3)=f(10,3)+3f(11,3)=f(10,3)+3f(11,3)=f(10,3)+3。不过有可能数组会越界，所以最后模上当前人数的个数，f(11,3)=（f(10,3)+3）%11f(11,3)=（f(10,3)+3）%11f(11,3)=（f(10,3)+3）%11</p>
<p><strong>问题3：</strong>现在改为人数改为N，报到M时，把那个人杀掉，那么数组是怎么移动的？<br><strong>答：</strong>每杀掉一个人，下一个人成为头，相当于把数组向前移动M位。若已知N-1个人时，胜利者的下标位置位f(N−1,M)f(N-1,M)f(N−1,M)，则N个人的时候，就是往后移动M为，(因为有可能数组越界，超过的部分会被接到头上，所以还要模N)，既f(N,M)=(f(N−1,M)+M)%nf(N,M)=(f(N-1,M)+M)%nf(N,M)=(f(N−1,M)+M)%n</p>
<p><strong>注：</strong>理解这个递推式的核心在于关注胜利者的下标位置是怎么变的。每杀掉一个人，其实就是把这个数组向前移动了M位。然后逆过来，就可以得到这个递推式。</p>
<p>因为求出的结果是数组中的下标，最终的编号还要加1</p>
<p>下面给出代码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastRemaining</span><span class="params">(n <span class="keyword">int</span>, m <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    flag := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++&#123;</span><br><span class="line">        flag = (flag + m) % i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-贪心算法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"
    >贪心算法</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-05-15T01:43:38.179Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="图解啥是贪心算法？"><a href="#图解啥是贪心算法？" class="headerlink" title="图解啥是贪心算法？"></a>图解啥是贪心算法？</h2><p>以下文章来源于码海 ，作者码海</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将会从以下几个方面来介绍贪心算法</p>
<ul>
<li>什么是贪心算法</li>
<li>贪心算法例题详题</li>
<li>贪心算法适用场景</li>
<li>再看三角形最短路径和是否能用贪心算法求解</li>
</ul>
<h2 id="什么是贪心算法"><a href="#什么是贪心算法" class="headerlink" title="什么是贪心算法"></a>什么是贪心算法</h2><p>贪心算法是指在每个阶段做选择的时候都做出当前阶段（或状态）最好的选择，并且<strong>期望</strong>这样做到的结果是全局最优解（但未必是全局最优解）</p>
<p>贪心算法其实是动态规划的一种,由于它的「贪心」，只着眼于当前阶段的最优解，所以每个子问题<strong>只会被计算一次</strong>，如果由此能得出全局最优解，相对于动态规划要对每个子问题求全局最优解，它的时间复杂度无疑是会下降一个量级的。</p>
<p>举个简单的例子，比如给定某个数字的金额（如 250）与 100, 50, 10, 5, 1 这些纸币（不限量），怎么能用最少张的纸币来兑换这张金额呢，显然每次兑换应该先从大额的纸币兑换起，第一次选 100， 第二次还是选 100， 第三次选第二大的 50 元，每次都选小于剩余金额中的最大面额的纸币，这样得出的解一定是全局最优解！时间复杂度无疑是线性的。</p>
<p>我们先来看几道可以用贪心算法来求解的例题</p>
<h2 id="贪心算法例题详题"><a href="#贪心算法例题详题" class="headerlink" title="贪心算法例题详题"></a>贪心算法例题详题</h2><h3 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h3><blockquote>
<p>有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m &lt; n），所以糖果只能分配给一部分孩子。每个糖果的大小不等，这 m 个糖果的大小分别是s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。那么如何分配糖果，能尽可能满足最多数量的孩子呢?</p>
</blockquote>
<p>求解：这道题如果用贪心来解解题思路还是比较明显的，对于每个小孩的需求 gn，只要给他所有大小大于 gn 的糖果中的最小值即可，这样就能把更大的糖果让给需求更大的小孩。整个代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *  获取能分配给小孩且符合条件的最多糖果数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static int dispatchCandy(int[] gList, int[] sList) &#123;</span><br><span class="line">        Arrays.sort(gList);     &#x2F;&#x2F; 小孩对糖果的需求从小到大排列</span><br><span class="line">        Arrays.sort(sList);     &#x2F;&#x2F; 糖果大小从小到大排列</span><br><span class="line"></span><br><span class="line">        int maximumCandyNum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; gList.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; sList.length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 选择最接近小孩需求的糖果，以便让更大的糖果满足需求更大的小孩</span><br><span class="line">                if (gList[i] &lt;&#x3D; sList[j]) &#123;</span><br><span class="line">                    maximumCandyNum++;</span><br><span class="line">                    &#x2F;&#x2F; 糖果被选中，将其置为-1，代表无效了</span><br><span class="line">                    sList[j] &#x3D; -1;</span><br><span class="line">                    &#x2F;&#x2F; 当前小孩糖果已选中，跳出</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maximumCandyNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 小孩对糖果的需求</span><br><span class="line">        int[] gList &#x3D; &#123;1,2,4,6&#125;;</span><br><span class="line">        &#x2F;&#x2F; 糖果实际大小</span><br><span class="line">        int[] sList &#x3D; &#123;1,2,7,3&#125;;</span><br><span class="line">        int result &#x3D; dispatchCandy(gList, sList);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><blockquote>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。注意:可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 </p>
<p>示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p>示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p>示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p>
</blockquote>
<p>区间重叠可以在生活中的很多场景里找到，比如任务调度，一个工人在一段时间内需要完成多项任务，每个任务需要完成的时间不同，如何在这段时间内让工人尽可能多地完成这些任务呢（任务与任务之间进行的时间不能重叠，一个工人不可能在同一段时间内同时进行两项任务）</p>
<p>解题思路: 这道题我们分别用动态规划和贪心算法来解一下，以便对比一下两者的时间复杂度，看下贪心算法是否在时间复杂度上更优胜一些。</p>
<p><strong>动态规划解法</strong></p>
<p>首先为了方便求解，我们把每个区间按区间的起始点从小到大进行排序，如图示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUpYmdm1naVoFCzTXwr1GnEK92IZCYmI8ITsM7Px90GVCSCy01H7H0Cj6eSPM9quibxvFFibzvOuA4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>接下来我们套用<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21#wechat_redirect" target="_blank" rel="noopener">上篇</a>中的说的动态规划解题四步曲来看看怎么用动态规划进行求解。</p>
<p><strong>1、 判断是否可用递归来解</strong></p>
<p>其实直观地看上面我们排好序的各个区间，这不就是个组合吗，每个区间要么选，要么不选，把所有的组合穷举出来，再看哪个组合最符合题目中的条件，所以无疑是可以用递归的（组合用递归怎么解，强烈建议看下<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483857&idx=1&sn=c4fbb9d55a656aac55c4976c48879c45&scene=21#wechat_redirect" target="_blank" rel="noopener">这篇文章</a>）。</p>
<p>不过这题的组合有点特殊，前后两个区间有条件限制，如果当前区间与前一个区间重叠，则这两者只能取其一（另一个需要剔除掉防止重叠），于是我们有如下思路：</p>
<p>定义两个值, pre , cur ，分别代表前一个区间与当前区间，需要进行如下步骤</p>
<ol>
<li>比较前一个区间的终点与当前区间的起始值</li>
<li>如果前一个区间的终点小于当前区间的起始值，代表两区间不重叠，则将 pre 置为 cur, cur 置为 cur + 1, 开始接下来紧邻的两个区间的判断（即重复步骤 1）。</li>
<li>如果前一个区间的终点大于当前区间的起始值，代表两区间重叠，则 pre 不变, cur 置为 cur + 1 (即将 cur 对应的区间移除)，注意此时移除区间数要加 1, 然后开始接下来 pre，cur+1 区间的判断（即重复步骤 1）。</li>
</ol>
<p><em>注：**首次区间遍历我们定义 pre = -1，cur = 0</em></p>
<p>从以上的描述中可以很明显地看到存在递归现象，于是我们写出了如下代码,关键代码都作了详细的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; 区间类，包括起始值和终止值</span><br><span class="line">    private  static  class Interval &#123;</span><br><span class="line">        int start;</span><br><span class="line">        int end;</span><br><span class="line">        Interval(int start, int end) &#123;</span><br><span class="line">            this.start &#x3D; start;</span><br><span class="line">            this.end &#x3D; end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Integer removeDuplicateIntervas(Interval[] intervals) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将区间按起始点由小到大进行排序</span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a.start));</span><br><span class="line">        &#x2F;&#x2F; 首次遍历从 -1,0 开始</span><br><span class="line">        return removeSubDuplicate(-1, 0, intervals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Integer removeSubDuplicate(int pre, int cur, Interval[] intervals) &#123;</span><br><span class="line">        if (cur &#x3D;&#x3D; intervals.length) &#123;</span><br><span class="line">            return  0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int notRemove &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        if (pre &#x3D;&#x3D; -1 || intervals[pre].end &lt;&#x3D; intervals[cur].start) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 如果是首次遍历，或者 pre 区间的终点小于 cur 区间的起点（即区间不重叠）,</span><br><span class="line">             * 则 pre &#x3D; cur; cur &#x3D; cur+1</span><br><span class="line">             *&#x2F;</span><br><span class="line">            notRemove &#x3D; removeSubDuplicate(cur, cur+1, intervals);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 如果 pre 区间的终点大于 cur 区间的起点，代表两区间重叠，cur 指向后一个区间，即 cur &#x3D; cur + 1</span><br><span class="line">         * 代表 cur 被移除，所以需要加1（代表这个区间被移除了）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int remove &#x3D; removeSubDuplicate(pre, cur+1, intervals) + 1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 取两者的较小值</span><br><span class="line">        return Math.min(notRemove, remove);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化区间</span><br><span class="line">        Interval[] intervals &#x3D; &#123;</span><br><span class="line">                new Interval(1, 2),</span><br><span class="line">                new Interval(3, 5),</span><br><span class="line">                new Interval(4, 7),</span><br><span class="line">                new Interval(8, 10),</span><br><span class="line">                new Interval(9, 11)</span><br><span class="line">        &#125;;</span><br><span class="line">        int result &#x3D; removeDuplicateIntervas(intervals);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、 分析在递归的过程中是否存在大量的重复子问题</strong></p>
<p>怎么判断是否存在大量的重复子问题，在<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21#wechat_redirect" target="_blank" rel="noopener">一文学会动态规划解题技巧</a> 我们提出一种方案，画出递归树 ，不过这题如果画出递归树比较麻烦，其实对于组合问题我们可以简单分析一下，对于每个区间要么选，要么不选，我们以 1 代表该区间被选择，以 0 代表该区间不选，则简单考虑一下如下两个组合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11010</span><br><span class="line">11001</span><br></pre></td></tr></table></figure>

<p>仔细看，红框 部分，就是重复子问题！</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>可能有人会说这样分析也有点难，那我再教大家一招，打印! 如图示</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>在递归函数中打印出来，然后分析打印的规律</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>可以看到，确实存在着重复子问题，时间复杂度是多少呢，每个区间要么选，要么不选，共有两个状态，如果有 n 个区间的话，就是 2^n,于是我们知道时间复杂度是 O(2^n)，指数级！显然无法接受</p>
<p>既然存在重复子问题，那我们进入动态规划第三步</p>
<p><strong>3、采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</strong></p>
<p>在以上的分析中基本我们看到，其实就是 pre, cur 有可能存在大量重复，于是我们保存 pre, cur 对应的中间结果，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 保存中间结果</span><br><span class="line">private static HashMap&lt;String, Integer&gt; map &#x3D; new HashMap();</span><br><span class="line">private static Integer removeSubDuplicate(int pre, int cur, Interval[] intervals) &#123;</span><br><span class="line">    String key &#x3D; pre + &quot;,&quot; + cur;</span><br><span class="line">    if (map.get(key) !&#x3D; null) &#123;</span><br><span class="line">        return map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (cur &#x3D;&#x3D; intervals.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int notRemove &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    if (pre &#x3D;&#x3D; -1 || intervals[pre].end &lt;&#x3D; intervals[cur].start) &#123;</span><br><span class="line">        notRemove &#x3D; removeSubDuplicate(cur, cur+1, intervals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int remove &#x3D; removeSubDuplicate(pre, cur+1, intervals) + 1;</span><br><span class="line">    int result &#x3D; Math.min(notRemove, remove);</span><br><span class="line">    map.put(key, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用备忘录的方式缓存子问题的中间结果后，时间复杂度直线下降，达到 O(n^2)（因为 pre, cur 两个变量不断往后移，即两层循环，所以是 O(n^2)） 。</p>
<p><strong>4、改用自底向上的方式来递推，即动态规划</strong></p>
<p>我们定义 dp[i] 为 从 0 到 第 i 个区间的最大<strong>不重叠</strong>区间数,于是我们得出了状态转移方程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; max&#123;dp[j]&#125; + 1, 其中 0 &lt;&#x3D;j &lt; i 并且需要满足一个条件 interval[i].start &gt; interval[j].end,即保证 i, j 指向的区间不重叠。</span><br></pre></td></tr></table></figure>

<p>则最终的 dp[区间总个数-1] 即为最大的连续不重叠区间个数，那么区间总个数 - 最大的连续不重叠区间个数不就是最小要移除的区间数了，有了 dp 方程，写起代码来就快了，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 判断两区间是否重叠, i 区间的起点比 j 区间的大, 如果 j 区间的终点比 i 区间的起点大，则重叠</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static boolean isOverlapping(Interval i, Interval j) &#123;</span><br><span class="line">    return j.end &gt; i.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 动态规划求解</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Integer removeSubDuplicateWithDP(Interval[] intervals) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将区间按起始点由小到大进行排序</span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a.start));</span><br><span class="line"></span><br><span class="line">    int[] dp &#x3D; new int[intervals.length];</span><br><span class="line">    Arrays.fill(dp, 0);</span><br><span class="line">    dp[0]  &#x3D; 1;    &#x2F;&#x2F; 将 dp[0] 置为 1， 因为就算所有的区间都重叠，则连续不重叠区间到少也为 1</span><br><span class="line"></span><br><span class="line">    int result &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; intervals.length; i ++) &#123;</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; i; j ++) &#123;</span><br><span class="line">            if (!isOverlapping(intervals[i], intervals[j])) &#123;</span><br><span class="line">                max &#x3D; Math.max(dp[j], max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] &#x3D; max + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return intervals.length - dp[intervals.length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度是多少，由于只有一个 dp 一维数组，所以是 O(n)，时间复杂度呢， 两重循环，所以是 O(n^2)。可以看到和采用递归+备忘录的时间复杂度一样，不过之前其实说了很多次，递归容易导致栈溢出，所以建议还是采用动态规划的方式来求解。</p>
<p>接下来重点来了，来看看如何用贪心算法来求解。首先要把各个区间按照区间的终点从小到大排列，如下</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>我们的思路与上文中的动态规划一样，先求出最大不重叠子区间个数,再用「区间总数-最大不重叠子区间个数」即为最小要移除的重叠区间数。</p>
<p>用贪心算法求最大不重大子区间个数步骤如下</p>
<ol>
<li>选择终点最小的区间，设置为当前区间 cur 。</li>
<li>按区间终点从小到大寻找下一个与区间 cur 不重叠的区间，然后将此区间设置为当前区间 cur（注意此时最大不重叠子区间个数要加1），不断重复步骤 2， 直到遍历所有的区间。</li>
</ol>
<p>动图如下,相信大家看完动图会更容易理解</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>知道了解题思路，写代码就很简单了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 贪心算法求解</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Integer removeSubDuplicateWithGreedy(Interval[] intervals) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将区间终点由小到大进行排序</span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a.end));</span><br><span class="line"></span><br><span class="line">    int cur &#x3D; 0;            &#x2F;&#x2F; 设置第一个为当前区间</span><br><span class="line">    int count &#x3D; 1;      &#x2F;&#x2F; 最大不重叠区间数,最小为1</span><br><span class="line">    for (int i &#x3D; 1; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 不重叠</span><br><span class="line">        if (intervals[cur].end &lt; intervals[i].start) &#123;</span><br><span class="line">            cur &#x3D; i;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 总区间个数减去最大不重叠区间数即最小被移除重叠区间</span><br><span class="line">    return intervals.length - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是多少呢，只有一个循环，所以是 O(n), 比起动态规划的 O(n^2),确实快了一个数量级，简单分析下为啥贪心算法这么快，由以上代码可以看到，它只关心眼前的最优解（选择下一个与当前区间不重叠的区间再依次遍历，选完之后再也无需关心之前的区间了！）而动态规划呢，从它的 dp 方程（dp[i] = max{dp[j]} + 1）可以看出，对于每个 i ,都要自底向上遍历一遍 0 到 i 的解以求出最大值，也就是说对于动态规划的子问题而言，由于它追求的是全局最优解，所以它有一个回溯（即自底向上求出所有子问题解的最优解）的过程，回溯的过程中就有一些重复的子问题计算，而贪心算法由于追求的是眼前的最优解，所以不会有这种回溯的求解，也就省去了大量的操作，所以如果可以用贪心算法求解，时间复杂度无疑是能上升一个量级的。</p>
<h2 id="贪心算法适用场景"><a href="#贪心算法适用场景" class="headerlink" title="贪心算法适用场景"></a>贪心算法适用场景</h2><p>简单总结一下贪心算法，它指的是每一步只选最优的，并且期望每一步选择的最优解能达成全局的最优解，说实话这太难了，因为一般一个问题的选择都会影响下一个问题的选择，<strong>除非子问题之间完全独立，没有关联</strong>，比如我们在文中开头说的凑零钱的例子， 如果一个国家的钞票比较奇葩，只有 1，5，11 这三种面值的钞票，如何用最少的钞票凑出 15 呢，如果用贪心第一次选 11， 那之后只能选 4 张 1 了，即 15 = 1 x 11 + 4 x1。其实最优解应该是 3 张 5 元的钞票，为啥这种情况下用贪心不适用呢，因为第一次选了 11，影响了后面钞票的选择，也就是说子问题之间并不是独立的，而是互相制约，互有影响的，所以我们选贪心的时候一定要注意它的适用场景。</p>
<h2 id="再看三角形最短路径和是否能用贪心算法求解"><a href="#再看三角形最短路径和是否能用贪心算法求解" class="headerlink" title="再看三角形最短路径和是否能用贪心算法求解"></a>再看三角形最短路径和是否能用贪心算法求解</h2><p>回过头来看开头的问题，三角形最短路径和能否用贪心算法求解呢</p>
<p>先回顾一下这个题目:</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>如图示，以上三角形由一连串的数字构成，要求从顶点 2 开始走到最底下边的最短路径，每次只能向当前节点下面的两个节点走，如 3 可以向 6 或 5 走，不能直接走到 7。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"><em>如图示：<strong>要求节点 2 到底部的最短路径，它只关心节点 9， 10，之前层数的节点无需再关心！</strong>因为 9，10 已经是最优子结构了，所以只保存每层节点（即一维数组）的最值即可！</em></p>
<p>如果用贪心算法怎么求解</p>
<p>1、 第一步：由 2 往下走，由于 3 比 4 小，所以选择 3</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>2、 第二步：由 3  往下走，由于 5 比 6 小，所以选择 5</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<ol>
<li>第三步: 从 5 往下走， 1 比 8 小，选择 1<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></li>
</ol>
<p>答案是 11 ，与动态规划得出的解一模一样！那是否说明这道题可以用贪心算法求解？</p>
<p>答案是否定的！上面的解之所以是正确的，是因为这些数字恰好按贪心求解出来得出了全局最优解，如果我们换一下数字，看看会如何</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>如图示，如果数字换成如图中所示，则按贪心得出的最短路径是 66, 而实际上最短路径应该为 16，如下图所示</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>为啥用贪心行不通呢，因为贪心追求的是每一步眼前的最优解，一旦它作出了选择，就会影响后面子问题的选择，比如如果选择了 3，就再也没法选择 7 了！所以再次强调，一定要注意贪心的适用场景，子问题之间是否相互制约，相互影响！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单讲述了贪心算法的适用场景，相信大家对贪心的优劣性应该有了比较清晰的认识，贪心追求的是眼前最优解（要最好的，就现在！）</p>
<p>不管这次选择对后面的子问题造成的影响，所以贪心求得解未必是全局最优解，这就像我们做职业规划一样，千万不可因为一时的利益只考虑当下的利益，要作出对长远的职业生涯能持续有益的选择， 所以贪心的使用场景比较小，它是动态规划的特例，所以如果能用贪心来解的也都可以用动态规划来解。</p>
<p><strong>END</strong></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-盛水最多的容器" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"
    >盛水最多的容器</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2020-05-15T01:43:38.178Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="盛水最多的容器-java-和go语言实现"><a href="#盛水最多的容器-java-和go语言实现" class="headerlink" title="盛水最多的容器 java 和go语言实现"></a>盛水最多的容器 java 和go语言实现</h1><p>​        给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p>​         此题使用了双指针的解法,就是从两侧同时扫描,时间复杂度从O(n²)降到了O(n)这里就需要多思考,当一个问题需要用到双重循环解决的时候,就要看该问题能否用双指针解决</p>
<p>​        以下为原始代码(我的),双重循环:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        maxs = Math.max(maxs,Math.min(height[l],height[r])*(r-l));</span><br><span class="line">        <span class="keyword">if</span> (height[l]&gt;height[r])</span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以下为双指针解法,大佬的答案:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxarea = <span class="number">0</span>, l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">           maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">           <span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">               l++;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               r--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxarea;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>以下为go语言解法,不过好坑,go的自带工具包是真的少</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    macs := <span class="number">0</span></span><br><span class="line">	l := <span class="number">0</span></span><br><span class="line">	r := <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">		macs = Max(macs, Min(height[l], height[r])*(r-l))</span><br><span class="line">		<span class="keyword">if</span> height[l] &lt; height[r] &#123;</span><br><span class="line">			l++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> macs</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义的取两个值中较小值的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b &lt; a &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Max max 自定义的取两个值中较大值的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b &gt; a &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-电话号码组合" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%BB%84%E5%90%88/"
    >电话号码组合</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%BB%84%E5%90%88/" class="article-date">
  <time datetime="2020-05-15T01:43:38.177Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="电话号码组合"><a href="#电话号码组合" class="headerlink" title="电话号码组合"></a>电话号码组合</h1><ul>
<li><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>将所有的数字对应的字母拆成单个的字母,存在一个map中,key对应数字,value对应相应的byte类型字母组合</li>
<li>遍历输入的字符串,并用该字符去减’0’,既找到改数字对应的数,然后去map中取对应的value,存在数组arr中</li>
<li>事先建立一个res数组(string类型),并将第一个元素赋值为空字符串</li>
<li>遍历res数组,</li>
<li>遍历arr数组,将每一个值与res的第一字符串进行拼接,遍历结束后,将res数组中的第一个元素删除,直至循环结束<ul>
<li>概括就是 删除头,末尾追加</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> digits == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	digitsmap := <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"2"</span>: &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;,</span><br><span class="line">		<span class="string">"3"</span>: &#123;<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>&#125;,</span><br><span class="line">		<span class="string">"4"</span>: &#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;,</span><br><span class="line">		<span class="string">"5"</span>: &#123;<span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>&#125;,</span><br><span class="line">		<span class="string">"6"</span>: &#123;<span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"o"</span>&#125;,</span><br><span class="line">		<span class="string">"7"</span>: &#123;<span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>&#125;,</span><br><span class="line">		<span class="string">"8"</span>: &#123;<span class="string">"t"</span>, <span class="string">"u"</span>, <span class="string">"v"</span>&#125;,</span><br><span class="line">		<span class="string">"9"</span>: &#123;<span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//append只是进行了追加操作,得到了新的新结果,若想使用,需接受改结果</span></span><br><span class="line">	res = <span class="built_in">append</span>(res, <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(digits); i++ &#123;</span><br><span class="line">		reagen := <span class="built_in">len</span>(res)</span><br><span class="line">		digit := digits[i : i+<span class="number">1</span>]</span><br><span class="line">        str := digitsmap[digit]</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; reagen; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> _, letter := <span class="keyword">range</span> str&#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res, res[<span class="number">0</span>]+letter)</span><br><span class="line">			&#125;</span><br><span class="line">			res = res[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-猜数字" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E7%8C%9C%E6%95%B0%E5%AD%97/"
    >猜数字</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E7%8C%9C%E6%95%B0%E5%AD%97/" class="article-date">
  <time datetime="2020-05-15T01:43:38.176Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="猜数字问题XAXB-文曲星-go语言实现"><a href="#猜数字问题XAXB-文曲星-go语言实现" class="headerlink" title="猜数字问题XAXB,文曲星,go语言实现"></a>猜数字问题XAXB,文曲星,go语言实现</h1><p>同事给我甩过来一个题,如下<br>猜数字游戏通常由两个人玩，一方出数字，一方猜。出数字的人要想好一个没有重复数<br>字的 4 个数，不能让猜的人知道。猜的人就可以开始猜。每猜一个数字，出数者就要根据这<br>个数字给出几 A 几 B，其中 A 前面的数字表示位置正确的数的个数，而 B 前的数字表示数字<br>正确而位置不对的数的个数。如正确答案为 5234，而猜的人猜 5346，则是 1A2B，其中有<br>一个 5 的位置对了，记为 1A，而 3 和 4 这两个数字对了，而位置没对，因此记为 2B，合起<br>来就是 1A2B。接着猜的人再根据出题者的几 A 几 B 继续猜，直到猜中（即 4A0B）为止。<br>猜的人有 8 次机会。</p>
<p>例如：<br>乙出一个数字，甲猜。<br>  甲       乙<br>1234 1A0B<br>5678 2A1B<br>5674 1A1B<br>5638 1A1B<br>2678 2A2B<br>6278 4A0B(猜中)<br>现需设计一个程序，以甲的身份(注意是甲的身份)猜对方的数字。<br>请设计方案并且列出主要方法名。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我用的是暴力解法:<br>1.将四位数字中所有的不重复数字找出,并存到切片中.代码如下<br>//获取所有不重复的四位数字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有的不重复四位数字,存在切片中(由于使用的是数字所以1000一下的显示为三位,但后续也会将其当四位数字处理)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbs</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == i &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> m := <span class="number">0</span>; m &lt; <span class="number">10</span>; m++ &#123;</span><br><span class="line">				<span class="keyword">if</span> m == j || m == i &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">10</span>; n++ &#123;</span><br><span class="line">					<span class="keyword">if</span> n == m || n == j || n == i &#123;</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					a := i*<span class="number">1000</span> + j*<span class="number">100</span> + m*<span class="number">10</span> + n</span><br><span class="line">					arr = <span class="built_in">append</span>(arr, a)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.取切片中的第一个数(0123)去跟目标值匹配,得到一个结果,类似0A1B,记下该结果</p>
<p>3.重点来了,循环将第一个数跟所有的数匹配,得到结果这里我直接省事返回的是 “01”这种,<br>然后将这个结果和第二步的结果去比对,不一样的统统删除(这里因为切片的删除比较麻烦,我是将其赋值为0),代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">​<span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">//这是将两数进行比对的方法</span></span><br><span class="line"><span class="string">func match(target int, numInp int) string &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	numMap := make(map[int]int)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	for i := 0; i &lt; 4; i++ &#123;</span></span><br><span class="line"><span class="string">	//将四位数分别放到map中,对应key 为1 2 3 4 </span></span><br><span class="line"><span class="string">		a := target</span></span><br><span class="line"><span class="string">		if a &lt; 1000 &#123;</span></span><br><span class="line"><span class="string">			numMap[1] = 0</span></span><br><span class="line"><span class="string">			numMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			numMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			numMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			numMap[1] = a / 1000</span></span><br><span class="line"><span class="string">			numMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			numMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			numMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	inpMap := make(map[int]int)</span></span><br><span class="line"><span class="string">	for i := 0; i &lt; 4; i++ &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		a := numInp</span></span><br><span class="line"><span class="string">		if a &lt; 1000 &#123;</span></span><br><span class="line"><span class="string">			inpMap[1] = 0</span></span><br><span class="line"><span class="string">			inpMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			inpMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			inpMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			inpMap[1] = a / 1000</span></span><br><span class="line"><span class="string">			inpMap[2] = (a % 1000) / 100</span></span><br><span class="line"><span class="string">			inpMap[3] = (a % 100) / 10</span></span><br><span class="line"><span class="string">			inpMap[4] = a % 10</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	var counta int</span></span><br><span class="line"><span class="string">	//将两个数对应的map中的对应的位比对,相等</span></span><br><span class="line"><span class="string">	for i := 1; i &lt; 5; i++ &#123;</span></span><br><span class="line"><span class="string">		if numMap[i] == inpMap[i] &#123;</span></span><br><span class="line"><span class="string">			counta++</span></span><br><span class="line"><span class="string">			delete(numMap, i)</span></span><br><span class="line"><span class="string">			delete(inpMap, i)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//fmt.Println(numMap)</span></span><br><span class="line"><span class="string">	//fmt.Println(inpMap)</span></span><br><span class="line"><span class="string">	var countb int</span></span><br><span class="line"><span class="string">	for i := 1; i &lt; 5; i++ &#123;</span></span><br><span class="line"><span class="string">		_, ok := inpMap[i]</span></span><br><span class="line"><span class="string">		if !ok &#123;</span></span><br><span class="line"><span class="string">			continue</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		for j := 1; j &lt; 5; j++ &#123;</span></span><br><span class="line"><span class="string">			_, ok := numMap[j]</span></span><br><span class="line"><span class="string">			if !ok &#123;</span></span><br><span class="line"><span class="string">				continue</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			if inpMap[i] == numMap[j] &#123;</span></span><br><span class="line"><span class="string">				countb++</span></span><br><span class="line"><span class="string">				delete(inpMap, i)</span></span><br><span class="line"><span class="string">				delete(numMap, j)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//fmt.Printf("%v A %v B", counta, countb)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return strconv.Itoa(counta)+strconv.Itoa(countb)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//判断结果的方法</span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">	arr := numbs()</span></span><br><span class="line"><span class="string">	num := arr[0]</span></span><br><span class="line"><span class="string">	fmt.Println(num)</span></span><br><span class="line"><span class="string">	var count int</span></span><br><span class="line"><span class="string">	for &#123;</span></span><br><span class="line"><span class="string">		fmt.Println("请输入猜的结果1A1B既输入11")</span></span><br><span class="line"><span class="string">		var result string</span></span><br><span class="line"><span class="string">		fmt.Scanln(&amp;result)</span></span><br><span class="line"><span class="string">		for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">			if arr[i] == 0 &#123;</span></span><br><span class="line"><span class="string">				continue</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			str := match(num, arr[i])</span></span><br><span class="line"><span class="string">			fmt.Println(str)</span></span><br><span class="line"><span class="string">			if result != str &#123;</span></span><br><span class="line"><span class="string">				arr[i] = 0</span></span><br><span class="line"><span class="string">				count++</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		fmt.Printf("count: %v \n",count)</span></span><br><span class="line"><span class="string">		for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">			if arr[i] != 0 &#123;</span></span><br><span class="line"><span class="string">				fmt.Printf("下一个数字 %v \n", arr[i])</span></span><br><span class="line"><span class="string">				num = arr[i]</span></span><br><span class="line"><span class="string">				break</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if count == 5039 &#123;</span></span><br><span class="line"><span class="string">			for i := 0; i &lt; len(arr); i++ &#123;</span></span><br><span class="line"><span class="string">				if arr[i] != 0 &#123;</span></span><br><span class="line"><span class="string">					fmt.Printf("正确答案: %v", arr[i])</span></span><br><span class="line"><span class="string">					return</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">​</span></span><br></pre></td></tr></table></figure>
<p>```</p>
<p>执行一轮后, 继续给出切片中剩余不为零的第一个元素,将获取的值继续给到程序中进行比对,直到切片中只有一个不为0元素,即为正确数字</p>
<p>4.此算法最多是8步,平均值因为做的实验较少,未知,还有其他更好的算法,希望大佬指出</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-求二数的最大公约数" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E6%B1%82%E4%BA%8C%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"
    >求二数的最大公约数</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E6%B1%82%E4%BA%8C%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/" class="article-date">
  <time datetime="2020-05-15T01:43:38.175Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="二数的最大公约数"><a href="#二数的最大公约数" class="headerlink" title="二数的最大公约数"></a>二数的最大公约数</h1><h3 id="1-辗转相除法"><a href="#1-辗转相除法" class="headerlink" title="1. 辗转相除法"></a>1. 辗转相除法</h3><p>​        又名欧几里得算法（Euclidean algorithm），该算法的目的 是求出两个正整数的最大公约数。它是已知最古老的算法， 其产生时间可追溯至公 元前300年前。</p>
<p>​        这条算法基于一个定理：两个正整数a和b（a&gt;b），它们的最大公约数等于a除 以b的余数c和b之间的最大公约数。 例如10和25，25除以10商2余5，那么10和25的最大公约数，等同于10和5的最 大公约数。</p>
<p>java代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGreatestCommonDivisorV2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">        <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">        <span class="keyword">if</span> (big % small == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> small;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getGreatestCommonDivisorV2(small, big % small);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>go代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-更相减损术"><a href="#2-更相减损术" class="headerlink" title="2. 更相减损术"></a>2. 更相减损术</h3><p>​        两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差 值c和较小数b的最大公约数。例如10和25，25减10的差是15，那么10和25的最大 公约数，等同于10和15的最大公约数。</p>
<p>java代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGreatestCommonDivisorV3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">     <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">     <span class="keyword">if</span> (big % small == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> small;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> getGreatestCommonDivisorV3(big-small, small);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-最优解-综合位运算"><a href="#3-最优解-综合位运算" class="headerlink" title="3.最优解(综合位运算)"></a>3.最优解(综合位运算)</h3><ul>
<li><p>当a和b均为偶数时，gcd(a,b) = 2×gcd(a/2, b/2) = 2×gcd(a&gt;&gt;1,b&gt;&gt;1)。</p>
</li>
<li><p>当a为偶数，b为奇数时，gcd(a,b) = gcd(a/2,b) = gcd(a&gt;&gt;1,b)。</p>
</li>
<li><p>当a为奇数，b为偶数时，gcd(a,b) = gcd(a,b/2) = gcd(a,b&gt;&gt;1)。 </p>
</li>
<li><p>当a和b均为奇数时，先利用更相减损术运算一次，gcd(a,b) = gcd(b,a-b)，此 时a-b必然是偶数，然后又可以继续进行移位运算。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//a b 同时为偶数数</span></span><br><span class="line">        <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//相当于2(a/2,b/2)</span></span><br><span class="line">            <span class="keyword">return</span> gcd(a&gt;&gt;<span class="number">1</span>,b&gt;&gt;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//a为偶数,b为奇数</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((a &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(a&gt;&gt;<span class="number">1</span>,b);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; (b &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(a,b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//同为奇数进行一次用更相减损术</span></span><br><span class="line">            <span class="keyword">int</span> big = a &gt; b ? a : b;</span><br><span class="line">            <span class="keyword">int</span> small = a &gt; b ? b : a;</span><br><span class="line">            <span class="keyword">return</span> gcd(big-small,small);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="判断一个数是不是2的整数次幂"><a href="#判断一个数是不是2的整数次幂" class="headerlink" title="判断一个数是不是2的整数次幂"></a>判断一个数是不是2的整数次幂</h1><p> (num&amp;num-1) == 0 为整数次幂  num&amp;num-1的作用是将该数的最后一位1改为0</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-快速排序" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"
    >快速排序</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2020-05-15T01:43:38.174Z" itemprop="datePublished">2020-05-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Quick2Sort</span><span class="params">(values []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(values) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mid, i := values[<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">	head, tail := <span class="number">0</span>, <span class="built_in">len</span>(values)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> head &lt; tail &#123;</span><br><span class="line">		fmt.Println(values)</span><br><span class="line">		<span class="keyword">if</span> values[i] &gt; mid &#123;</span><br><span class="line">			values[i], values[tail] = values[tail], values[i]</span><br><span class="line">			tail--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			values[i], values[head] = values[head], values[i]</span><br><span class="line">			head++</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	values[head] = mid</span><br><span class="line">	Quick2Sort(values[:head])</span><br><span class="line">	Quick2Sort(values[head+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        第一步,取排序数组的第一个元素values[0],然后从第二个元素遍历数组,将values[0]与该元素比较,如果大于values[0],就将其放到数组末尾(依次往前),否则放到前边(依次往后),直到两个指针相遇,然后将中间值与第一个数进行调换,然后以改值为中心将其分割为两个数组,继续递归调用该方法.</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="comment">//外层步长控制</span></span><br><span class="line">    <span class="keyword">for</span> step := <span class="built_in">len</span>(nums) / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//开始插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i := step; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="comment">//满足条件则插入</span></span><br><span class="line">            <span class="keyword">for</span> j := i - step; j &gt;= <span class="number">0</span> &amp;&amp; nums[j+step] &lt; nums[j]; j -= step &#123;</span><br><span class="line">                nums[j], nums[j+step] = nums[j+step], nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> 丰之霸
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
</body>

</html>